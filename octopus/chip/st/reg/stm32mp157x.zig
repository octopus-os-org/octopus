const mmio = @import("mmio.zig");

pub const devices = struct {
    ///  STM32MP157x
    pub const STM32MP157x = struct {
        pub const peripherals = struct {
            ///  TIM2
            pub const TIM2 = @as(*volatile types.peripherals.TIM2, @ptrFromInt(0x40000000));
            ///  TIM3
            pub const TIM3 = @as(*volatile types.peripherals.TIM3, @ptrFromInt(0x40001000));
            ///  TIM4
            pub const TIM4 = @as(*volatile types.peripherals.TIM4, @ptrFromInt(0x40002000));
            ///  TIM5
            pub const TIM5 = @as(*volatile types.peripherals.TIM5, @ptrFromInt(0x40003000));
            ///  TIM6
            pub const TIM6 = @as(*volatile types.peripherals.TIM6, @ptrFromInt(0x40004000));
            ///  TIM7
            pub const TIM7 = @as(*volatile types.peripherals.TIM7, @ptrFromInt(0x40005000));
            ///  TIM12
            pub const TIM12 = @as(*volatile types.peripherals.TIM12, @ptrFromInt(0x40006000));
            ///  TIM13
            pub const TIM13 = @as(*volatile types.peripherals.TIM13, @ptrFromInt(0x40007000));
            ///  TIM14
            pub const TIM14 = @as(*volatile types.peripherals.TIM14, @ptrFromInt(0x40008000));
            ///  LPTIM1
            pub const LPTIM1 = @as(*volatile types.peripherals.LPTIM1, @ptrFromInt(0x40009000));
            ///  WWDG1
            pub const WWDG1 = @as(*volatile types.peripherals.WWDG1, @ptrFromInt(0x4000a000));
            ///  SPI1
            pub const SPI2 = @as(*volatile types.peripherals.SPI1, @ptrFromInt(0x4000b000));
            ///  SPI1
            pub const SPI3 = @as(*volatile types.peripherals.SPI1, @ptrFromInt(0x4000c000));
            ///  SPDIFRX
            pub const SPDIFRX = @as(*volatile types.peripherals.SPDIFRX, @ptrFromInt(0x4000d000));
            ///  Universal synchronous asynchronous receiver transmitter
            pub const USART2 = @as(*volatile types.peripherals.USART1, @ptrFromInt(0x4000e000));
            ///  Universal synchronous asynchronous receiver transmitter
            pub const USART3 = @as(*volatile types.peripherals.USART1, @ptrFromInt(0x4000f000));
            ///  Universal synchronous asynchronous receiver transmitter
            pub const USART4 = @as(*volatile types.peripherals.USART1, @ptrFromInt(0x40010000));
            ///  Universal synchronous asynchronous receiver transmitter
            pub const USART5 = @as(*volatile types.peripherals.USART1, @ptrFromInt(0x40011000));
            ///  I2C1
            pub const I2C1 = @as(*volatile types.peripherals.I2C1, @ptrFromInt(0x40012000));
            ///  I2C1
            pub const I2C2 = @as(*volatile types.peripherals.I2C1, @ptrFromInt(0x40013000));
            ///  I2C1
            pub const I2C3 = @as(*volatile types.peripherals.I2C1, @ptrFromInt(0x40014000));
            ///  I2C1
            pub const I2C5 = @as(*volatile types.peripherals.I2C1, @ptrFromInt(0x40015000));
            ///  HDMI_CEC
            pub const HDMI_CEC = @as(*volatile types.peripherals.HDMI_CEC, @ptrFromInt(0x40016000));
            ///  DAC1
            pub const DAC1 = @as(*volatile types.peripherals.DAC1, @ptrFromInt(0x40017000));
            ///  Universal synchronous asynchronous receiver transmitter
            pub const USART7 = @as(*volatile types.peripherals.USART1, @ptrFromInt(0x40018000));
            ///  Universal synchronous asynchronous receiver transmitter
            pub const USART8 = @as(*volatile types.peripherals.USART1, @ptrFromInt(0x40019000));
            ///  MDIOS
            pub const MDIOS = @as(*volatile types.peripherals.MDIOS, @ptrFromInt(0x4001c000));
            ///  TIM1
            pub const TIM1 = @as(*volatile types.peripherals.TIM1, @ptrFromInt(0x44000000));
            ///  TIM8
            pub const TIM8 = @as(*volatile types.peripherals.TIM8, @ptrFromInt(0x44001000));
            ///  Universal synchronous asynchronous receiver transmitter
            pub const USART6 = @as(*volatile types.peripherals.USART1, @ptrFromInt(0x44003000));
            ///  SPI1
            pub const SPI1 = @as(*volatile types.peripherals.SPI1, @ptrFromInt(0x44004000));
            ///  SPI1
            pub const SPI4 = @as(*volatile types.peripherals.SPI1, @ptrFromInt(0x44005000));
            ///  TIM15
            pub const TIM15 = @as(*volatile types.peripherals.TIM15, @ptrFromInt(0x44006000));
            ///  TIM16
            pub const TIM16 = @as(*volatile types.peripherals.TIM16, @ptrFromInt(0x44007000));
            ///  TIM16
            pub const TIM17 = @as(*volatile types.peripherals.TIM16, @ptrFromInt(0x44008000));
            ///  SPI1
            pub const SPI5 = @as(*volatile types.peripherals.SPI1, @ptrFromInt(0x44009000));
            ///  SAI1 register block
            pub const SAI1 = @as(*volatile types.peripherals.SAI1, @ptrFromInt(0x4400a000));
            ///  SAI1 register block
            pub const SAI2 = @as(*volatile types.peripherals.SAI1, @ptrFromInt(0x4400b000));
            ///  SAI1 register block
            pub const SAI3 = @as(*volatile types.peripherals.SAI1, @ptrFromInt(0x4400c000));
            ///  DFSDM1
            pub const DFSDM1 = @as(*volatile types.peripherals.DFSDM1, @ptrFromInt(0x4400d000));
            ///  FDCAN1
            pub const FDCAN1 = @as(*volatile types.peripherals.FDCAN1, @ptrFromInt(0x4400e000));
            ///  FDCAN1
            pub const FDCAN2 = @as(*volatile types.peripherals.FDCAN1, @ptrFromInt(0x4400f000));
            ///  CCU
            pub const CCU = @as(*volatile types.peripherals.CCU, @ptrFromInt(0x44010000));
            ///  DMA1
            pub const DMA1 = @as(*volatile types.peripherals.DMA1, @ptrFromInt(0x48000000));
            ///  DMA1
            pub const DMA2 = @as(*volatile types.peripherals.DMA1, @ptrFromInt(0x48001000));
            ///  DMAMUX1
            pub const DMAMUX1 = @as(*volatile types.peripherals.DMAMUX1, @ptrFromInt(0x48002000));
            ///  ADC
            pub const ADC = @as(*volatile types.peripherals.ADC, @ptrFromInt(0x48003000));
            ///  ADC2
            pub const ADC2 = @as(*volatile types.peripherals.ADC2, @ptrFromInt(0x48003100));
            ///  Analog-to-Digital Converter
            pub const ADC_common = @as(*volatile types.peripherals.ADC_common, @ptrFromInt(0x48003300));
            ///  SDMMC1
            pub const SDMMC3 = @as(*volatile types.peripherals.SDMMC1, @ptrFromInt(0x48004000));
            ///  DLYBSD1
            pub const DLYBSD3 = @as(*volatile types.peripherals.DLYBSD1, @ptrFromInt(0x48005000));
            ///  OTG
            pub const OTG = @as(*volatile types.peripherals.OTG, @ptrFromInt(0x49000000));
            ///  HSEM
            pub const HSEM = @as(*volatile types.peripherals.HSEM, @ptrFromInt(0x4c000000));
            ///  IPCC
            pub const IPCC = @as(*volatile types.peripherals.IPCC, @ptrFromInt(0x4c001000));
            ///  HASH register block
            pub const HASH2 = @as(*volatile types.peripherals.HASH2, @ptrFromInt(0x4c002000));
            ///  RNG1
            pub const RNG2 = @as(*volatile types.peripherals.RNG1, @ptrFromInt(0x4c003000));
            ///  CRC1
            pub const CRC2 = @as(*volatile types.peripherals.CRC1, @ptrFromInt(0x4c004000));
            ///  CRYP1
            pub const CRYP2 = @as(*volatile types.peripherals.CRYP1, @ptrFromInt(0x4c005000));
            ///  DCMI
            pub const DCMI = @as(*volatile types.peripherals.DCMI, @ptrFromInt(0x4c006000));
            ///  RCC
            pub const RCC = @as(*volatile types.peripherals.RCC, @ptrFromInt(0x50000000));
            ///  PWR
            pub const PWR = @as(*volatile types.peripherals.PWR, @ptrFromInt(0x50001000));
            ///  GPIOA
            pub const GPIOA = @as(*volatile types.peripherals.GPIOA, @ptrFromInt(0x50002000));
            ///  GPIOB
            pub const GPIOB = @as(*volatile types.peripherals.GPIOB, @ptrFromInt(0x50003000));
            ///  GPIOC
            pub const GPIOC = @as(*volatile types.peripherals.GPIOC, @ptrFromInt(0x50004000));
            ///  GPIOD
            pub const GPIOD = @as(*volatile types.peripherals.GPIOD, @ptrFromInt(0x50005000));
            ///  GPIOE
            pub const GPIOE = @as(*volatile types.peripherals.GPIOE, @ptrFromInt(0x50006000));
            ///  GPIOF
            pub const GPIOF = @as(*volatile types.peripherals.GPIOF, @ptrFromInt(0x50007000));
            ///  GPIOG
            pub const GPIOG = @as(*volatile types.peripherals.GPIOG, @ptrFromInt(0x50008000));
            ///  GPIOH
            pub const GPIOH = @as(*volatile types.peripherals.GPIOH, @ptrFromInt(0x50009000));
            ///  GPIOI
            pub const GPIOI = @as(*volatile types.peripherals.GPIOI, @ptrFromInt(0x5000a000));
            ///  GPIOJ
            pub const GPIOJ = @as(*volatile types.peripherals.GPIOJ, @ptrFromInt(0x5000b000));
            ///  GPIOK
            pub const GPIOK = @as(*volatile types.peripherals.GPIOK, @ptrFromInt(0x5000c000));
            ///  EXTI
            pub const EXTI = @as(*volatile types.peripherals.EXTI, @ptrFromInt(0x5000d000));
            ///  SYSCFG
            pub const SYSCFG = @as(*volatile types.peripherals.SYSCFG, @ptrFromInt(0x50020000));
            ///  LPTIM1
            pub const LPTIM2 = @as(*volatile types.peripherals.LPTIM1, @ptrFromInt(0x50021000));
            ///  LPTIM1
            pub const LPTIM3 = @as(*volatile types.peripherals.LPTIM1, @ptrFromInt(0x50022000));
            ///  LPTIM1
            pub const LPTIM4 = @as(*volatile types.peripherals.LPTIM1, @ptrFromInt(0x50023000));
            ///  LPTIM1
            pub const LPTIM5 = @as(*volatile types.peripherals.LPTIM1, @ptrFromInt(0x50024000));
            ///  VREFBUF
            pub const VREFBUF = @as(*volatile types.peripherals.VREFBUF, @ptrFromInt(0x50025000));
            ///  SAI1 register block
            pub const SAI4 = @as(*volatile types.peripherals.SAI1, @ptrFromInt(0x50027000));
            ///  DTS register block
            pub const DTS = @as(*volatile types.peripherals.DTS, @ptrFromInt(0x50028000));
            ///  HDP
            pub const HDP = @as(*volatile types.peripherals.HDP, @ptrFromInt(0x5002a000));
            ///  CRYP1
            pub const CRYP1 = @as(*volatile types.peripherals.CRYP1, @ptrFromInt(0x54001000));
            ///  HASH register block
            pub const HASH1 = @as(*volatile types.peripherals.HASH1, @ptrFromInt(0x54002000));
            ///  RNG1
            pub const RNG1 = @as(*volatile types.peripherals.RNG1, @ptrFromInt(0x54003000));
            ///  GPIOZ
            pub const GPIOZ = @as(*volatile types.peripherals.GPIOZ, @ptrFromInt(0x54004000));
            ///  AXIMC_Mx
            pub const AXIMC_Mx = @as(*volatile types.peripherals.AXIMC_Mx, @ptrFromInt(0x57042024));
            ///  MDMA1
            pub const MDMA = @as(*volatile types.peripherals.MDMA, @ptrFromInt(0x58000000));
            ///  FMC register block
            pub const FMC = @as(*volatile types.peripherals.FMC, @ptrFromInt(0x58002000));
            ///  QUADSPI1
            pub const QUADSPI = @as(*volatile types.peripherals.QUADSPI, @ptrFromInt(0x58003000));
            ///  DLYBQS
            pub const DLYBQS = @as(*volatile types.peripherals.DLYBQS, @ptrFromInt(0x58004000));
            ///  SDMMC1
            pub const SDMMC1 = @as(*volatile types.peripherals.SDMMC1, @ptrFromInt(0x58005000));
            ///  DLYBSD1
            pub const DLYBSD1 = @as(*volatile types.peripherals.DLYBSD1, @ptrFromInt(0x58006000));
            ///  SDMMC1
            pub const SDMMC2 = @as(*volatile types.peripherals.SDMMC1, @ptrFromInt(0x58007000));
            ///  DLYBSD1
            pub const DLYBSD2 = @as(*volatile types.peripherals.DLYBSD1, @ptrFromInt(0x58008000));
            ///  CRC1
            pub const CRC1 = @as(*volatile types.peripherals.CRC1, @ptrFromInt(0x58009000));
            ///  ETH_MAC_MMC
            pub const ETH_MAC_MMC = @as(*volatile types.peripherals.ETH_MAC_MMC, @ptrFromInt(0x5800a000));
            ///  ETH_MTL
            pub const ETH_MTL = @as(*volatile types.peripherals.ETH_MTL, @ptrFromInt(0x5800ac00));
            ///  ETH_DMA
            pub const ETH_DMA = @as(*volatile types.peripherals.ETH_DMA, @ptrFromInt(0x5800b000));
            ///  DSIHOST1
            pub const DSIHOST1 = @as(*volatile types.peripherals.DSIHOST1, @ptrFromInt(0x5a000000));
            ///  LTDC
            pub const LTDC = @as(*volatile types.peripherals.LTDC, @ptrFromInt(0x5a001000));
            ///  IWDG1
            pub const IWDG2 = @as(*volatile types.peripherals.IWDG1, @ptrFromInt(0x5a002000));
            ///  DDRCTRL
            pub const DDRCTRL = @as(*volatile types.peripherals.DDRCTRL, @ptrFromInt(0x5a003000));
            ///  DDRPHYC
            pub const DDRPHYC = @as(*volatile types.peripherals.DDRPHYC, @ptrFromInt(0x5a004000));
            ///  STGENR
            pub const STGENR = @as(*volatile types.peripherals.STGENR, @ptrFromInt(0x5a005000));
            ///  USBPHYC
            pub const USBPHYC = @as(*volatile types.peripherals.USBPHYC, @ptrFromInt(0x5a006000));
            ///  DDRPERFM
            pub const DDRPERFM = @as(*volatile types.peripherals.DDRPERFM, @ptrFromInt(0x5a007000));
            ///  Universal synchronous asynchronous receiver transmitter
            pub const USART1 = @as(*volatile types.peripherals.USART1, @ptrFromInt(0x5c000000));
            ///  SPI1
            pub const SPI6 = @as(*volatile types.peripherals.SPI1, @ptrFromInt(0x5c001000));
            ///  I2C1
            pub const I2C4 = @as(*volatile types.peripherals.I2C1, @ptrFromInt(0x5c002000));
            ///  IWDG1
            pub const IWDG1 = @as(*volatile types.peripherals.IWDG1, @ptrFromInt(0x5c003000));
            ///  RTC
            pub const RTC = @as(*volatile types.peripherals.RTC, @ptrFromInt(0x5c004000));
            ///  BSEC2
            pub const BSEC = @as(*volatile types.peripherals.BSEC, @ptrFromInt(0x5c005000));
            ///  TZC
            pub const TZC = @as(*volatile types.peripherals.TZC, @ptrFromInt(0x5c006000));
            ///  ETZPC
            pub const ETZPC = @as(*volatile types.peripherals.ETZPC, @ptrFromInt(0x5c007000));
            ///  STGENC
            pub const STGENC = @as(*volatile types.peripherals.STGENC, @ptrFromInt(0x5c008000));
            ///  I2C1
            pub const I2C6 = @as(*volatile types.peripherals.I2C1, @ptrFromInt(0x5c009000));
            ///  TAMP
            pub const TAMP = @as(*volatile types.peripherals.TAMP, @ptrFromInt(0x5c00a000));
            ///  GICD
            pub const GICD = @as(*volatile types.peripherals.GICD, @ptrFromInt(0xa0021000));
            ///  GICC
            pub const GICC = @as(*volatile types.peripherals.GICC, @ptrFromInt(0xa0022000));
            ///  GICH
            pub const GICH = @as(*volatile types.peripherals.GICH, @ptrFromInt(0xa0024000));
            ///  GICV
            pub const GICV = @as(*volatile types.peripherals.GICV, @ptrFromInt(0xa0026000));
            ///  Nested Vectored Interrupt Controller
            pub const NVIC = @as(*volatile types.peripherals.NVIC, @ptrFromInt(0xe000e100));
        };
    };
};

pub const types = struct {
    pub const peripherals = struct {
        ///  ADC
        pub const ADC = extern struct {
            ///  ADC interrupt and status register
            ADC_ISR: mmio.Mmio(packed struct(u32) {
                ///  ADRDY
                ADRDY: u1,
                ///  EOSMP
                EOSMP: u1,
                ///  EOC
                EOC: u1,
                ///  EOS
                EOS: u1,
                ///  OVR
                OVR: u1,
                ///  JEOC
                JEOC: u1,
                ///  JEOS
                JEOS: u1,
                ///  AWD1
                AWD1: u1,
                ///  AWD2
                AWD2: u1,
                ///  AWD3
                AWD3: u1,
                ///  JQOVF
                JQOVF: u1,
                padding: u21,
            }),
            ///  ADC interrupt enable register
            ADC_IER: mmio.Mmio(packed struct(u32) {
                ///  ADRDYIE
                ADRDYIE: u1,
                ///  EOSMPIE
                EOSMPIE: u1,
                ///  EOCIE
                EOCIE: u1,
                ///  EOSIE
                EOSIE: u1,
                ///  OVRIE
                OVRIE: u1,
                ///  JEOCIE
                JEOCIE: u1,
                ///  JEOSIE
                JEOSIE: u1,
                ///  AWD1IE
                AWD1IE: u1,
                ///  AWD2IE
                AWD2IE: u1,
                ///  AWD3IE
                AWD3IE: u1,
                ///  JQOVFIE
                JQOVFIE: u1,
                padding: u21,
            }),
            ///  ADC control register
            ADC_CR: mmio.Mmio(packed struct(u32) {
                ///  ADEN
                ADEN: u1,
                ///  ADDIS
                ADDIS: u1,
                ///  ADSTART
                ADSTART: u1,
                ///  JADSTART
                JADSTART: u1,
                ///  ADSTP
                ADSTP: u1,
                ///  JADSTP
                JADSTP: u1,
                reserved8: u2,
                ///  BOOST
                BOOST: u1,
                reserved16: u7,
                ///  ADCALLIN
                ADCALLIN: u1,
                reserved22: u5,
                ///  LINCALRDYW1
                LINCALRDYW1: u1,
                ///  LINCALRDYW2
                LINCALRDYW2: u1,
                ///  LINCALRDYW3
                LINCALRDYW3: u1,
                ///  LINCALRDYW4
                LINCALRDYW4: u1,
                ///  LINCALRDYW5
                LINCALRDYW5: u1,
                ///  LINCALRDYW6
                LINCALRDYW6: u1,
                ///  ADVREGEN
                ADVREGEN: u1,
                ///  DEEPPWD
                DEEPPWD: u1,
                ///  ADCALDIF
                ADCALDIF: u1,
                ///  ADCAL
                ADCAL: u1,
            }),
            ///  ADC configuration register
            ADC_CFGR: mmio.Mmio(packed struct(u32) {
                ///  DMNGT
                DMNGT: u2,
                ///  RES
                RES: u3,
                ///  EXTSEL
                EXTSEL: u5,
                ///  EXTEN
                EXTEN: u2,
                ///  OVRMOD
                OVRMOD: u1,
                ///  CONT
                CONT: u1,
                ///  AUTDLY
                AUTDLY: u1,
                reserved16: u1,
                ///  DISCEN
                DISCEN: u1,
                ///  DISCNUM
                DISCNUM: u3,
                ///  JDISCEN
                JDISCEN: u1,
                ///  JQM
                JQM: u1,
                ///  AWD1SGL
                AWD1SGL: u1,
                ///  AWD1EN
                AWD1EN: u1,
                ///  JAWD1EN
                JAWD1EN: u1,
                ///  JAUTO
                JAUTO: u1,
                ///  AWD1CH
                AWD1CH: u5,
                ///  JQDIS
                JQDIS: u1,
            }),
            ///  ADC configuration register 2
            ADC_CFGR2: mmio.Mmio(packed struct(u32) {
                ///  ROVSE
                ROVSE: u1,
                ///  JOVSE
                JOVSE: u1,
                reserved5: u3,
                ///  OVSS
                OVSS: u4,
                ///  TROVS
                TROVS: u1,
                ///  ROVSM
                ROVSM: u1,
                ///  RSHIFT1
                RSHIFT1: u1,
                ///  RSHIFT2
                RSHIFT2: u1,
                ///  RSHIFT3
                RSHIFT3: u1,
                ///  RSHIFT4
                RSHIFT4: u1,
                reserved16: u1,
                ///  OSVR
                OSVR: u10,
                reserved28: u2,
                ///  LSHIFT
                LSHIFT: u4,
            }),
            ///  ADC sample time register 1
            ADC_SMPR1: mmio.Mmio(packed struct(u32) {
                ///  SMP0
                SMP0: u3,
                ///  SMP1
                SMP1: u3,
                ///  SMP2
                SMP2: u3,
                ///  SMP3
                SMP3: u3,
                ///  SMP4
                SMP4: u3,
                ///  SMP5
                SMP5: u3,
                ///  SMP6
                SMP6: u3,
                ///  SMP7
                SMP7: u3,
                ///  SMP8
                SMP8: u3,
                ///  SMP9
                SMP9: u3,
                padding: u2,
            }),
            ///  ADC sample time register 2
            ADC_SMPR2: mmio.Mmio(packed struct(u32) {
                ///  SMP10
                SMP10: u3,
                ///  SMP11
                SMP11: u3,
                ///  SMP12
                SMP12: u3,
                ///  SMP13
                SMP13: u3,
                ///  SMP14
                SMP14: u3,
                ///  SMP15
                SMP15: u3,
                ///  SMP16
                SMP16: u3,
                ///  SMP17
                SMP17: u3,
                ///  SMP18
                SMP18: u3,
                ///  SMP19
                SMP19: u3,
                padding: u2,
            }),
            ///  ADC channel preselection register
            ADC_PCSEL: mmio.Mmio(packed struct(u32) {
                ///  PCSEL0
                PCSEL0: u1,
                ///  PCSEL1
                PCSEL1: u1,
                ///  PCSEL2
                PCSEL2: u1,
                ///  PCSEL3
                PCSEL3: u1,
                ///  PCSEL4
                PCSEL4: u1,
                ///  PCSEL5
                PCSEL5: u1,
                ///  PCSEL6
                PCSEL6: u1,
                ///  PCSEL7
                PCSEL7: u1,
                ///  PCSEL8
                PCSEL8: u1,
                ///  PCSEL9
                PCSEL9: u1,
                ///  PCSEL10
                PCSEL10: u1,
                ///  PCSEL11
                PCSEL11: u1,
                ///  PCSEL12
                PCSEL12: u1,
                ///  PCSEL13
                PCSEL13: u1,
                ///  PCSEL14
                PCSEL14: u1,
                ///  PCSEL15
                PCSEL15: u1,
                ///  PCSEL16
                PCSEL16: u1,
                ///  PCSEL17
                PCSEL17: u1,
                ///  PCSEL18
                PCSEL18: u1,
                ///  PCSEL19
                PCSEL19: u1,
                padding: u12,
            }),
            ///  ADC watchdog threshold register 1
            ADC_LTR1: mmio.Mmio(packed struct(u32) {
                ///  LTR1
                LTR1: u26,
                padding: u6,
            }),
            ///  ADC watchdog threshold register 1
            ADC_HTR1: mmio.Mmio(packed struct(u32) {
                ///  HTR1
                HTR1: u26,
                padding: u6,
            }),
            reserved48: [8]u8,
            ///  ADC regular sequence register 1
            ADC_SQR1: mmio.Mmio(packed struct(u32) {
                ///  L
                L: u4,
                reserved6: u2,
                ///  SQ1
                SQ1: u5,
                reserved12: u1,
                ///  SQ2
                SQ2: u5,
                reserved18: u1,
                ///  SQ3
                SQ3: u5,
                reserved24: u1,
                ///  SQ4
                SQ4: u5,
                padding: u3,
            }),
            ///  ADC regular sequence register 2
            ADC_SQR2: mmio.Mmio(packed struct(u32) {
                ///  SQ5
                SQ5: u5,
                reserved6: u1,
                ///  SQ6
                SQ6: u5,
                reserved12: u1,
                ///  SQ7
                SQ7: u5,
                reserved18: u1,
                ///  SQ8
                SQ8: u5,
                reserved24: u1,
                ///  SQ9
                SQ9: u5,
                padding: u3,
            }),
            ///  ADC regular sequence register 3
            ADC_SQR3: mmio.Mmio(packed struct(u32) {
                ///  SQ10
                SQ10: u5,
                reserved6: u1,
                ///  SQ11
                SQ11: u5,
                reserved12: u1,
                ///  SQ12
                SQ12: u5,
                reserved18: u1,
                ///  SQ13
                SQ13: u5,
                reserved24: u1,
                ///  SQ14
                SQ14: u5,
                padding: u3,
            }),
            ///  ADC regular sequence register 4
            ADC_SQR4: mmio.Mmio(packed struct(u32) {
                ///  SQ15
                SQ15: u5,
                reserved6: u1,
                ///  SQ16
                SQ16: u5,
                padding: u21,
            }),
            ///  ADC regular Data Register
            ADC_DR: mmio.Mmio(packed struct(u32) {
                ///  RDATA
                RDATA: u32,
            }),
            reserved76: [8]u8,
            ///  ADC injected sequence register
            ADC_JSQR: mmio.Mmio(packed struct(u32) {
                ///  JL
                JL: u2,
                ///  JEXTSEL
                JEXTSEL: u5,
                ///  JEXTEN
                JEXTEN: u2,
                ///  JSQ1
                JSQ1: u5,
                reserved15: u1,
                ///  JSQ2
                JSQ2: u5,
                reserved21: u1,
                ///  JSQ3
                JSQ3: u5,
                reserved27: u1,
                ///  JSQ4
                JSQ4: u5,
            }),
            reserved96: [16]u8,
            ///  ADC offset register
            ADC_OFR1: mmio.Mmio(packed struct(u32) {
                ///  OFFSET1
                OFFSET1: u26,
                ///  OFFSET1_CH
                OFFSET1_CH: u5,
                ///  SSATE
                SSATE: u1,
            }),
            ///  ADC offset register
            ADC_OFR2: mmio.Mmio(packed struct(u32) {
                ///  OFFSET2
                OFFSET2: u26,
                ///  OFFSET2_CH
                OFFSET2_CH: u5,
                ///  SSATE
                SSATE: u1,
            }),
            ///  ADC offset register
            ADC_OFR3: mmio.Mmio(packed struct(u32) {
                ///  OFFSET3
                OFFSET3: u26,
                ///  OFFSET3_CH
                OFFSET3_CH: u5,
                ///  SSATE
                SSATE: u1,
            }),
            ///  ADC offset register
            ADC_OFR4: mmio.Mmio(packed struct(u32) {
                ///  OFFSET4
                OFFSET4: u26,
                ///  OFFSET4_CH
                OFFSET4_CH: u5,
                ///  SSATE
                SSATE: u1,
            }),
            reserved128: [16]u8,
            ///  ADC injected data register
            ADC_JDR1: mmio.Mmio(packed struct(u32) {
                ///  JDATA
                JDATA: u32,
            }),
            ///  ADC injected data register
            ADC_JDR2: mmio.Mmio(packed struct(u32) {
                ///  JDATA
                JDATA: u32,
            }),
            ///  ADC injected data register
            ADC_JDR3: mmio.Mmio(packed struct(u32) {
                ///  JDATA
                JDATA: u32,
            }),
            ///  ADC injected data register
            ADC_JDR4: mmio.Mmio(packed struct(u32) {
                ///  JDATA
                JDATA: u32,
            }),
            reserved160: [16]u8,
            ///  ADC analog watchdog 2 configuration register
            ADC_AWD2CR: mmio.Mmio(packed struct(u32) {
                ///  AWD2CH
                AWD2CH: u20,
                padding: u12,
            }),
            ///  ADC analog watchdog 3 configuration register
            ADC_AWD3CR: mmio.Mmio(packed struct(u32) {
                ///  AWD3CH
                AWD3CH: u20,
                padding: u12,
            }),
            reserved176: [8]u8,
            ///  ADC watchdog lower threshold register 2
            ADC_LTR2: mmio.Mmio(packed struct(u32) {
                ///  LTR2
                LTR2: u26,
                padding: u6,
            }),
            ///  ADC watchdog higher threshold register 2
            ADC_HTR2: mmio.Mmio(packed struct(u32) {
                ///  HTR2
                HTR2: u26,
                padding: u6,
            }),
            ///  ADC watchdog lower threshold register 3
            ADC_LTR3: mmio.Mmio(packed struct(u32) {
                ///  LTR3
                LTR3: u26,
                padding: u6,
            }),
            ///  ADC watchdog higher threshold register 3
            ADC_HTR3: mmio.Mmio(packed struct(u32) {
                ///  HTR3
                HTR3: u26,
                padding: u6,
            }),
            ///  ADC differential mode selection register
            ADC_DIFSEL: mmio.Mmio(packed struct(u32) {
                ///  DIFSEL
                DIFSEL: u20,
                padding: u12,
            }),
            ///  ADC calibration factors register
            ADC_CALFACT: mmio.Mmio(packed struct(u32) {
                ///  CALFACT_S
                CALFACT_S: u11,
                reserved16: u5,
                ///  CALFACT_D
                CALFACT_D: u11,
                padding: u5,
            }),
            ///  ADC calibration factor register 2
            ADC_CALFACT2: mmio.Mmio(packed struct(u32) {
                ///  LINCALFACT
                LINCALFACT: u30,
                padding: u2,
            }),
        };

        ///  ADC2
        pub const ADC2 = extern struct {
            ///  ADC interrupt and status register
            ADC_ISR: mmio.Mmio(packed struct(u32) {
                ///  ADRDY
                ADRDY: u1,
                ///  EOSMP
                EOSMP: u1,
                ///  EOC
                EOC: u1,
                ///  EOS
                EOS: u1,
                ///  OVR
                OVR: u1,
                ///  JEOC
                JEOC: u1,
                ///  JEOS
                JEOS: u1,
                ///  AWD1
                AWD1: u1,
                ///  AWD2
                AWD2: u1,
                ///  AWD3
                AWD3: u1,
                ///  JQOVF
                JQOVF: u1,
                padding: u21,
            }),
            ///  ADC interrupt enable register
            ADC_IER: mmio.Mmio(packed struct(u32) {
                ///  ADRDYIE
                ADRDYIE: u1,
                ///  EOSMPIE
                EOSMPIE: u1,
                ///  EOCIE
                EOCIE: u1,
                ///  EOSIE
                EOSIE: u1,
                ///  OVRIE
                OVRIE: u1,
                ///  JEOCIE
                JEOCIE: u1,
                ///  JEOSIE
                JEOSIE: u1,
                ///  AWD1IE
                AWD1IE: u1,
                ///  AWD2IE
                AWD2IE: u1,
                ///  AWD3IE
                AWD3IE: u1,
                ///  JQOVFIE
                JQOVFIE: u1,
                padding: u21,
            }),
            ///  ADC control register
            ADC_CR: mmio.Mmio(packed struct(u32) {
                ///  ADEN
                ADEN: u1,
                ///  ADDIS
                ADDIS: u1,
                ///  ADSTART
                ADSTART: u1,
                ///  JADSTART
                JADSTART: u1,
                ///  ADSTP
                ADSTP: u1,
                ///  JADSTP
                JADSTP: u1,
                reserved8: u2,
                ///  BOOST
                BOOST: u1,
                reserved16: u7,
                ///  ADCALLIN
                ADCALLIN: u1,
                reserved22: u5,
                ///  LINCALRDYW1
                LINCALRDYW1: u1,
                ///  LINCALRDYW2
                LINCALRDYW2: u1,
                ///  LINCALRDYW3
                LINCALRDYW3: u1,
                ///  LINCALRDYW4
                LINCALRDYW4: u1,
                ///  LINCALRDYW5
                LINCALRDYW5: u1,
                ///  LINCALRDYW6
                LINCALRDYW6: u1,
                ///  ADVREGEN
                ADVREGEN: u1,
                ///  DEEPPWD
                DEEPPWD: u1,
                ///  ADCALDIF
                ADCALDIF: u1,
                ///  ADCAL
                ADCAL: u1,
            }),
            ///  ADC configuration register
            ADC_CFGR: mmio.Mmio(packed struct(u32) {
                ///  DMNGT
                DMNGT: u2,
                ///  RES
                RES: u3,
                ///  EXTSEL
                EXTSEL: u5,
                ///  EXTEN
                EXTEN: u2,
                ///  OVRMOD
                OVRMOD: u1,
                ///  CONT
                CONT: u1,
                ///  AUTDLY
                AUTDLY: u1,
                reserved16: u1,
                ///  DISCEN
                DISCEN: u1,
                ///  DISCNUM
                DISCNUM: u3,
                ///  JDISCEN
                JDISCEN: u1,
                ///  JQM
                JQM: u1,
                ///  AWD1SGL
                AWD1SGL: u1,
                ///  AWD1EN
                AWD1EN: u1,
                ///  JAWD1EN
                JAWD1EN: u1,
                ///  JAUTO
                JAUTO: u1,
                ///  AWD1CH
                AWD1CH: u5,
                ///  JQDIS
                JQDIS: u1,
            }),
            ///  ADC configuration register 2
            ADC_CFGR2: mmio.Mmio(packed struct(u32) {
                ///  ROVSE
                ROVSE: u1,
                ///  JOVSE
                JOVSE: u1,
                reserved5: u3,
                ///  OVSS
                OVSS: u4,
                ///  TROVS
                TROVS: u1,
                ///  ROVSM
                ROVSM: u1,
                ///  RSHIFT1
                RSHIFT1: u1,
                ///  RSHIFT2
                RSHIFT2: u1,
                ///  RSHIFT3
                RSHIFT3: u1,
                ///  RSHIFT4
                RSHIFT4: u1,
                reserved16: u1,
                ///  OSVR
                OSVR: u10,
                reserved28: u2,
                ///  LSHIFT
                LSHIFT: u4,
            }),
            ///  ADC sample time register 1
            ADC_SMPR1: mmio.Mmio(packed struct(u32) {
                ///  SMP0
                SMP0: u3,
                ///  SMP1
                SMP1: u3,
                ///  SMP2
                SMP2: u3,
                ///  SMP3
                SMP3: u3,
                ///  SMP4
                SMP4: u3,
                ///  SMP5
                SMP5: u3,
                ///  SMP6
                SMP6: u3,
                ///  SMP7
                SMP7: u3,
                ///  SMP8
                SMP8: u3,
                ///  SMP9
                SMP9: u3,
                padding: u2,
            }),
            ///  ADC sample time register 2
            ADC_SMPR2: mmio.Mmio(packed struct(u32) {
                ///  SMP10
                SMP10: u3,
                ///  SMP11
                SMP11: u3,
                ///  SMP12
                SMP12: u3,
                ///  SMP13
                SMP13: u3,
                ///  SMP14
                SMP14: u3,
                ///  SMP15
                SMP15: u3,
                ///  SMP16
                SMP16: u3,
                ///  SMP17
                SMP17: u3,
                ///  SMP18
                SMP18: u3,
                ///  SMP19
                SMP19: u3,
                padding: u2,
            }),
            ///  ADC channel preselection register
            ADC_PCSEL: mmio.Mmio(packed struct(u32) {
                ///  PCSEL0
                PCSEL0: u1,
                ///  PCSEL1
                PCSEL1: u1,
                ///  PCSEL2
                PCSEL2: u1,
                ///  PCSEL3
                PCSEL3: u1,
                ///  PCSEL4
                PCSEL4: u1,
                ///  PCSEL5
                PCSEL5: u1,
                ///  PCSEL6
                PCSEL6: u1,
                ///  PCSEL7
                PCSEL7: u1,
                ///  PCSEL8
                PCSEL8: u1,
                ///  PCSEL9
                PCSEL9: u1,
                ///  PCSEL10
                PCSEL10: u1,
                ///  PCSEL11
                PCSEL11: u1,
                ///  PCSEL12
                PCSEL12: u1,
                ///  PCSEL13
                PCSEL13: u1,
                ///  PCSEL14
                PCSEL14: u1,
                ///  PCSEL15
                PCSEL15: u1,
                ///  PCSEL16
                PCSEL16: u1,
                ///  PCSEL17
                PCSEL17: u1,
                ///  PCSEL18
                PCSEL18: u1,
                ///  PCSEL19
                PCSEL19: u1,
                padding: u12,
            }),
            ///  ADC watchdog threshold register 1
            ADC_LTR1: mmio.Mmio(packed struct(u32) {
                ///  LTR1
                LTR1: u26,
                padding: u6,
            }),
            ///  ADC watchdog threshold register 1
            ADC_HTR1: mmio.Mmio(packed struct(u32) {
                ///  HTR1
                HTR1: u26,
                padding: u6,
            }),
            reserved48: [8]u8,
            ///  ADC regular sequence register 1
            ADC_SQR1: mmio.Mmio(packed struct(u32) {
                ///  L
                L: u4,
                reserved6: u2,
                ///  SQ1
                SQ1: u5,
                reserved12: u1,
                ///  SQ2
                SQ2: u5,
                reserved18: u1,
                ///  SQ3
                SQ3: u5,
                reserved24: u1,
                ///  SQ4
                SQ4: u5,
                padding: u3,
            }),
            ///  ADC regular sequence register 2
            ADC_SQR2: mmio.Mmio(packed struct(u32) {
                ///  SQ5
                SQ5: u5,
                reserved6: u1,
                ///  SQ6
                SQ6: u5,
                reserved12: u1,
                ///  SQ7
                SQ7: u5,
                reserved18: u1,
                ///  SQ8
                SQ8: u5,
                reserved24: u1,
                ///  SQ9
                SQ9: u5,
                padding: u3,
            }),
            ///  ADC regular sequence register 3
            ADC_SQR3: mmio.Mmio(packed struct(u32) {
                ///  SQ10
                SQ10: u5,
                reserved6: u1,
                ///  SQ11
                SQ11: u5,
                reserved12: u1,
                ///  SQ12
                SQ12: u5,
                reserved18: u1,
                ///  SQ13
                SQ13: u5,
                reserved24: u1,
                ///  SQ14
                SQ14: u5,
                padding: u3,
            }),
            ///  ADC regular sequence register 4
            ADC_SQR4: mmio.Mmio(packed struct(u32) {
                ///  SQ15
                SQ15: u5,
                reserved6: u1,
                ///  SQ16
                SQ16: u5,
                padding: u21,
            }),
            ///  ADC regular Data Register
            ADC_DR: mmio.Mmio(packed struct(u32) {
                ///  RDATA
                RDATA: u32,
            }),
            reserved76: [8]u8,
            ///  ADC injected sequence register
            ADC_JSQR: mmio.Mmio(packed struct(u32) {
                ///  JL
                JL: u2,
                ///  JEXTSEL
                JEXTSEL: u5,
                ///  JEXTEN
                JEXTEN: u2,
                ///  JSQ1
                JSQ1: u5,
                reserved15: u1,
                ///  JSQ2
                JSQ2: u5,
                reserved21: u1,
                ///  JSQ3
                JSQ3: u5,
                reserved27: u1,
                ///  JSQ4
                JSQ4: u5,
            }),
            reserved96: [16]u8,
            ///  ADC offset register
            ADC_OFR1: mmio.Mmio(packed struct(u32) {
                ///  OFFSET1
                OFFSET1: u26,
                ///  OFFSET1_CH
                OFFSET1_CH: u5,
                ///  SSATE
                SSATE: u1,
            }),
            ///  ADC offset register
            ADC_OFR2: mmio.Mmio(packed struct(u32) {
                ///  OFFSET2
                OFFSET2: u26,
                ///  OFFSET2_CH
                OFFSET2_CH: u5,
                ///  SSATE
                SSATE: u1,
            }),
            ///  ADC offset register
            ADC_OFR3: mmio.Mmio(packed struct(u32) {
                ///  OFFSET3
                OFFSET3: u26,
                ///  OFFSET3_CH
                OFFSET3_CH: u5,
                ///  SSATE
                SSATE: u1,
            }),
            ///  ADC offset register
            ADC_OFR4: mmio.Mmio(packed struct(u32) {
                ///  OFFSET4
                OFFSET4: u26,
                ///  OFFSET4_CH
                OFFSET4_CH: u5,
                ///  SSATE
                SSATE: u1,
            }),
            reserved128: [16]u8,
            ///  ADC injected data register
            ADC_JDR1: mmio.Mmio(packed struct(u32) {
                ///  JDATA
                JDATA: u32,
            }),
            ///  ADC injected data register
            ADC_JDR2: mmio.Mmio(packed struct(u32) {
                ///  JDATA
                JDATA: u32,
            }),
            ///  ADC injected data register
            ADC_JDR3: mmio.Mmio(packed struct(u32) {
                ///  JDATA
                JDATA: u32,
            }),
            ///  ADC injected data register
            ADC_JDR4: mmio.Mmio(packed struct(u32) {
                ///  JDATA
                JDATA: u32,
            }),
            reserved160: [16]u8,
            ///  ADC analog watchdog 2 configuration register
            ADC_AWD2CR: mmio.Mmio(packed struct(u32) {
                ///  AWD2CH
                AWD2CH: u20,
                padding: u12,
            }),
            ///  ADC analog watchdog 3 configuration register
            ADC_AWD3CR: mmio.Mmio(packed struct(u32) {
                ///  AWD3CH
                AWD3CH: u20,
                padding: u12,
            }),
            reserved176: [8]u8,
            ///  ADC watchdog lower threshold register 2
            ADC_LTR2: mmio.Mmio(packed struct(u32) {
                ///  LTR2
                LTR2: u26,
                padding: u6,
            }),
            ///  ADC watchdog higher threshold register 2
            ADC_HTR2: mmio.Mmio(packed struct(u32) {
                ///  HTR2
                HTR2: u26,
                padding: u6,
            }),
            ///  ADC watchdog lower threshold register 3
            ADC_LTR3: mmio.Mmio(packed struct(u32) {
                ///  LTR3
                LTR3: u26,
                padding: u6,
            }),
            ///  ADC watchdog higher threshold register 3
            ADC_HTR3: mmio.Mmio(packed struct(u32) {
                ///  HTR3
                HTR3: u26,
                padding: u6,
            }),
            ///  ADC differential mode selection register
            ADC_DIFSEL: mmio.Mmio(packed struct(u32) {
                ///  DIFSEL
                DIFSEL: u20,
                padding: u12,
            }),
            ///  ADC calibration factors register
            ADC_CALFACT: mmio.Mmio(packed struct(u32) {
                ///  CALFACT_S
                CALFACT_S: u11,
                reserved16: u5,
                ///  CALFACT_D
                CALFACT_D: u11,
                padding: u5,
            }),
            ///  ADC calibration factor register 2
            ADC_CALFACT2: mmio.Mmio(packed struct(u32) {
                ///  LINCALFACT
                LINCALFACT: u30,
                padding: u2,
            }),
            reserved208: [4]u8,
            ///  ADC2 option register
            ADC2_OR: mmio.Mmio(packed struct(u32) {
                ///  VDDCOREEN
                VDDCOREEN: u1,
                padding: u31,
            }),
        };

        ///  Analog-to-Digital Converter
        pub const ADC_common = extern struct {
            ///  ADC Common status register
            CSR: mmio.Mmio(packed struct(u32) {
                ///  ADDRDY_MST
                ADDRDY_MST: u1,
                ///  EOSMP_MST
                EOSMP_MST: u1,
                ///  EOC_MST
                EOC_MST: u1,
                ///  EOS_MST
                EOS_MST: u1,
                ///  OVR_MST
                OVR_MST: u1,
                ///  JEOC_MST
                JEOC_MST: u1,
                ///  JEOS_MST
                JEOS_MST: u1,
                ///  AWD1_MST
                AWD1_MST: u1,
                ///  AWD2_MST
                AWD2_MST: u1,
                ///  AWD3_MST
                AWD3_MST: u1,
                ///  JQOVF_MST
                JQOVF_MST: u1,
                reserved16: u5,
                ///  ADRDY_SLV
                ADRDY_SLV: u1,
                ///  EOSMP_SLV
                EOSMP_SLV: u1,
                ///  EOC_SLV
                EOC_SLV: u1,
                ///  EOS_SLV
                EOS_SLV: u1,
                ///  OVR_SLV
                OVR_SLV: u1,
                ///  JEOC_SLV
                JEOC_SLV: u1,
                ///  JEOS_SLV
                JEOS_SLV: u1,
                ///  AWD1_SLV
                AWD1_SLV: u1,
                ///  AWD2_SLV
                AWD2_SLV: u1,
                ///  AWD3_SLV
                AWD3_SLV: u1,
                ///  JQOVF_SLV
                JQOVF_SLV: u1,
                padding: u5,
            }),
            reserved8: [4]u8,
            ///  ADC common control register
            CCR: mmio.Mmio(packed struct(u32) {
                ///  DUAL
                DUAL: u5,
                reserved8: u3,
                ///  DELAY
                DELAY: u3,
                reserved13: u2,
                ///  DMACFG
                DMACFG: u1,
                ///  MDMA
                MDMA: u2,
                ///  ADC clock mode
                CKMODE: u2,
                ///  ADC prescaler
                PRESC: u4,
                ///  VREFINT enable
                VREFEN: u1,
                ///  CH17SEL
                CH17SEL: u1,
                ///  CH18SEL
                CH18SEL: u1,
                padding: u7,
            }),
            ///  Common regular data register for dual mode
            CDR: mmio.Mmio(packed struct(u32) {
                ///  RDATA_MST
                RDATA_MST: u16,
                ///  RDATA_SLV
                RDATA_SLV: u16,
            }),
            ///  Common regular data register for dual mode
            CDR2: mmio.Mmio(packed struct(u32) {
                ///  RDATA_ALT
                RDATA_ALT: u32,
            }),
        };

        ///  AXIMC_Mx
        pub const AXIMC_Mx = extern struct {
            ///  AXIMC master 0 packing functionality register
            AXIMC_M0_FN_MOD2: mmio.Mmio(packed struct(u32) {
                ///  BYPASS_MERGE
                BYPASS_MERGE: u1,
                padding: u31,
            }),
            reserved220: [216]u8,
            ///  AXIMC master 0 read priority register
            AXIMC_M0_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  AR_QOS
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 0 issuing capability override functionality register
            AXIMC_M0_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  WRITE_ISS_OVERRIDE
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            ///  AXIMC master 0 write priority register
            AXIMC_M0_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  AW_QOS
                AW_QOS: u4,
                padding: u28,
            }),
            reserved4096: [3864]u8,
            ///  AXIMC master 1 packing functionality register
            AXIMC_M1_FN_MOD2: mmio.Mmio(packed struct(u32) {
                ///  BYPASS_MERGE
                BYPASS_MERGE: u1,
                padding: u31,
            }),
            reserved4316: [216]u8,
            ///  AXIMC master 1 read priority register
            AXIMC_M1_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  AR_QOS
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 1 write priority register
            AXIMC_M1_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  AW_QOS
                AW_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 1 issuing capability override functionality register
            AXIMC_M1_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  WRITE_ISS_OVERRIDE
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved8144: [3816]u8,
            ///  AXIMC peripheral ID4 register
            AXIMC_PERIPH_ID_4: mmio.Mmio(packed struct(u32) {
                ///  JEP106CON
                JEP106CON: u4,
                ///  K4COUNT
                K4COUNT: u4,
                padding: u24,
            }),
            ///  AXIMC peripheral ID5 register
            AXIMC_PERIPH_ID_5: mmio.Mmio(packed struct(u32) {
                ///  PERIPH_ID_5
                PERIPH_ID_5: u8,
                padding: u24,
            }),
            ///  AXIMC peripheral ID6 register
            AXIMC_PERIPH_ID_6: mmio.Mmio(packed struct(u32) {
                ///  PERIPH_ID_6
                PERIPH_ID_6: u8,
                padding: u24,
            }),
            ///  AXIMC peripheral ID7 register
            AXIMC_PERIPH_ID_7: mmio.Mmio(packed struct(u32) {
                ///  PERIPH_ID_7
                PERIPH_ID_7: u8,
                padding: u24,
            }),
            ///  AXIMC peripheral ID0 register
            AXIMC_PERIPH_ID_0: mmio.Mmio(packed struct(u32) {
                ///  PERIPH_ID_0
                PERIPH_ID_0: u8,
                padding: u24,
            }),
            ///  AXIMC peripheral ID1 register
            AXIMC_PERIPH_ID_1: mmio.Mmio(packed struct(u32) {
                ///  PERIPH_ID_1
                PERIPH_ID_1: u8,
                padding: u24,
            }),
            ///  AXIMC peripheral ID2 register
            AXIMC_PERIPH_ID_2: mmio.Mmio(packed struct(u32) {
                ///  PERIPH_ID_2
                PERIPH_ID_2: u8,
                padding: u24,
            }),
            ///  AXIMC peripheral ID3 register
            AXIMC_PERIPH_ID_3: mmio.Mmio(packed struct(u32) {
                ///  CUST_MOD_NUM
                CUST_MOD_NUM: u4,
                ///  REV_AND
                REV_AND: u4,
                padding: u24,
            }),
            ///  AXIMC component ID0 register
            AXIMC_COMP_ID_0: mmio.Mmio(packed struct(u32) {
                ///  PREAMBLE
                PREAMBLE: u8,
                padding: u24,
            }),
            ///  AXIMC component ID1 register
            AXIMC_COMP_ID_1: mmio.Mmio(packed struct(u32) {
                ///  PREAMBLE
                PREAMBLE: u4,
                ///  CLASS
                CLASS: u4,
                padding: u24,
            }),
            ///  AXIMC component ID2 register
            AXIMC_COMP_ID_2: mmio.Mmio(packed struct(u32) {
                ///  PREAMBLE
                PREAMBLE: u8,
                padding: u24,
            }),
            ///  AXIMC component ID3 register
            AXIMC_COMP_ID_3: mmio.Mmio(packed struct(u32) {
                ///  PREAMBLE
                PREAMBLE: u8,
                padding: u24,
            }),
            ///  AXIMC master 2 packing functionality register
            AXIMC_M2_FN_MOD2: mmio.Mmio(packed struct(u32) {
                ///  BYPASS_MERGE
                BYPASS_MERGE: u1,
                padding: u31,
            }),
            reserved8412: [216]u8,
            ///  AXIMC master 2 read priority register
            AXIMC_M2_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  AR_QOS
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 2 write priority register
            AXIMC_M2_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  AW_QOS
                AW_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 2 issuing capability override functionality register
            AXIMC_M2_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  WRITE_ISS_OVERRIDE
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved12288: [3864]u8,
            ///  AXIMC master 5 packing functionality register
            AXIMC_M5_FN_MOD2: mmio.Mmio(packed struct(u32) {
                ///  BYPASS_MERGE
                BYPASS_MERGE: u1,
                padding: u31,
            }),
            reserved12508: [216]u8,
            ///  AXIMC master 5 read priority register
            AXIMC_M5_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  AR_QOS
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 5 write priority register
            AXIMC_M5_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  AW_QOS
                AW_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 5 issuing capability override functionality register
            AXIMC_M5_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  WRITE_ISS_OVERRIDE
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved16604: [4084]u8,
            ///  AXIMC master 3 read priority register
            AXIMC_M3_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  AR_QOS
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 3 write priority register
            AXIMC_M3_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  AW_QOS
                AW_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 3 packing functionality register
            AXIMC_M3_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  WRITE_ISS_OVERRIDE
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved20700: [4084]u8,
            ///  AXIMC master 7 read priority register
            AXIMC_M7_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  AR_QOS
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 7 write priority register
            AXIMC_M7_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  AW_QOS
                AW_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 7 issuing capability override functionality register
            AXIMC_M7_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  WRITE_ISS_OVERRIDE
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved24796: [4084]u8,
            ///  AXIMC master 8 read priority register
            AXIMC_M8_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  AR_QOS
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 8 write priority register
            AXIMC_M8_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  AW_QOS
                AW_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 8 issuing capability override functionality register
            AXIMC_M8_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  WRITE_ISS_OVERRIDE
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved32768: [7960]u8,
            ///  AXIMC master 4 packing functionality register
            AXIMC_M4_FN_MOD2: mmio.Mmio(packed struct(u32) {
                ///  BYPASS_MERGE
                BYPASS_MERGE: u1,
                padding: u31,
            }),
            reserved32988: [216]u8,
            ///  AXIMC master 4 read priority register
            AXIMC_M4_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  AR_QOS
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 4 write priority register
            AXIMC_M4_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  AW_QOS
                AW_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 4 packing functionality register
            AXIMC_M4_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  WRITE_ISS_OVERRIDE
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved37084: [4084]u8,
            ///  AXIMC master 9 read priority register
            AXIMC_M9_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  AR_QOS
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 9 write priority register
            AXIMC_M9_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  AW_QOS
                AW_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 9 issuing capability override functionality register
            AXIMC_M9_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  WRITE_ISS_OVERRIDE
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved41180: [4084]u8,
            ///  AXIMC master 10 read priority register
            AXIMC_M10_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  AR_QOS
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 10 write priority register
            AXIMC_M10_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  AW_QOS
                AW_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 10 issuing capability override functionality register
            AXIMC_M10_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  WRITE_ISS_OVERRIDE
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved45056: [3864]u8,
            ///  AXIMC master 6 packing functionality register
            AXIMC_M6_FN_MOD2: mmio.Mmio(packed struct(u32) {
                ///  BYPASS_MERGE
                BYPASS_MERGE: u1,
                padding: u31,
            }),
            reserved45276: [216]u8,
            ///  AXIMC master 6 read priority register
            AXIMC_M6_READ_QOS: mmio.Mmio(packed struct(u32) {
                ///  AR_QOS
                AR_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 6 write priority register
            AXIMC_M6_WRITE_QOS: mmio.Mmio(packed struct(u32) {
                ///  AW_QOS
                AW_QOS: u4,
                padding: u28,
            }),
            ///  AXIMC master 6 issuing capability override functionality register
            AXIMC_M6_FN_MOD: mmio.Mmio(packed struct(u32) {
                ///  READ_ISS_OVERRIDE
                READ_ISS_OVERRIDE: u1,
                ///  WRITE_ISS_OVERRIDE
                WRITE_ISS_OVERRIDE: u1,
                padding: u30,
            }),
            reserved270376: [225088]u8,
            ///  AXIMC master 0 AHB conversion override functionality register
            AXIMC_M0_FN_MOD_AHB: mmio.Mmio(packed struct(u32) {
                ///  RD_INC_OVERRIDE
                RD_INC_OVERRIDE: u1,
                ///  WR_INC_OVERRIDE
                WR_INC_OVERRIDE: u1,
                padding: u30,
            }),
            reserved274472: [4092]u8,
            ///  AXIMC master 1 AHB conversion override functionality register
            AXIMC_M1_FN_MOD_AHB: mmio.Mmio(packed struct(u32) {
                ///  RD_INC_OVERRIDE
                RD_INC_OVERRIDE: u1,
                ///  WR_INC_OVERRIDE
                WR_INC_OVERRIDE: u1,
                padding: u30,
            }),
            reserved278568: [4092]u8,
            ///  AXIMC master 2 AHB conversion override functionality register
            AXIMC_M2_FN_MOD_AHB: mmio.Mmio(packed struct(u32) {
                ///  RD_INC_OVERRIDE
                RD_INC_OVERRIDE: u1,
                ///  WR_INC_OVERRIDE
                WR_INC_OVERRIDE: u1,
                padding: u30,
            }),
            reserved282664: [4092]u8,
            ///  AXIMC master 5 AHB conversion override functionality register
            AXIMC_M5_FN_MOD_AHB: mmio.Mmio(packed struct(u32) {
                ///  RD_INC_OVERRIDE
                RD_INC_OVERRIDE: u1,
                ///  WR_INC_OVERRIDE
                WR_INC_OVERRIDE: u1,
                padding: u30,
            }),
            reserved303148: [20480]u8,
            ///  AXIMC long burst capability inhibition register
            AXIMC_FN_MOD_LB: mmio.Mmio(packed struct(u32) {
                ///  FN_MOD_LB
                FN_MOD_LB: u1,
                padding: u31,
            }),
            reserved315432: [12280]u8,
            ///  AXIMC master 6 AHB conversion override functionality register
            AXIMC_M6_FN_MOD_AHB: mmio.Mmio(packed struct(u32) {
                ///  RD_INC_OVERRIDE
                RD_INC_OVERRIDE: u1,
                ///  WR_INC_OVERRIDE
                WR_INC_OVERRIDE: u1,
                padding: u30,
            }),
        };

        ///  BSEC2
        pub const BSEC = extern struct {
            ///  BSEC OTP configuration register
            BSEC_OTP_CONFIG: mmio.Mmio(packed struct(u32) {
                ///  PWRUP
                PWRUP: u1,
                ///  FRC
                FRC: u2,
                ///  PRGWIDTH
                PRGWIDTH: u4,
                ///  TREAD
                TREAD: u2,
                padding: u23,
            }),
            ///  BSEC OTP control register
            BSEC_OTP_CONTROL: mmio.Mmio(packed struct(u32) {
                ///  ADDR
                ADDR: u7,
                reserved8: u1,
                ///  PROG
                PROG: u1,
                ///  LOCK
                LOCK: u1,
                padding: u22,
            }),
            ///  BSEC OTP write data register
            BSEC_OTP_WRDATA: mmio.Mmio(packed struct(u32) {
                ///  WRDATA
                WRDATA: u32,
            }),
            ///  BSEC OTP status register
            BSEC_OTP_STATUS: mmio.Mmio(packed struct(u32) {
                ///  SECURE
                SECURE: u1,
                ///  FULLDBG
                FULLDBG: u1,
                ///  INVALID
                INVALID: u1,
                ///  BUSY
                BUSY: u1,
                ///  PROGFAIL
                PROGFAIL: u1,
                ///  PWRON
                PWRON: u1,
                ///  BIST1LOCK
                BIST1LOCK: u1,
                ///  BIST2LOCK
                BIST2LOCK: u1,
                padding: u24,
            }),
            ///  BSEC OTP lock configuration register
            BSEC_OTP_LOCK: mmio.Mmio(packed struct(u32) {
                ///  OTP
                OTP: u1,
                ///  ROMLOCK
                ROMLOCK: u1,
                ///  DENREG
                DENREG: u1,
                reserved4: u1,
                ///  GPLOCK
                GPLOCK: u1,
                padding: u27,
            }),
            ///  reset value depends on OTP secure mode according toTable18: BSEC_DENABLE default values after reset on page181.
            BSEC_DENABLE: mmio.Mmio(packed struct(u32) {
                ///  DFTEN
                DFTEN: u1,
                ///  DBGEN
                DBGEN: u1,
                ///  NIDEN
                NIDEN: u1,
                ///  DEVICEEN
                DEVICEEN: u1,
                ///  HDPEN
                HDPEN: u1,
                ///  SPIDEN
                SPIDEN: u1,
                ///  SPNIDEN
                SPNIDEN: u1,
                ///  CP15SDISABLE
                CP15SDISABLE: u2,
                ///  CFGSDISABLE
                CFGSDISABLE: u1,
                ///  DBGSWENABLE
                DBGSWENABLE: u1,
                padding: u21,
            }),
            reserved28: [4]u8,
            ///  BSEC_OTP_DISTURBED0 is used to report disturbed state of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 (lower 1Kbits OTP). BSEC_OTP_DISTURBED1 is used to report disturbed state of BSEC_OTP_DATA32 to BSEC_OTP_DATA63. BSEC_OTP_DISTURBED2 is used to report disturbed state of BSEC_OTP_DATA64 to BSEC_OTP_DATA95.
            BSEC_OTP_DISTURBED0: mmio.Mmio(packed struct(u32) {
                ///  DIS
                DIS: u32,
            }),
            ///  BSEC_OTP_DISTURBED0 is used to report disturbed state of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 (lower 1Kbits OTP). BSEC_OTP_DISTURBED1 is used to report disturbed state of BSEC_OTP_DATA32 to BSEC_OTP_DATA63. BSEC_OTP_DISTURBED2 is used to report disturbed state of BSEC_OTP_DATA64 to BSEC_OTP_DATA95.
            BSEC_OTP_DISTURBED1: mmio.Mmio(packed struct(u32) {
                ///  DIS
                DIS: u32,
            }),
            ///  BSEC_OTP_DISTURBED0 is used to report disturbed state of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 (lower 1Kbits OTP). BSEC_OTP_DISTURBED1 is used to report disturbed state of BSEC_OTP_DATA32 to BSEC_OTP_DATA63. BSEC_OTP_DISTURBED2 is used to report disturbed state of BSEC_OTP_DATA64 to BSEC_OTP_DATA95.
            BSEC_OTP_DISTURBED2: mmio.Mmio(packed struct(u32) {
                ///  DIS
                DIS: u32,
            }),
            reserved52: [12]u8,
            ///  BSEC_OTP_ERROR0 is used to report error state of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 (lower 1Kbits OTP which are protected by 2:1 redundancy). BSEC_OTP_ERROR1 is used to report error state of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 which are protected by 6-bit ECC. BSEC_OTP_ERROR2 is used to report error state of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 which are protected by 6-bit ECC.
            BSEC_OTP_ERROR0: mmio.Mmio(packed struct(u32) {
                ///  ERR
                ERR: u32,
            }),
            ///  BSEC_OTP_ERROR0 is used to report error state of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 (lower 1Kbits OTP which are protected by 2:1 redundancy). BSEC_OTP_ERROR1 is used to report error state of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 which are protected by 6-bit ECC. BSEC_OTP_ERROR2 is used to report error state of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 which are protected by 6-bit ECC.
            BSEC_OTP_ERROR1: mmio.Mmio(packed struct(u32) {
                ///  ERR
                ERR: u32,
            }),
            ///  BSEC_OTP_ERROR0 is used to report error state of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 (lower 1Kbits OTP which are protected by 2:1 redundancy). BSEC_OTP_ERROR1 is used to report error state of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 which are protected by 6-bit ECC. BSEC_OTP_ERROR2 is used to report error state of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 which are protected by 6-bit ECC.
            BSEC_OTP_ERROR2: mmio.Mmio(packed struct(u32) {
                ///  ERR
                ERR: u32,
            }),
            reserved76: [12]u8,
            ///  BSEC_OTP_WLOCK0 is used to report permanent write lock of BSEC_OTP_DATA0 to BSEC_OTP_DATA31. BSEC_OTP_WLOCK1 is used to report permanent write lock of BSEC_OTP_DATA32 to BSEC_OTP_DATA63. BSEC_OTP_WLOCK2 is used to report permanent write lock of BSEC_OTP_DATA64 to BSEC_OTP_DATA95. Permanent write lock requires a programming sequence to lock a word (see section:Section3.3.6: OTP operations on page178).
            BSEC_OTP_WRLOCK0: mmio.Mmio(packed struct(u32) {
                ///  WRLOCK
                WRLOCK: u32,
            }),
            ///  BSEC_OTP_WLOCK0 is used to report permanent write lock of BSEC_OTP_DATA0 to BSEC_OTP_DATA31. BSEC_OTP_WLOCK1 is used to report permanent write lock of BSEC_OTP_DATA32 to BSEC_OTP_DATA63. BSEC_OTP_WLOCK2 is used to report permanent write lock of BSEC_OTP_DATA64 to BSEC_OTP_DATA95. Permanent write lock requires a programming sequence to lock a word (see section:Section3.3.6: OTP operations on page178).
            BSEC_OTP_WRLOCK1: mmio.Mmio(packed struct(u32) {
                ///  WRLOCK
                WRLOCK: u32,
            }),
            ///  BSEC_OTP_WLOCK0 is used to report permanent write lock of BSEC_OTP_DATA0 to BSEC_OTP_DATA31. BSEC_OTP_WLOCK1 is used to report permanent write lock of BSEC_OTP_DATA32 to BSEC_OTP_DATA63. BSEC_OTP_WLOCK2 is used to report permanent write lock of BSEC_OTP_DATA64 to BSEC_OTP_DATA95. Permanent write lock requires a programming sequence to lock a word (see section:Section3.3.6: OTP operations on page178).
            BSEC_OTP_WRLOCK2: mmio.Mmio(packed struct(u32) {
                ///  WRLOCK
                WRLOCK: u32,
            }),
            reserved100: [12]u8,
            ///  BSEC_OTP_SPLOCK0 is used to lock the programming of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset BSEC_OTP_SPLOCK1 is used to lock the programming of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset BSEC_OTP_SPLOCK2 is used to lock the programming of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset Attempt to sticky program locked OTP word are silently ignored.
            BSEC_OTP_SPLOCK0: mmio.Mmio(packed struct(u32) {
                ///  SPLOCK
                SPLOCK: u32,
            }),
            ///  BSEC_OTP_SPLOCK0 is used to lock the programming of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset BSEC_OTP_SPLOCK1 is used to lock the programming of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset BSEC_OTP_SPLOCK2 is used to lock the programming of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset Attempt to sticky program locked OTP word are silently ignored.
            BSEC_OTP_SPLOCK1: mmio.Mmio(packed struct(u32) {
                ///  SPLOCK
                SPLOCK: u32,
            }),
            ///  BSEC_OTP_SPLOCK0 is used to lock the programming of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset BSEC_OTP_SPLOCK1 is used to lock the programming of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset BSEC_OTP_SPLOCK2 is used to lock the programming of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset Attempt to sticky program locked OTP word are silently ignored.
            BSEC_OTP_SPLOCK2: mmio.Mmio(packed struct(u32) {
                ///  SPLOCK
                SPLOCK: u32,
            }),
            reserved124: [12]u8,
            ///  BSEC_OTP_SWLOCK0 is used to prevent writing to BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset. BSEC_OTP_SWLOCK1 is used to prevent writing to BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset. BSEC_OTP_SWLOCK2 is used to prevent writing to BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset. Write to shadow write locked BSEC_OTP_DATA word are silently ignored. Writing to OTP word 0 shadow is always prevented.
            BSEC_OTP_SWLOCK0: mmio.Mmio(packed struct(u32) {
                ///  SWLOCK
                SWLOCK: u32,
            }),
            ///  BSEC_OTP_SWLOCK0 is used to prevent writing to BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset. BSEC_OTP_SWLOCK1 is used to prevent writing to BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset. BSEC_OTP_SWLOCK2 is used to prevent writing to BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset. Write to shadow write locked BSEC_OTP_DATA word are silently ignored. Writing to OTP word 0 shadow is always prevented.
            BSEC_OTP_SWLOCK1: mmio.Mmio(packed struct(u32) {
                ///  SWLOCK
                SWLOCK: u32,
            }),
            ///  BSEC_OTP_SWLOCK0 is used to prevent writing to BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset. BSEC_OTP_SWLOCK1 is used to prevent writing to BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset. BSEC_OTP_SWLOCK2 is used to prevent writing to BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset. Write to shadow write locked BSEC_OTP_DATA word are silently ignored. Writing to OTP word 0 shadow is always prevented.
            BSEC_OTP_SWLOCK2: mmio.Mmio(packed struct(u32) {
                ///  SWLOCK
                SWLOCK: u32,
            }),
            reserved148: [12]u8,
            ///  BSEC_OTP_SRLOCK0 is used to prevent reloading of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset. BSEC_OTP_SRLOCK1 is used to prevent reloading of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset. BSEC_OTP_SRLOCK2 is used to prevent reloading of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset. Setting SRLOCK bits or attempt to reload a locked OTP do not clear the corresponding BSEC_OTP_DATAx shadow register. BSEC_OTP_SRLOCK0 bit 0 is controlled by hardware according to fuse_ok, writing to this bit has no effect.
            BSEC_OTP_SRLOCK0: mmio.Mmio(packed struct(u32) {
                ///  SRLOCK
                SRLOCK: u32,
            }),
            ///  BSEC_OTP_SRLOCK0 is used to prevent reloading of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset. BSEC_OTP_SRLOCK1 is used to prevent reloading of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset. BSEC_OTP_SRLOCK2 is used to prevent reloading of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset. Setting SRLOCK bits or attempt to reload a locked OTP do not clear the corresponding BSEC_OTP_DATAx shadow register. BSEC_OTP_SRLOCK0 bit 0 is controlled by hardware according to fuse_ok, writing to this bit has no effect.
            BSEC_OTP_SRLOCK1: mmio.Mmio(packed struct(u32) {
                ///  SRLOCK
                SRLOCK: u32,
            }),
            ///  BSEC_OTP_SRLOCK0 is used to prevent reloading of BSEC_OTP_DATA0 to BSEC_OTP_DATA31 until next system-reset. BSEC_OTP_SRLOCK1 is used to prevent reloading of BSEC_OTP_DATA32 to BSEC_OTP_DATA63 until next system-reset. BSEC_OTP_SRLOCK2 is used to prevent reloading of BSEC_OTP_DATA64 to BSEC_OTP_DATA95 until next system-reset. Setting SRLOCK bits or attempt to reload a locked OTP do not clear the corresponding BSEC_OTP_DATAx shadow register. BSEC_OTP_SRLOCK0 bit 0 is controlled by hardware according to fuse_ok, writing to this bit has no effect.
            BSEC_OTP_SRLOCK2: mmio.Mmio(packed struct(u32) {
                ///  SRLOCK
                SRLOCK: u32,
            }),
            reserved172: [12]u8,
            ///  BSEC JTAG input register
            BSEC_JTAGIN: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u16,
                padding: u16,
            }),
            ///  BSEC JTAG output register
            BSEC_JTAGOUT: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u16,
                padding: u16,
            }),
            ///  BSEC scratch register
            BSEC_SCRATCH: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            reserved512: [328]u8,
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA0: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA1: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA2: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA3: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA4: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA5: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA6: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA7: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA8: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA9: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA10: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA11: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA12: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA13: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA14: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA15: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA16: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA17: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA18: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA19: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA20: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA21: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA22: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA23: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA24: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA25: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA26: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA27: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA28: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA29: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA30: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA31: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA32: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA33: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA34: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA35: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA36: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA37: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA38: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA39: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA40: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA41: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA42: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA43: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA44: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA45: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA46: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA47: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA48: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA49: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA50: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA51: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA52: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA53: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA54: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA55: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA56: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA57: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA58: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA59: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA60: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA61: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA62: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA63: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA64: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA65: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA66: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA67: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA68: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA69: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA70: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA71: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA72: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA73: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA74: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA75: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA76: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA77: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA78: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA79: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA80: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA81: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA82: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA83: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA84: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA85: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA86: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA87: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA88: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA89: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA90: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA91: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA92: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA93: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA94: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Several OTP directly impact BSEC behavior, such as: BSEC_OTP_DATA0[6:0] (see Table15: OTP modes definition on page175) BSEC_OTP_DATA1, 16 lsb used for SoC features control BSEC_OTP_DATA2, 2 lsb used to control the RAM handling The reset value depends on the actual OTP programmed value and the OTP mode.
            BSEC_OTP_DATA95: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            reserved4080: [3184]u8,
            ///  BSEC hardware configuration register
            BSEC_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  SIZE
                SIZE: u4,
                ///  ECC_USE
                ECC_USE: u4,
                padding: u24,
            }),
            ///  BSEC version register
            BSEC_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  BSEC identification register
            BSEC_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  BSEC size identification register
            BSEC_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  CCU
        pub const CCU = extern struct {
            ///  Clock calibration unit core release register
            FCCAN_CCU_CREL: mmio.Mmio(packed struct(u32) {
                ///  DAY
                DAY: u8,
                ///  MON
                MON: u8,
                ///  YEAR
                YEAR: u4,
                ///  SUBSTEP
                SUBSTEP: u4,
                ///  STEP
                STEP: u4,
                ///  REL
                REL: u4,
            }),
            ///  Calibration configuration register
            FCCAN_CCU_CCFG: mmio.Mmio(packed struct(u32) {
                ///  TQBT
                TQBT: u5,
                reserved6: u1,
                ///  BCC
                BCC: u1,
                ///  CFL
                CFL: u1,
                ///  OCPM
                OCPM: u8,
                ///  CDIV
                CDIV: u4,
                reserved31: u11,
                ///  SWR
                SWR: u1,
            }),
            ///  Calibration status register
            FCCAN_CCU_CSTAT: mmio.Mmio(packed struct(u32) {
                ///  OCPC
                OCPC: u18,
                ///  TQC
                TQC: u11,
                reserved30: u1,
                ///  CALS
                CALS: u2,
            }),
            ///  The calibration watchdog is started after the first falling edge when the calibration FSM is in state Not_Calibrated (CCU_CSTAT.CALS = 00). In this state the calibration watchdog monitors the message received. In case no message was received until the calibration watchdog has counted down to 0, the calibration FSM stays in state Not_Calibrated (CCU_CSTAT.CALS = 00), the counter is reloaded with FDCAN_RWD.WDC and basic calibration is restarted after the next falling edge. When in state Basic_Calibrated (CCU_CSTAT.CALS = 01), the calibration watchdog is restarted with each received message . In case no message was received until the calibration watchdog has counted down to 0, the calibration FSM returns to state Not_Calibrated (CCU_CSTAT.CALS = 00), the counter is reloaded with FDCAN_RWD.WDC and basic calibration is restarted after the next falling edge. When a quartz message is received, state Precision_Calibrated (CCU_CSTAT.CALS = 10) is entered and the calibration watchdog is restarted. In this state the calibration watchdog monitors the quartz message received input. In case no message from a quartz controlled node is received by the attached TTCAN until the calibration watchdog has counted down to 0, the calibration FSM transits back to state Basic_Calibrated (CCU_CSTAT.CALS = 01). The signal is active when the CAN protocol engine on the attached TTCAN is started i.e. when the INIT bit is reset. A calibration watchdog event also sets interrupt flag CCU_IR.CWE. If enabled by CCU_IE.CWEE, interrupt line is activated (set to high). Interrupt line remains active until interrupt flag CCU_IR.CWE is reset.
            FCCAN_CCU_CWD: mmio.Mmio(packed struct(u32) {
                ///  WDC
                WDC: u16,
                ///  WDV
                WDV: u16,
            }),
            ///  The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the register. The configuration of CCU_IE controls whether an interrupt is generated or not.
            FCCAN_CCU_IR: mmio.Mmio(packed struct(u32) {
                ///  CWE
                CWE: u1,
                ///  CSC
                CSC: u1,
                padding: u30,
            }),
            ///  The settings in the CU interrupt enable register determine whether a status change in the CU interrupt register will be signaled on an interrupt line.
            FCCAN_CCU_IE: mmio.Mmio(packed struct(u32) {
                ///  CWEE
                CWEE: u1,
                ///  CSCE
                CSCE: u1,
                padding: u30,
            }),
        };

        ///  CRC1
        pub const CRC1 = extern struct {
            ///  CRC data register
            CRC_DR: mmio.Mmio(packed struct(u32) {
                ///  DR
                DR: u32,
            }),
            ///  CRC independent data register
            CRC_IDR: mmio.Mmio(packed struct(u32) {
                ///  IDR
                IDR: u32,
            }),
            ///  CRC control register
            CRC_CR: mmio.Mmio(packed struct(u32) {
                ///  RESET
                RESET: u1,
                reserved3: u2,
                ///  POLYSIZE
                POLYSIZE: u2,
                ///  REV_IN
                REV_IN: u2,
                ///  REV_OUT
                REV_OUT: u1,
                padding: u24,
            }),
            reserved16: [4]u8,
            ///  CRC initial value
            CRC_INIT: mmio.Mmio(packed struct(u32) {
                ///  CRC_INIT
                CRC_INIT: u32,
            }),
            ///  CRC polynomial
            CRC_POL: mmio.Mmio(packed struct(u32) {
                ///  POL
                POL: u32,
            }),
        };

        ///  WWDG1
        pub const WWDG1 = extern struct {
            ///  Control register
            WWDG_CR: mmio.Mmio(packed struct(u32) {
                ///  T
                T: u7,
                ///  WDGA
                WDGA: u1,
                padding: u24,
            }),
            ///  Configuration register
            WWDG_CFR: mmio.Mmio(packed struct(u32) {
                ///  W
                W: u7,
                reserved9: u2,
                ///  EWI
                EWI: u1,
                reserved11: u1,
                ///  WDGTB
                WDGTB: u3,
                padding: u18,
            }),
            ///  Status register
            WWDG_SR: mmio.Mmio(packed struct(u32) {
                ///  EWIF
                EWIF: u1,
                padding: u31,
            }),
            reserved1008: [996]u8,
            ///  WWDG hardware configuration register
            WWDG_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  PREDIV
                PREDIV: u16,
                padding: u16,
            }),
            ///  WWDG version register
            WWDG_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  WWDG ID register
            WWDG_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  WWDG size ID register
            WWDG_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  CRYP1
        pub const CRYP1 = extern struct {
            ///  CRYP control register
            CRYP_CR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  ALGODIR
                ALGODIR: u1,
                ///  ALGOMODE
                ALGOMODE: u3,
                ///  DATATYPE
                DATATYPE: u2,
                ///  KEYSIZE
                KEYSIZE: u2,
                reserved14: u4,
                ///  FFLUSH
                FFLUSH: u1,
                ///  CRYPEN
                CRYPEN: u1,
                ///  GCM_CCMPH
                GCM_CCMPH: u2,
                reserved19: u1,
                ///  ALGOMODE3
                ALGOMODE3: u1,
                ///  NPBLB
                NPBLB: u4,
                padding: u8,
            }),
            ///  CRYP status register
            CRYP_SR: mmio.Mmio(packed struct(u32) {
                ///  IFEM
                IFEM: u1,
                ///  IFNF
                IFNF: u1,
                ///  OFNE
                OFNE: u1,
                ///  OFFU
                OFFU: u1,
                ///  BUSY
                BUSY: u1,
                padding: u27,
            }),
            ///  The CRYP_DIN register is the data input register. It is 32-bit wide. It is used to enter into the input FIFO up to four 64-bit blocks (TDES) or two 128-bit blocks (AES) of plaintext (when encrypting) or ciphertext (when decrypting), one 32-bit word at a time. To fit different data sizes, the data can be swapped after processing by configuring the DATATYPE bits in the CRYP_CR register. Refer to Section39.3.16: CRYP data registers and data swapping for more details. When CRYP_DIN register is written to the data are pushed into the input FIFO. If CRYPEN = 1, when at least two 32-bit words in the DES/TDES mode have been pushed into the input FIFO (four words in the AES mode), and when at least two words are free in the output FIFO (four words in the AES mode), the CRYP engine starts an encrypting or decrypting process. When CRYP_DIN register is read: If CRYPEN = 0, the FIFO is popped, and then the data present in the Input FIFO are returned, from the oldest one (first reading) to the newest one (last reading). The IFEM flag must be checked before each read operation to make sure that the FIFO is not empty. if CRYPEN = 1, an undefined value is returned. After the CRYP_DIN register has been read once or several times, the FIFO must be flushed by setting the FFLUSH bit prior to processing new data.
            CRYP_DIN: mmio.Mmio(packed struct(u32) {
                ///  DATAIN
                DATAIN: u32,
            }),
            ///  The CRYP_DOUT register is the data output register. It is read-only and 32-bit wide. It is used to retrieve from the output FIFO up to four 64-bit blocks (TDES) or two 128-bit blocks (AES) of plaintext (when encrypting) or ciphertext (when decrypting), one 32-bit word at a time. To fit different data sizes, the data can be swapped after processing by configuring the DATATYPE bits in the CRYP_CR register. Refer to Section39.3.16: CRYP data registers and data swapping for more details. When CRYP_DOUT register is read, the last data entered into the output FIFO (pointed to by the read pointer) is returned.
            CRYP_DOUT: mmio.Mmio(packed struct(u32) {
                ///  DATAOUT
                DATAOUT: u32,
            }),
            ///  CRYP DMA control register
            CRYP_DMACR: mmio.Mmio(packed struct(u32) {
                ///  DIEN
                DIEN: u1,
                ///  DOEN
                DOEN: u1,
                padding: u30,
            }),
            ///  The CRYP_IMSCR register is the interrupt mask set or clear register. It is a read/write register. When a read operation is performed, this register gives the current value of the mask applied to the relevant interrupt. Writing 1 to the particular bit sets the mask, thus enabling the interrupt to be read. Writing 0 to this bit clears the corresponding mask. All the bits are cleared to 0 when the peripheral is reset.
            CRYP_IMSCR: mmio.Mmio(packed struct(u32) {
                ///  INIM
                INIM: u1,
                ///  OUTIM
                OUTIM: u1,
                padding: u30,
            }),
            ///  The CRYP_RISR register is the raw interrupt status register. It is a read-only register. When a read operation is performed, this register gives the current raw status of the corresponding interrupt, i.e. the interrupt information without taking CRYP_IMSCR mask into account. Write operations have no effect.
            CRYP_RISR: mmio.Mmio(packed struct(u32) {
                ///  INRIS
                INRIS: u1,
                ///  OUTRIS
                OUTRIS: u1,
                padding: u30,
            }),
            ///  The CRYP_MISR register is the masked interrupt status register. It is a read-only register. When a read operation is performed, this register gives the current masked status of the corresponding interrupt, i.e. the interrupt information taking CRYP_IMSCR mask into account. Write operations have no effect.
            CRYP_MISR: mmio.Mmio(packed struct(u32) {
                ///  INMIS
                INMIS: u1,
                ///  OUTMIS
                OUTMIS: u1,
                padding: u30,
            }),
            ///  CRYP key registers contain the cryptographic keys. In DES/TDES mode, the keys are 64-bit binary values (number from left to right, that is the leftmost bit is bit 1) and named K1, K2 and K3 (K0 is not used). Each key consists of 56 information bits and 8 parity bits. In AES mode, the key is considered as a single 128, 192 or 256 bits long sequence K0K1K2...K127/191/255. The AES key is entered into the registers as follows: for AES-128: K0..K127 corresponds to b127..b0 (b255..b128 are not used), for AES-192: K0..K191 corresponds to b191..b0 (b255..b192 are not used), for AES-256: K0..K255 corresponds to b255..b0. In all cases key bit K0 is the leftmost bit in CRYP inner memory and register bit b0 is the rightmost bit in corresponding CRYP_KxLR key register. For more information refer to Section39.3.17: CRYP key registers. Write accesses to these registers are disregarded when the cryptographic processor is busy (bit BUSY = 1 in the CRYP_SR register)
            CRYP_K0LR: mmio.Mmio(packed struct(u32) {
                ///  K
                K: u32,
            }),
            ///  Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
            CRYP_K0RR: mmio.Mmio(packed struct(u32) {
                ///  K
                K: u32,
            }),
            ///  Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
            CRYP_K1LR: mmio.Mmio(packed struct(u32) {
                ///  K
                K: u32,
            }),
            ///  Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
            CRYP_K1RR: mmio.Mmio(packed struct(u32) {
                ///  K
                K: u32,
            }),
            ///  Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
            CRYP_K2LR: mmio.Mmio(packed struct(u32) {
                ///  K
                K: u32,
            }),
            ///  Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
            CRYP_K2RR: mmio.Mmio(packed struct(u32) {
                ///  K
                K: u32,
            }),
            ///  Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
            CRYP_K3LR: mmio.Mmio(packed struct(u32) {
                ///  K
                K: u32,
            }),
            ///  Refer to Section39.6.9: CRYP key register 0L (CRYP_K0LR) for details.
            CRYP_K3RR: mmio.Mmio(packed struct(u32) {
                ///  K
                K: u32,
            }),
            ///  The CRYP_IV0...1(L/R)R are the left-word and right-word registers for the initialization vector (64 bits for DES/TDES and 128 bits for AES). For more information refer to Section39.3.18: CRYP initialization vector registers. IV0 is the leftmost bit whereas IV63 (DES, TDES) or IV127 (AES) are the rightmost bits of the initialization vector. IV1(L/R)R is used only in the AES. Only CRYP_IV0(L/R) is used in DES/TDES. Write access to these registers are disregarded when the cryptographic processor is busy (bit BUSY = 1 in the CRYP_SR register).
            CRYP_IV0LR: mmio.Mmio(packed struct(u32) {
                ///  IV31
                IV31: u1,
                ///  IV30
                IV30: u1,
                ///  IV29
                IV29: u1,
                ///  IV28
                IV28: u1,
                ///  IV27
                IV27: u1,
                ///  IV26
                IV26: u1,
                ///  IV25
                IV25: u1,
                ///  IV24
                IV24: u1,
                ///  IV23
                IV23: u1,
                ///  IV22
                IV22: u1,
                ///  IV21
                IV21: u1,
                ///  IV20
                IV20: u1,
                ///  IV19
                IV19: u1,
                ///  IV18
                IV18: u1,
                ///  IV17
                IV17: u1,
                ///  IV16
                IV16: u1,
                ///  IV15
                IV15: u1,
                ///  IV14
                IV14: u1,
                ///  IV13
                IV13: u1,
                ///  IV12
                IV12: u1,
                ///  IV11
                IV11: u1,
                ///  IV10
                IV10: u1,
                ///  IV9
                IV9: u1,
                ///  IV8
                IV8: u1,
                ///  IV7
                IV7: u1,
                ///  IV6
                IV6: u1,
                ///  IV5
                IV5: u1,
                ///  IV4
                IV4: u1,
                ///  IV3
                IV3: u1,
                ///  IV2
                IV2: u1,
                ///  IV1
                IV1: u1,
                ///  IV0
                IV0: u1,
            }),
            ///  Refer to Section39.6.17: CRYP initialization vector register 0L (CRYP_IV0LR) for details.
            CRYP_IV0RR: mmio.Mmio(packed struct(u32) {
                ///  IV63
                IV63: u1,
                ///  IV62
                IV62: u1,
                ///  IV61
                IV61: u1,
                ///  IV60
                IV60: u1,
                ///  IV59
                IV59: u1,
                ///  IV58
                IV58: u1,
                ///  IV57
                IV57: u1,
                ///  IV56
                IV56: u1,
                ///  IV55
                IV55: u1,
                ///  IV54
                IV54: u1,
                ///  IV53
                IV53: u1,
                ///  IV52
                IV52: u1,
                ///  IV51
                IV51: u1,
                ///  IV50
                IV50: u1,
                ///  IV49
                IV49: u1,
                ///  IV48
                IV48: u1,
                ///  IV47
                IV47: u1,
                ///  IV46
                IV46: u1,
                ///  IV45
                IV45: u1,
                ///  IV44
                IV44: u1,
                ///  IV43
                IV43: u1,
                ///  IV42
                IV42: u1,
                ///  IV41
                IV41: u1,
                ///  IV40
                IV40: u1,
                ///  IV39
                IV39: u1,
                ///  IV38
                IV38: u1,
                ///  IV37
                IV37: u1,
                ///  IV36
                IV36: u1,
                ///  IV35
                IV35: u1,
                ///  IV34
                IV34: u1,
                ///  IV33
                IV33: u1,
                ///  IV32
                IV32: u1,
            }),
            ///  Refer to Section39.6.17: CRYP initialization vector register 0L (CRYP_IV0LR) for details.
            CRYP_IV1LR: mmio.Mmio(packed struct(u32) {
                ///  IV95
                IV95: u1,
                ///  IV94
                IV94: u1,
                ///  IV93
                IV93: u1,
                ///  IV92
                IV92: u1,
                ///  IV91
                IV91: u1,
                ///  IV90
                IV90: u1,
                ///  IV89
                IV89: u1,
                ///  IV88
                IV88: u1,
                ///  IV87
                IV87: u1,
                ///  IV86
                IV86: u1,
                ///  IV85
                IV85: u1,
                ///  IV84
                IV84: u1,
                ///  IV83
                IV83: u1,
                ///  IV82
                IV82: u1,
                ///  IV81
                IV81: u1,
                ///  IV80
                IV80: u1,
                ///  IV79
                IV79: u1,
                ///  IV78
                IV78: u1,
                ///  IV77
                IV77: u1,
                ///  IV76
                IV76: u1,
                ///  IV75
                IV75: u1,
                ///  IV74
                IV74: u1,
                ///  IV73
                IV73: u1,
                ///  IV72
                IV72: u1,
                ///  IV71
                IV71: u1,
                ///  IV70
                IV70: u1,
                ///  IV69
                IV69: u1,
                ///  IV68
                IV68: u1,
                ///  IV67
                IV67: u1,
                ///  IV66
                IV66: u1,
                ///  IV65
                IV65: u1,
                ///  IV64
                IV64: u1,
            }),
            ///  Refer to Section39.6.17: CRYP initialization vector register 0L (CRYP_IV0LR) for details.
            CRYP_IV1RR: mmio.Mmio(packed struct(u32) {
                ///  IV127
                IV127: u1,
                ///  IV126
                IV126: u1,
                ///  IV125
                IV125: u1,
                ///  IV124
                IV124: u1,
                ///  IV123
                IV123: u1,
                ///  IV122
                IV122: u1,
                ///  IV121
                IV121: u1,
                ///  IV120
                IV120: u1,
                ///  IV119
                IV119: u1,
                ///  IV118
                IV118: u1,
                ///  IV117
                IV117: u1,
                ///  IV116
                IV116: u1,
                ///  IV115
                IV115: u1,
                ///  IV114
                IV114: u1,
                ///  IV113
                IV113: u1,
                ///  IV112
                IV112: u1,
                ///  IV111
                IV111: u1,
                ///  IV110
                IV110: u1,
                ///  IV109
                IV109: u1,
                ///  IV108
                IV108: u1,
                ///  IV107
                IV107: u1,
                ///  IV106
                IV106: u1,
                ///  IV105
                IV105: u1,
                ///  IV104
                IV104: u1,
                ///  IV103
                IV103: u1,
                ///  IV102
                IV102: u1,
                ///  IV101
                IV101: u1,
                ///  IV100
                IV100: u1,
                ///  IV99
                IV99: u1,
                ///  IV98
                IV98: u1,
                ///  IV97
                IV97: u1,
                ///  IV96
                IV96: u1,
            }),
            ///  These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
            CRYP_CSGCMCCM0R: mmio.Mmio(packed struct(u32) {
                ///  CSGCMCCM0
                CSGCMCCM0: u32,
            }),
            ///  These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
            CRYP_CSGCMCCM1R: mmio.Mmio(packed struct(u32) {
                ///  CSGCMCCM1
                CSGCMCCM1: u32,
            }),
            ///  These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
            CRYP_CSGCMCCM2R: mmio.Mmio(packed struct(u32) {
                ///  CSGCMCCM2
                CSGCMCCM2: u32,
            }),
            ///  These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
            CRYP_CSGCMCCM3R: mmio.Mmio(packed struct(u32) {
                ///  CSGCMCCM3
                CSGCMCCM3: u32,
            }),
            ///  These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
            CRYP_CSGCMCCM4R: mmio.Mmio(packed struct(u32) {
                ///  CSGCMCCM4
                CSGCMCCM4: u32,
            }),
            ///  These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
            CRYP_CSGCMCCM5R: mmio.Mmio(packed struct(u32) {
                ///  CSGCMCCM5
                CSGCMCCM5: u32,
            }),
            ///  These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
            CRYP_CSGCMCCM6R: mmio.Mmio(packed struct(u32) {
                ///  CSGCMCCM6
                CSGCMCCM6: u32,
            }),
            ///  These registers contain the complete internal register states of the CRYP processor when the GCM/GMAC or CCM algorithm is selected. They are useful when a context swap has to be performed because a high-priority task needs the cryptographic processor while it is already in use by another task. When such an event occurs, the CRYP_CSGCMCCM0..7R and CRYP_CSGCM0..7R (in GCM/GMAC mode) or CRYP_CSGCMCCM0..7R (in CCM mode) registers have to be read and the values retrieved have to be saved in the system memory space. The cryptographic processor can then be used by the preemptive task. Then when the cryptographic computation is complete, the saved context can be read from memory and written back into the corresponding context swap registers.
            CRYP_CSGCMCCM7R: mmio.Mmio(packed struct(u32) {
                ///  CSGCMCCM7
                CSGCMCCM7: u32,
            }),
            ///  Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
            CRYP_CSGCM0R: mmio.Mmio(packed struct(u32) {
                ///  CSGCM0
                CSGCM0: u32,
            }),
            ///  Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
            CRYP_CSGCM1R: mmio.Mmio(packed struct(u32) {
                ///  CSGCM1
                CSGCM1: u32,
            }),
            ///  Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
            CRYP_CSGCM2R: mmio.Mmio(packed struct(u32) {
                ///  CSGCM2
                CSGCM2: u32,
            }),
            ///  Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
            CRYP_CSGCM3R: mmio.Mmio(packed struct(u32) {
                ///  CSGCM3
                CSGCM3: u32,
            }),
            ///  Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
            CRYP_CSGCM4R: mmio.Mmio(packed struct(u32) {
                ///  CSGCM4
                CSGCM4: u32,
            }),
            ///  Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
            CRYP_CSGCM5R: mmio.Mmio(packed struct(u32) {
                ///  CSGCM5
                CSGCM5: u32,
            }),
            ///  Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
            CRYP_CSGCM6R: mmio.Mmio(packed struct(u32) {
                ///  CSGCM6
                CSGCM6: u32,
            }),
            ///  Please refer to Section39.6.21: CRYP context swap GCM-CCM registers (CRYP_CSGCMCCMxR) for details.
            CRYP_CSGCM7R: mmio.Mmio(packed struct(u32) {
                ///  CSGCM7
                CSGCM7: u32,
            }),
            reserved1008: [864]u8,
            ///  CRYP hardware configuration register
            CRYP_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  CFG1
                CFG1: u4,
                ///  CFG2
                CFG2: u4,
                ///  CFG3
                CFG3: u4,
                ///  CFG4
                CFG4: u4,
                padding: u16,
            }),
            ///  CRYP HW Version Register
            CRYP_VERR: mmio.Mmio(packed struct(u32) {
                ///  VER
                VER: u8,
                padding: u24,
            }),
            ///  CRYP Identification
            CRYP_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  CRYP HW Magic ID
            CRYP_MID: mmio.Mmio(packed struct(u32) {
                ///  MID
                MID: u32,
            }),
        };

        ///  VREFBUF
        pub const VREFBUF = extern struct {
            ///  VREFBUF control and status register
            VREFBUF_CSR: mmio.Mmio(packed struct(u32) {
                ///  ENVR
                ENVR: u1,
                ///  HIZ
                HIZ: u1,
                reserved3: u1,
                ///  VRR
                VRR: u1,
                ///  VRS
                VRS: u3,
                padding: u25,
            }),
            ///  VREFBUF calibration control register
            VREFBUF_CCR: mmio.Mmio(packed struct(u32) {
                ///  TRIM
                TRIM: u6,
                padding: u26,
            }),
        };

        ///  DAC1
        pub const DAC1 = extern struct {
            ///  DAC control register
            DAC_CR: mmio.Mmio(packed struct(u32) {
                ///  EN1
                EN1: u1,
                ///  TEN1
                TEN1: u1,
                ///  TSEL10
                TSEL10: u1,
                ///  TSEL11
                TSEL11: u1,
                ///  TSEL12
                TSEL12: u1,
                ///  TSEL13
                TSEL13: u1,
                ///  WAVE1
                WAVE1: u2,
                ///  MAMP1
                MAMP1: u4,
                ///  DMAEN1
                DMAEN1: u1,
                ///  DMAUDRIE1
                DMAUDRIE1: u1,
                ///  CEN1
                CEN1: u1,
                ///  HFSEL
                HFSEL: u1,
                ///  EN2
                EN2: u1,
                ///  TEN2
                TEN2: u1,
                ///  TSEL20
                TSEL20: u1,
                ///  TSEL21
                TSEL21: u1,
                ///  TSEL22
                TSEL22: u1,
                ///  TSEL23
                TSEL23: u1,
                ///  WAVE2
                WAVE2: u2,
                ///  MAMP2
                MAMP2: u4,
                ///  DMAEN2
                DMAEN2: u1,
                ///  DMAUDRIE2
                DMAUDRIE2: u1,
                ///  CEN2
                CEN2: u1,
                padding: u1,
            }),
            ///  DAC software trigger register
            DAC_SWTRGR: mmio.Mmio(packed struct(u32) {
                ///  SWTRIG1
                SWTRIG1: u1,
                ///  SWTRIG2
                SWTRIG2: u1,
                padding: u30,
            }),
            ///  DAC channel1 12-bit right-aligned data holding register
            DAC_DHR12R1: mmio.Mmio(packed struct(u32) {
                ///  DACC1DHR
                DACC1DHR: u12,
                padding: u20,
            }),
            ///  DAC channel1 12-bit left aligned data holding register
            DAC_DHR12L1: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  DACC1DHR
                DACC1DHR: u12,
                padding: u16,
            }),
            ///  DAC channel1 8-bit right aligned data holding register
            DAC_DHR8R1: mmio.Mmio(packed struct(u32) {
                ///  DACC1DHR
                DACC1DHR: u8,
                padding: u24,
            }),
            ///  This register is available only on dual-channel DACs. Refer to Section29.3: DAC implementation.
            DAC_DHR12R2: mmio.Mmio(packed struct(u32) {
                ///  DACC2DHR
                DACC2DHR: u12,
                padding: u20,
            }),
            ///  This register is available only on dual-channel DACs. Refer to Section29.3: DAC implementation.
            DAC_DHR12L2: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  DACC2DHR
                DACC2DHR: u12,
                padding: u16,
            }),
            ///  This register is available only on dual-channel DACs. Refer to Section29.3: DAC implementation.
            DAC_DHR8R2: mmio.Mmio(packed struct(u32) {
                ///  DACC2DHR
                DACC2DHR: u8,
                padding: u24,
            }),
            ///  Dual DAC 12-bit right-aligned data holding register
            DAC_DHR12RD: mmio.Mmio(packed struct(u32) {
                ///  DACC1DHR
                DACC1DHR: u12,
                reserved16: u4,
                ///  DACC2DHR
                DACC2DHR: u12,
                padding: u4,
            }),
            ///  Dual DAC 12-bit left aligned data holding register
            DAC_DHR12LD: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  DACC1DHR
                DACC1DHR: u12,
                reserved20: u4,
                ///  DACC2DHR
                DACC2DHR: u12,
            }),
            ///  Dual DAC 8-bit right aligned data holding register
            DAC_DHR8RD: mmio.Mmio(packed struct(u32) {
                ///  DACC1DHR
                DACC1DHR: u8,
                ///  DACC2DHR
                DACC2DHR: u8,
                padding: u16,
            }),
            ///  DAC channel1 data output register
            DAC_DOR1: mmio.Mmio(packed struct(u32) {
                ///  DACC1DOR
                DACC1DOR: u12,
                padding: u20,
            }),
            ///  This register is available only on dual-channel DACs. Refer to Section29.3: DAC implementation.
            DAC_DOR2: mmio.Mmio(packed struct(u32) {
                ///  DACC2DOR
                DACC2DOR: u12,
                padding: u20,
            }),
            ///  DAC status register
            DAC_SR: mmio.Mmio(packed struct(u32) {
                reserved13: u13,
                ///  DMAUDR1
                DMAUDR1: u1,
                ///  CAL_FLAG1
                CAL_FLAG1: u1,
                ///  BWST1
                BWST1: u1,
                reserved29: u13,
                ///  DMAUDR2
                DMAUDR2: u1,
                ///  CAL_FLAG2
                CAL_FLAG2: u1,
                ///  BWST2
                BWST2: u1,
            }),
            ///  DAC calibration control register
            DAC_CCR: mmio.Mmio(packed struct(u32) {
                ///  OTRIM1
                OTRIM1: u5,
                reserved16: u11,
                ///  OTRIM2
                OTRIM2: u5,
                padding: u11,
            }),
            ///  DAC mode control register
            DAC_MCR: mmio.Mmio(packed struct(u32) {
                ///  MODE1
                MODE1: u3,
                reserved16: u13,
                ///  MODE2
                MODE2: u3,
                padding: u13,
            }),
            ///  DAC channel 1 sample and hold sample time register
            DAC_SHSR1: mmio.Mmio(packed struct(u32) {
                ///  TSAMPLE1
                TSAMPLE1: u10,
                padding: u22,
            }),
            ///  This register is available only on dual-channel DACs. Refer to Section29.3: DAC implementation.
            DAC_SHSR2: mmio.Mmio(packed struct(u32) {
                ///  TSAMPLE2
                TSAMPLE2: u10,
                padding: u22,
            }),
            ///  DAC sample and hold time register
            DAC_SHHR: mmio.Mmio(packed struct(u32) {
                ///  THOLD1
                THOLD1: u10,
                reserved16: u6,
                ///  THOLD2
                THOLD2: u10,
                padding: u6,
            }),
            ///  DAC sample and hold refresh time register
            DAC_SHRR: mmio.Mmio(packed struct(u32) {
                ///  TREFRESH1
                TREFRESH1: u8,
                reserved16: u8,
                ///  TREFRESH2
                TREFRESH2: u8,
                padding: u8,
            }),
            reserved1008: [928]u8,
            ///  DAC IP hardware configuration register
            DAC_HWCFGR0: mmio.Mmio(packed struct(u32) {
                ///  DUAL
                DUAL: u4,
                ///  LFSR
                LFSR: u4,
                ///  TRIANGLE
                TRIANGLE: u4,
                ///  SAMPLE
                SAMPLE: u4,
                ///  OR_CFG
                OR_CFG: u8,
                padding: u8,
            }),
            ///  No
            DAC_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  No
            DAC_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  No
            DAC_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  DCMI
        pub const DCMI = extern struct {
            ///  DCMI control register
            DCMI_CR: mmio.Mmio(packed struct(u32) {
                ///  CAPTURE
                CAPTURE: u1,
                ///  CM
                CM: u1,
                ///  CROP
                CROP: u1,
                ///  JPEG
                JPEG: u1,
                ///  ESS
                ESS: u1,
                ///  PCKPOL
                PCKPOL: u1,
                ///  HSPOL
                HSPOL: u1,
                ///  VSPOL
                VSPOL: u1,
                ///  FCRC
                FCRC: u2,
                ///  EDM
                EDM: u2,
                reserved14: u2,
                ///  ENABLE
                ENABLE: u1,
                reserved16: u1,
                ///  BSM
                BSM: u2,
                ///  OEBS
                OEBS: u1,
                ///  LSM
                LSM: u1,
                ///  OELS
                OELS: u1,
                padding: u11,
            }),
            ///  DCMI status register
            DCMI_SR: mmio.Mmio(packed struct(u32) {
                ///  HSYNC
                HSYNC: u1,
                ///  VSYNC
                VSYNC: u1,
                ///  FNE
                FNE: u1,
                padding: u29,
            }),
            ///  DCMI_RIS gives the raw interrupt status and is accessible in read only. When read, this register returns the status of the corresponding interrupt before masking with the DCMI_IER register value.
            DCMI_RIS: mmio.Mmio(packed struct(u32) {
                ///  FRAME_RIS
                FRAME_RIS: u1,
                ///  OVR_RIS
                OVR_RIS: u1,
                ///  ERR_RIS
                ERR_RIS: u1,
                ///  VSYNC_RIS
                VSYNC_RIS: u1,
                ///  LINE_RIS
                LINE_RIS: u1,
                padding: u27,
            }),
            ///  The DCMI_IER register is used to enable interrupts. When one of the DCMI_IER bits is set, the corresponding interrupt is enabled. This register is accessible in both read and write.
            DCMI_IER: mmio.Mmio(packed struct(u32) {
                ///  FRAME_IE
                FRAME_IE: u1,
                ///  OVR_IE
                OVR_IE: u1,
                ///  ERR_IE
                ERR_IE: u1,
                ///  VSYNC_IE
                VSYNC_IE: u1,
                ///  LINE_IE
                LINE_IE: u1,
                padding: u27,
            }),
            ///  This DCMI_MIS register is a read-only register. When read, it returns the current masked status value (depending on the value in DCMI_IER) of the corresponding interrupt. A bit in this register is set if the corresponding enable bit in DCMI_IER is set and the corresponding bit in DCMI_RIS is set.
            DCMI_MIS: mmio.Mmio(packed struct(u32) {
                ///  FRAME_MIS
                FRAME_MIS: u1,
                ///  OVR_MIS
                OVR_MIS: u1,
                ///  ERR_MIS
                ERR_MIS: u1,
                ///  VSYNC_MIS
                VSYNC_MIS: u1,
                ///  LINE_MIS
                LINE_MIS: u1,
                padding: u27,
            }),
            ///  The DCMI_ICR register is write-only.
            DCMI_ICR: mmio.Mmio(packed struct(u32) {
                ///  FRAME_ISC
                FRAME_ISC: u1,
                ///  OVR_ISC
                OVR_ISC: u1,
                ///  ERR_ISC
                ERR_ISC: u1,
                ///  VSYNC_ISC
                VSYNC_ISC: u1,
                ///  LINE_ISC
                LINE_ISC: u1,
                padding: u27,
            }),
            ///  DCMI embedded synchronization code register
            DCMI_ESCR: mmio.Mmio(packed struct(u32) {
                ///  FSC
                FSC: u8,
                ///  LSC
                LSC: u8,
                ///  LEC
                LEC: u8,
                ///  FEC
                FEC: u8,
            }),
            ///  DCMI embedded synchronization unmask register
            DCMI_ESUR: mmio.Mmio(packed struct(u32) {
                ///  FSU
                FSU: u8,
                ///  LSU
                LSU: u8,
                ///  LEU
                LEU: u8,
                ///  FEU
                FEU: u8,
            }),
            ///  DCMI crop window start
            DCMI_CWSTRT: mmio.Mmio(packed struct(u32) {
                ///  HOFFCNT
                HOFFCNT: u14,
                reserved16: u2,
                ///  VST
                VST: u13,
                padding: u3,
            }),
            ///  DCMI crop window size
            DCMI_CWSIZE: mmio.Mmio(packed struct(u32) {
                ///  CAPCNT
                CAPCNT: u14,
                reserved16: u2,
                ///  VLINE
                VLINE: u14,
                padding: u2,
            }),
            ///  DCMI data register
            DCMI_DR: mmio.Mmio(packed struct(u32) {
                ///  Byte0
                Byte0: u8,
                ///  Byte1
                Byte1: u8,
                ///  Byte2
                Byte2: u8,
                ///  Byte3
                Byte3: u8,
            }),
        };

        ///  DDRCTRL
        pub const DDRCTRL = extern struct {
            ///  DDRCTRL master register 0
            DDRCTRL_MSTR: mmio.Mmio(packed struct(u32) {
                ///  DDR3
                DDR3: u1,
                reserved2: u1,
                ///  LPDDR2
                LPDDR2: u1,
                ///  LPDDR3
                LPDDR3: u1,
                reserved9: u5,
                ///  BURSTCHOP
                BURSTCHOP: u1,
                ///  EN_2T_TIMING_MODE
                EN_2T_TIMING_MODE: u1,
                reserved12: u1,
                ///  DATA_BUS_WIDTH
                DATA_BUS_WIDTH: u2,
                reserved15: u1,
                ///  DLL_OFF_MODE
                DLL_OFF_MODE: u1,
                ///  BURST_RDWR
                BURST_RDWR: u4,
                padding: u12,
            }),
            ///  DDRCTRL operating mode status register
            DDRCTRL_STAT: mmio.Mmio(packed struct(u32) {
                ///  OPERATING_MODE
                OPERATING_MODE: u3,
                reserved4: u1,
                ///  SELFREF_TYPE
                SELFREF_TYPE: u2,
                reserved12: u6,
                ///  SELFREF_CAM_NOT_EMPTY
                SELFREF_CAM_NOT_EMPTY: u1,
                padding: u19,
            }),
            reserved16: [8]u8,
            ///  Mode Register Read/Write Control Register 0. Do not enable more than one of the following fields simultaneously: sw_init_int pda_en mpr_en
            DDRCTRL_MRCTRL0: mmio.Mmio(packed struct(u32) {
                ///  MR_TYPE
                MR_TYPE: u1,
                reserved4: u3,
                ///  MR_RANK
                MR_RANK: u1,
                reserved12: u7,
                ///  MR_ADDR
                MR_ADDR: u4,
                reserved31: u15,
                ///  MR_WR
                MR_WR: u1,
            }),
            ///  DDRCTRL mode register read/write control register 1
            DDRCTRL_MRCTRL1: mmio.Mmio(packed struct(u32) {
                ///  MR_DATA
                MR_DATA: u16,
                padding: u16,
            }),
            ///  DDRCTRL mode register read/write status register
            DDRCTRL_MRSTAT: mmio.Mmio(packed struct(u32) {
                ///  MR_WR_BUSY
                MR_WR_BUSY: u1,
                padding: u31,
            }),
            reserved32: [4]u8,
            ///  DDRCTRL temperature derate enable register
            DDRCTRL_DERATEEN: mmio.Mmio(packed struct(u32) {
                ///  DERATE_ENABLE
                DERATE_ENABLE: u1,
                ///  DERATE_VALUE
                DERATE_VALUE: u2,
                reserved4: u1,
                ///  DERATE_BYTE
                DERATE_BYTE: u4,
                padding: u24,
            }),
            ///  DDRCTRL temperature derate interval register
            DDRCTRL_DERATEINT: mmio.Mmio(packed struct(u32) {
                ///  MR4_READ_INTERVAL
                MR4_READ_INTERVAL: u32,
            }),
            reserved48: [8]u8,
            ///  DDRCTRL low power control register
            DDRCTRL_PWRCTL: mmio.Mmio(packed struct(u32) {
                ///  SELFREF_EN
                SELFREF_EN: u1,
                ///  POWERDOWN_EN
                POWERDOWN_EN: u1,
                ///  DEEPPOWERDOWN_EN
                DEEPPOWERDOWN_EN: u1,
                ///  EN_DFI_DRAM_CLK_DISABLE
                EN_DFI_DRAM_CLK_DISABLE: u1,
                reserved5: u1,
                ///  SELFREF_SW
                SELFREF_SW: u1,
                reserved7: u1,
                ///  DIS_CAM_DRAIN_SELFREF
                DIS_CAM_DRAIN_SELFREF: u1,
                padding: u24,
            }),
            ///  DDRCTRL low power timing register
            DDRCTRL_PWRTMG: mmio.Mmio(packed struct(u32) {
                ///  POWERDOWN_TO_X32
                POWERDOWN_TO_X32: u5,
                reserved8: u3,
                ///  T_DPD_X4096
                T_DPD_X4096: u8,
                ///  SELFREF_TO_X32
                SELFREF_TO_X32: u8,
                padding: u8,
            }),
            ///  DDRCTRL hardware low power control register
            DDRCTRL_HWLPCTL: mmio.Mmio(packed struct(u32) {
                ///  HW_LP_EN
                HW_LP_EN: u1,
                ///  HW_LP_EXIT_IDLE_EN
                HW_LP_EXIT_IDLE_EN: u1,
                reserved16: u14,
                ///  HW_LP_IDLE_X32
                HW_LP_IDLE_X32: u12,
                padding: u4,
            }),
            reserved80: [20]u8,
            ///  DDRCTRL refresh control register 0
            DDRCTRL_RFSHCTL0: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  PER_BANK_REFRESH
                PER_BANK_REFRESH: u1,
                reserved4: u1,
                ///  REFRESH_BURST
                REFRESH_BURST: u5,
                reserved12: u3,
                ///  REFRESH_TO_X32
                REFRESH_TO_X32: u5,
                reserved20: u3,
                ///  REFRESH_MARGIN
                REFRESH_MARGIN: u4,
                padding: u8,
            }),
            reserved96: [12]u8,
            ///  DDRCTRL refresh control register 3
            DDRCTRL_RFSHCTL3: mmio.Mmio(packed struct(u32) {
                ///  DIS_AUTO_REFRESH
                DIS_AUTO_REFRESH: u1,
                ///  REFRESH_UPDATE_LEVEL
                REFRESH_UPDATE_LEVEL: u1,
                padding: u30,
            }),
            ///  DDRCTRL refresh timing register
            DDRCTRL_RFSHTMG: mmio.Mmio(packed struct(u32) {
                ///  T_RFC_MIN
                T_RFC_MIN: u10,
                reserved15: u5,
                ///  LPDDR3_TREFBW_EN
                LPDDR3_TREFBW_EN: u1,
                ///  T_RFC_NOM_X1_X32
                T_RFC_NOM_X1_X32: u12,
                reserved31: u3,
                ///  T_RFC_NOM_X1_SEL
                T_RFC_NOM_X1_SEL: u1,
            }),
            reserved192: [88]u8,
            ///  DDRCTRL CRC parity control register 0
            DDRCTRL_CRCPARCTL0: mmio.Mmio(packed struct(u32) {
                ///  DFI_ALERT_ERR_INT_EN
                DFI_ALERT_ERR_INT_EN: u1,
                ///  DFI_ALERT_ERR_INT_CLR
                DFI_ALERT_ERR_INT_CLR: u1,
                ///  DFI_ALERT_ERR_CNT_CLR
                DFI_ALERT_ERR_CNT_CLR: u1,
                padding: u29,
            }),
            reserved204: [8]u8,
            ///  DDRCTRL CRC parity status register
            DDRCTRL_CRCPARSTAT: mmio.Mmio(packed struct(u32) {
                ///  DFI_ALERT_ERR_CNT
                DFI_ALERT_ERR_CNT: u16,
                ///  DFI_ALERT_ERR_INT
                DFI_ALERT_ERR_INT: u1,
                padding: u15,
            }),
            ///  DDRCTRL SDRAM initialization register 0
            DDRCTRL_INIT0: mmio.Mmio(packed struct(u32) {
                ///  PRE_CKE_X1024
                PRE_CKE_X1024: u12,
                reserved16: u4,
                ///  POST_CKE_X1024
                POST_CKE_X1024: u10,
                reserved30: u4,
                ///  SKIP_DRAM_INIT
                SKIP_DRAM_INIT: u2,
            }),
            ///  DDRCTRL SDRAM initialization register 1
            DDRCTRL_INIT1: mmio.Mmio(packed struct(u32) {
                ///  PRE_OCD_X32
                PRE_OCD_X32: u4,
                reserved16: u12,
                ///  DRAM_RSTN_X1024
                DRAM_RSTN_X1024: u9,
                padding: u7,
            }),
            ///  DDRCTRL SDRAM initialization register 2
            DDRCTRL_INIT2: mmio.Mmio(packed struct(u32) {
                ///  MIN_STABLE_CLOCK_X1
                MIN_STABLE_CLOCK_X1: u4,
                reserved8: u4,
                ///  IDLE_AFTER_RESET_X32
                IDLE_AFTER_RESET_X32: u8,
                padding: u16,
            }),
            ///  DDRCTRL SDRAM initialization register 3
            DDRCTRL_INIT3: mmio.Mmio(packed struct(u32) {
                ///  EMR
                EMR: u16,
                ///  MR
                MR: u16,
            }),
            ///  DDRCTRL SDRAM initialization register 4
            DDRCTRL_INIT4: mmio.Mmio(packed struct(u32) {
                ///  EMR3
                EMR3: u16,
                ///  EMR2
                EMR2: u16,
            }),
            ///  DDRCTRL SDRAM initialization register 5
            DDRCTRL_INIT5: mmio.Mmio(packed struct(u32) {
                ///  MAX_AUTO_INIT_X1024
                MAX_AUTO_INIT_X1024: u10,
                reserved16: u6,
                ///  DEV_ZQINIT_X32
                DEV_ZQINIT_X32: u8,
                padding: u8,
            }),
            reserved240: [8]u8,
            ///  DDRCTRL DIMM control register
            DDRCTRL_DIMMCTL: mmio.Mmio(packed struct(u32) {
                ///  DIMM_STAGGER_CS_EN
                DIMM_STAGGER_CS_EN: u1,
                ///  DIMM_ADDR_MIRR_EN
                DIMM_ADDR_MIRR_EN: u1,
                padding: u30,
            }),
            reserved256: [12]u8,
            ///  DDRCTRL SDRAM timing register 0
            DDRCTRL_DRAMTMG0: mmio.Mmio(packed struct(u32) {
                ///  T_RAS_MIN
                T_RAS_MIN: u6,
                reserved8: u2,
                ///  T_RAS_MAX
                T_RAS_MAX: u7,
                reserved16: u1,
                ///  T_FAW
                T_FAW: u6,
                reserved24: u2,
                ///  WR2PRE
                WR2PRE: u7,
                padding: u1,
            }),
            ///  DDRCTRL SDRAM timing register 1
            DDRCTRL_DRAMTMG1: mmio.Mmio(packed struct(u32) {
                ///  T_RC
                T_RC: u7,
                reserved8: u1,
                ///  RD2PRE
                RD2PRE: u6,
                reserved16: u2,
                ///  T_XP
                T_XP: u5,
                padding: u11,
            }),
            ///  DDRCTRL SDRAM timing register 2
            DDRCTRL_DRAMTMG2: mmio.Mmio(packed struct(u32) {
                ///  WR2RD
                WR2RD: u6,
                reserved8: u2,
                ///  RD2WR
                RD2WR: u6,
                reserved16: u2,
                ///  READ_LATENCY
                READ_LATENCY: u6,
                reserved24: u2,
                ///  WRITE_LATENCY
                WRITE_LATENCY: u6,
                padding: u2,
            }),
            ///  DDRCTRL SDRAM timing register 3
            DDRCTRL_DRAMTMG3: mmio.Mmio(packed struct(u32) {
                ///  T_MOD
                T_MOD: u10,
                reserved12: u2,
                ///  T_MRD
                T_MRD: u6,
                reserved20: u2,
                ///  T_MRW
                T_MRW: u10,
                padding: u2,
            }),
            ///  DDRCTRL SDRAM timing register 4
            DDRCTRL_DRAMTMG4: mmio.Mmio(packed struct(u32) {
                ///  T_RP
                T_RP: u5,
                reserved8: u3,
                ///  T_RRD
                T_RRD: u4,
                reserved16: u4,
                ///  T_CCD
                T_CCD: u4,
                reserved24: u4,
                ///  T_RCD
                T_RCD: u5,
                padding: u3,
            }),
            ///  DDRCTRL SDRAM timing register 5
            DDRCTRL_DRAMTMG5: mmio.Mmio(packed struct(u32) {
                ///  T_CKE
                T_CKE: u5,
                reserved8: u3,
                ///  T_CKESR
                T_CKESR: u6,
                reserved16: u2,
                ///  T_CKSRE
                T_CKSRE: u4,
                reserved24: u4,
                ///  T_CKSRX
                T_CKSRX: u4,
                padding: u4,
            }),
            ///  DDRCTRL SDRAM timing register 6
            DDRCTRL_DRAMTMG6: mmio.Mmio(packed struct(u32) {
                ///  T_CKCSX
                T_CKCSX: u4,
                reserved16: u12,
                ///  T_CKDPDX
                T_CKDPDX: u4,
                reserved24: u4,
                ///  T_CKDPDE
                T_CKDPDE: u4,
                padding: u4,
            }),
            ///  DDRCTRL SDRAM timing register 7
            DDRCTRL_DRAMTMG7: mmio.Mmio(packed struct(u32) {
                ///  T_CKPDX
                T_CKPDX: u4,
                reserved8: u4,
                ///  T_CKPDE
                T_CKPDE: u4,
                padding: u20,
            }),
            ///  DDRCTRL SDRAM timing register 8
            DDRCTRL_DRAMTMG8: mmio.Mmio(packed struct(u32) {
                ///  T_XS_X32
                T_XS_X32: u7,
                reserved8: u1,
                ///  T_XS_DLL_X32
                T_XS_DLL_X32: u7,
                padding: u17,
            }),
            reserved312: [20]u8,
            ///  DDRCTRL SDRAM timing register 14
            DDRCTRL_DRAMTMG14: mmio.Mmio(packed struct(u32) {
                ///  T_XSR
                T_XSR: u12,
                padding: u20,
            }),
            ///  DDRCTRL SDRAM timing register 15
            DDRCTRL_DRAMTMG15: mmio.Mmio(packed struct(u32) {
                ///  T_STAB_X32
                T_STAB_X32: u8,
                reserved31: u23,
                ///  EN_DFI_LP_T_STAB
                EN_DFI_LP_T_STAB: u1,
            }),
            reserved384: [64]u8,
            ///  DDRCTRL ZQ control register 0
            DDRCTRL_ZQCTL0: mmio.Mmio(packed struct(u32) {
                ///  T_ZQ_SHORT_NOP
                T_ZQ_SHORT_NOP: u10,
                reserved16: u6,
                ///  T_ZQ_LONG_NOP
                T_ZQ_LONG_NOP: u11,
                reserved29: u2,
                ///  ZQ_RESISTOR_SHARED
                ZQ_RESISTOR_SHARED: u1,
                ///  DIS_SRX_ZQCL
                DIS_SRX_ZQCL: u1,
                ///  DIS_AUTO_ZQ
                DIS_AUTO_ZQ: u1,
            }),
            ///  DDRCTRL ZQ control register 1
            DDRCTRL_ZQCTL1: mmio.Mmio(packed struct(u32) {
                ///  T_ZQ_SHORT_INTERVAL_X1024
                T_ZQ_SHORT_INTERVAL_X1024: u20,
                ///  T_ZQ_RESET_NOP
                T_ZQ_RESET_NOP: u10,
                padding: u2,
            }),
            ///  DDRCTRL ZQ control register 2
            DDRCTRL_ZQCTL2: mmio.Mmio(packed struct(u32) {
                ///  ZQ_RESET
                ZQ_RESET: u1,
                padding: u31,
            }),
            ///  DDRCTRL ZQ status register
            DDRCTRL_ZQSTAT: mmio.Mmio(packed struct(u32) {
                ///  ZQ_RESET_BUSY
                ZQ_RESET_BUSY: u1,
                padding: u31,
            }),
            ///  DDRCTRL DFI timing register 0
            DDRCTRL_DFITMG0: mmio.Mmio(packed struct(u32) {
                ///  DFI_TPHY_WRLAT
                DFI_TPHY_WRLAT: u6,
                reserved8: u2,
                ///  DFI_TPHY_WRDATA
                DFI_TPHY_WRDATA: u6,
                reserved16: u2,
                ///  DFI_T_RDDATA_EN
                DFI_T_RDDATA_EN: u7,
                reserved24: u1,
                ///  DFI_T_CTRL_DELAY
                DFI_T_CTRL_DELAY: u5,
                padding: u3,
            }),
            ///  DDRCTRL DFI timing register 1
            DDRCTRL_DFITMG1: mmio.Mmio(packed struct(u32) {
                ///  DFI_T_DRAM_CLK_ENABLE
                DFI_T_DRAM_CLK_ENABLE: u5,
                reserved8: u3,
                ///  DFI_T_DRAM_CLK_DISABLE
                DFI_T_DRAM_CLK_DISABLE: u5,
                reserved16: u3,
                ///  DFI_T_WRDATA_DELAY
                DFI_T_WRDATA_DELAY: u5,
                padding: u11,
            }),
            ///  DDRCTRL low power configuration register 0
            DDRCTRL_DFILPCFG0: mmio.Mmio(packed struct(u32) {
                ///  DFI_LP_EN_PD
                DFI_LP_EN_PD: u1,
                reserved4: u3,
                ///  DFI_LP_WAKEUP_PD
                DFI_LP_WAKEUP_PD: u4,
                ///  DFI_LP_EN_SR
                DFI_LP_EN_SR: u1,
                reserved12: u3,
                ///  DFI_LP_WAKEUP_SR
                DFI_LP_WAKEUP_SR: u4,
                ///  DFI_LP_EN_DPD
                DFI_LP_EN_DPD: u1,
                reserved20: u3,
                ///  DFI_LP_WAKEUP_DPD
                DFI_LP_WAKEUP_DPD: u4,
                ///  DFI_TLP_RESP
                DFI_TLP_RESP: u5,
                padding: u3,
            }),
            reserved416: [4]u8,
            ///  DDRCTRL DFI update register 0
            DDRCTRL_DFIUPD0: mmio.Mmio(packed struct(u32) {
                ///  DFI_T_CTRLUP_MIN
                DFI_T_CTRLUP_MIN: u10,
                reserved16: u6,
                ///  DFI_T_CTRLUP_MAX
                DFI_T_CTRLUP_MAX: u10,
                reserved29: u3,
                ///  CTRLUPD_PRE_SRX
                CTRLUPD_PRE_SRX: u1,
                ///  DIS_AUTO_CTRLUPD_SRX
                DIS_AUTO_CTRLUPD_SRX: u1,
                ///  DIS_AUTO_CTRLUPD
                DIS_AUTO_CTRLUPD: u1,
            }),
            ///  DDRCTRL DFI update register 1
            DDRCTRL_DFIUPD1: mmio.Mmio(packed struct(u32) {
                ///  DFI_T_CTRLUPD_INTERVAL_MAX_X1024
                DFI_T_CTRLUPD_INTERVAL_MAX_X1024: u8,
                reserved16: u8,
                ///  DFI_T_CTRLUPD_INTERVAL_MIN_X1024
                DFI_T_CTRLUPD_INTERVAL_MIN_X1024: u8,
                padding: u8,
            }),
            ///  DDRCTRL DFI update register 2
            DDRCTRL_DFIUPD2: mmio.Mmio(packed struct(u32) {
                reserved31: u31,
                ///  DFI_PHYUPD_EN
                DFI_PHYUPD_EN: u1,
            }),
            reserved432: [4]u8,
            ///  DDRCTRL DFI miscellaneous control register
            DDRCTRL_DFIMISC: mmio.Mmio(packed struct(u32) {
                ///  DFI_INIT_COMPLETE_EN
                DFI_INIT_COMPLETE_EN: u1,
                reserved4: u3,
                ///  CTL_IDLE_EN
                CTL_IDLE_EN: u1,
                ///  DFI_INIT_START
                DFI_INIT_START: u1,
                reserved8: u2,
                ///  DFI_FREQUENCY
                DFI_FREQUENCY: u5,
                padding: u19,
            }),
            reserved444: [8]u8,
            ///  DDRCTRL DFI status register
            DDRCTRL_DFISTAT: mmio.Mmio(packed struct(u32) {
                ///  DFI_INIT_COMPLETE
                DFI_INIT_COMPLETE: u1,
                ///  DFI_LP_ACK
                DFI_LP_ACK: u1,
                padding: u30,
            }),
            reserved452: [4]u8,
            ///  DDRCTRL DFI PHY master register
            DDRCTRL_DFIPHYMSTR: mmio.Mmio(packed struct(u32) {
                ///  DFI_PHYMSTR_EN
                DFI_PHYMSTR_EN: u1,
                padding: u31,
            }),
            reserved516: [60]u8,
            ///  DDRCTRL address map register 1
            DDRCTRL_ADDRMAP1: mmio.Mmio(packed struct(u32) {
                ///  ADDRMAP_BANK_B0
                ADDRMAP_BANK_B0: u6,
                reserved8: u2,
                ///  ADDRMAP_BANK_B1
                ADDRMAP_BANK_B1: u6,
                reserved16: u2,
                ///  ADDRMAP_BANK_B2
                ADDRMAP_BANK_B2: u6,
                padding: u10,
            }),
            ///  DDRCTRL address map register 2
            DDRCTRL_ADDRMAP2: mmio.Mmio(packed struct(u32) {
                ///  ADDRMAP_COL_B2
                ADDRMAP_COL_B2: u4,
                reserved8: u4,
                ///  ADDRMAP_COL_B3
                ADDRMAP_COL_B3: u4,
                reserved16: u4,
                ///  ADDRMAP_COL_B4
                ADDRMAP_COL_B4: u4,
                reserved24: u4,
                ///  ADDRMAP_COL_B5
                ADDRMAP_COL_B5: u4,
                padding: u4,
            }),
            ///  DDRCTRL address map register 3
            DDRCTRL_ADDRMAP3: mmio.Mmio(packed struct(u32) {
                ///  ADDRMAP_COL_B6
                ADDRMAP_COL_B6: u4,
                reserved8: u4,
                ///  ADDRMAP_COL_B7
                ADDRMAP_COL_B7: u5,
                reserved16: u3,
                ///  ADDRMAP_COL_B8
                ADDRMAP_COL_B8: u5,
                reserved24: u3,
                ///  ADDRMAP_COL_B9
                ADDRMAP_COL_B9: u5,
                padding: u3,
            }),
            ///  DDRCTRL address map register 4
            DDRCTRL_ADDRMAP4: mmio.Mmio(packed struct(u32) {
                ///  ADDRMAP_COL_B10
                ADDRMAP_COL_B10: u5,
                reserved8: u3,
                ///  ADDRMAP_COL_B11
                ADDRMAP_COL_B11: u5,
                padding: u19,
            }),
            ///  DDRCTRL address map register 5
            DDRCTRL_ADDRMAP5: mmio.Mmio(packed struct(u32) {
                ///  ADDRMAP_ROW_B0
                ADDRMAP_ROW_B0: u4,
                reserved8: u4,
                ///  ADDRMAP_ROW_B1
                ADDRMAP_ROW_B1: u4,
                reserved16: u4,
                ///  ADDRMAP_ROW_B2_10
                ADDRMAP_ROW_B2_10: u4,
                reserved24: u4,
                ///  ADDRMAP_ROW_B11
                ADDRMAP_ROW_B11: u4,
                padding: u4,
            }),
            ///  DDRCTRL address register 6
            DDRCTRL_ADDRMAP6: mmio.Mmio(packed struct(u32) {
                ///  ADDRMAP_ROW_B12
                ADDRMAP_ROW_B12: u4,
                reserved8: u4,
                ///  ADDRMAP_ROW_B13
                ADDRMAP_ROW_B13: u4,
                reserved16: u4,
                ///  ADDRMAP_ROW_B14
                ADDRMAP_ROW_B14: u4,
                reserved24: u4,
                ///  ADDRMAP_ROW_B15
                ADDRMAP_ROW_B15: u4,
                reserved31: u3,
                ///  LPDDR3_6GB_12GB
                LPDDR3_6GB_12GB: u1,
            }),
            reserved548: [8]u8,
            ///  DDRCTRL address map register 9
            DDRCTRL_ADDRMAP9: mmio.Mmio(packed struct(u32) {
                ///  ADDRMAP_ROW_B2
                ADDRMAP_ROW_B2: u4,
                reserved8: u4,
                ///  ADDRMAP_ROW_B3
                ADDRMAP_ROW_B3: u4,
                reserved16: u4,
                ///  ADDRMAP_ROW_B4
                ADDRMAP_ROW_B4: u4,
                reserved24: u4,
                ///  ADDRMAP_ROW_B5
                ADDRMAP_ROW_B5: u4,
                padding: u4,
            }),
            ///  DDRCTRL address map register 10
            DDRCTRL_ADDRMAP10: mmio.Mmio(packed struct(u32) {
                ///  ADDRMAP_ROW_B6
                ADDRMAP_ROW_B6: u4,
                reserved8: u4,
                ///  ADDRMAP_ROW_B7
                ADDRMAP_ROW_B7: u4,
                reserved16: u4,
                ///  ADDRMAP_ROW_B8
                ADDRMAP_ROW_B8: u4,
                reserved24: u4,
                ///  ADDRMAP_ROW_B9
                ADDRMAP_ROW_B9: u4,
                padding: u4,
            }),
            ///  DDRCTRL address map register 11
            DDRCTRL_ADDRMAP11: mmio.Mmio(packed struct(u32) {
                ///  ADDRMAP_ROW_B10
                ADDRMAP_ROW_B10: u4,
                padding: u28,
            }),
            reserved576: [16]u8,
            ///  DDRCTRL ODT configuration register
            DDRCTRL_ODTCFG: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  RD_ODT_DELAY
                RD_ODT_DELAY: u5,
                reserved8: u1,
                ///  RD_ODT_HOLD
                RD_ODT_HOLD: u4,
                reserved16: u4,
                ///  WR_ODT_DELAY
                WR_ODT_DELAY: u5,
                reserved24: u3,
                ///  WR_ODT_HOLD
                WR_ODT_HOLD: u4,
                padding: u4,
            }),
            ///  DDRCTRL ODT/Rank map register
            DDRCTRL_ODTMAP: mmio.Mmio(packed struct(u32) {
                ///  RANK0_WR_ODT
                RANK0_WR_ODT: u1,
                reserved4: u3,
                ///  RANK0_RD_ODT
                RANK0_RD_ODT: u1,
                padding: u27,
            }),
            reserved592: [8]u8,
            ///  DDRCTRL scheduler control register
            DDRCTRL_SCHED: mmio.Mmio(packed struct(u32) {
                ///  FORCE_LOW_PRI_N
                FORCE_LOW_PRI_N: u1,
                ///  PREFER_WRITE
                PREFER_WRITE: u1,
                ///  PAGECLOSE
                PAGECLOSE: u1,
                reserved8: u5,
                ///  LPR_NUM_ENTRIES
                LPR_NUM_ENTRIES: u4,
                reserved16: u4,
                ///  GO2CRITICAL_HYSTERESIS
                GO2CRITICAL_HYSTERESIS: u8,
                ///  RDWR_IDLE_GAP
                RDWR_IDLE_GAP: u7,
                padding: u1,
            }),
            ///  DDRCTRL scheduler control register 1
            DDRCTRL_SCHED1: mmio.Mmio(packed struct(u32) {
                ///  PAGECLOSE_TIMER
                PAGECLOSE_TIMER: u8,
                padding: u24,
            }),
            reserved604: [4]u8,
            ///  DDRCTRL high priority read CAM register 1
            DDRCTRL_PERFHPR1: mmio.Mmio(packed struct(u32) {
                ///  HPR_MAX_STARVE
                HPR_MAX_STARVE: u16,
                reserved24: u8,
                ///  HPR_XACT_RUN_LENGTH
                HPR_XACT_RUN_LENGTH: u8,
            }),
            reserved612: [4]u8,
            ///  DDRCTRL low priority read CAM register 1
            DDRCTRL_PERFLPR1: mmio.Mmio(packed struct(u32) {
                ///  LPR_MAX_STARVE
                LPR_MAX_STARVE: u16,
                reserved24: u8,
                ///  LPR_XACT_RUN_LENGTH
                LPR_XACT_RUN_LENGTH: u8,
            }),
            reserved620: [4]u8,
            ///  DDRCTRL write CAM register 1
            DDRCTRL_PERFWR1: mmio.Mmio(packed struct(u32) {
                ///  W_MAX_STARVE
                W_MAX_STARVE: u16,
                reserved24: u8,
                ///  W_XACT_RUN_LENGTH
                W_XACT_RUN_LENGTH: u8,
            }),
            reserved768: [144]u8,
            ///  DDRCTRL debug register 0
            DDRCTRL_DBG0: mmio.Mmio(packed struct(u32) {
                ///  DIS_WC
                DIS_WC: u1,
                reserved4: u3,
                ///  DIS_COLLISION_PAGE_OPT
                DIS_COLLISION_PAGE_OPT: u1,
                padding: u27,
            }),
            ///  DDRCTRL debug register 1
            DDRCTRL_DBG1: mmio.Mmio(packed struct(u32) {
                ///  DIS_DQ
                DIS_DQ: u1,
                ///  DIS_HIF
                DIS_HIF: u1,
                padding: u30,
            }),
            ///  DDRCTRL CAM debug register
            DDRCTRL_DBGCAM: mmio.Mmio(packed struct(u32) {
                ///  DBG_HPR_Q_DEPTH
                DBG_HPR_Q_DEPTH: u5,
                reserved8: u3,
                ///  DBG_LPR_Q_DEPTH
                DBG_LPR_Q_DEPTH: u5,
                reserved16: u3,
                ///  DBG_W_Q_DEPTH
                DBG_W_Q_DEPTH: u5,
                reserved24: u3,
                ///  DBG_STALL
                DBG_STALL: u1,
                ///  DBG_RD_Q_EMPTY
                DBG_RD_Q_EMPTY: u1,
                ///  DBG_WR_Q_EMPTY
                DBG_WR_Q_EMPTY: u1,
                reserved28: u1,
                ///  RD_DATA_PIPELINE_EMPTY
                RD_DATA_PIPELINE_EMPTY: u1,
                ///  WR_DATA_PIPELINE_EMPTY
                WR_DATA_PIPELINE_EMPTY: u1,
                padding: u2,
            }),
            ///  DDRCTRL command debug register
            DDRCTRL_DBGCMD: mmio.Mmio(packed struct(u32) {
                ///  RANK0_REFRESH
                RANK0_REFRESH: u1,
                reserved4: u3,
                ///  ZQ_CALIB_SHORT
                ZQ_CALIB_SHORT: u1,
                ///  CTRLUPD
                CTRLUPD: u1,
                padding: u26,
            }),
            ///  DDRCTRL status debug register
            DDRCTRL_DBGSTAT: mmio.Mmio(packed struct(u32) {
                ///  RANK0_REFRESH_BUSY
                RANK0_REFRESH_BUSY: u1,
                reserved4: u3,
                ///  ZQ_CALIB_SHORT_BUSY
                ZQ_CALIB_SHORT_BUSY: u1,
                ///  CTRLUPD_BUSY
                CTRLUPD_BUSY: u1,
                padding: u26,
            }),
            reserved800: [12]u8,
            ///  DDRCTRL software register programming control enable
            DDRCTRL_SWCTL: mmio.Mmio(packed struct(u32) {
                ///  SW_DONE
                SW_DONE: u1,
                padding: u31,
            }),
            ///  DDRCTRL software register programming control status
            DDRCTRL_SWSTAT: mmio.Mmio(packed struct(u32) {
                ///  SW_DONE_ACK
                SW_DONE_ACK: u1,
                padding: u31,
            }),
            reserved876: [68]u8,
            ///  AXI Poison configuration register common for all AXI ports.
            DDRCTRL_POISONCFG: mmio.Mmio(packed struct(u32) {
                ///  WR_POISON_SLVERR_EN
                WR_POISON_SLVERR_EN: u1,
                reserved4: u3,
                ///  WR_POISON_INTR_EN
                WR_POISON_INTR_EN: u1,
                reserved8: u3,
                ///  WR_POISON_INTR_CLR
                WR_POISON_INTR_CLR: u1,
                reserved16: u7,
                ///  RD_POISON_SLVERR_EN
                RD_POISON_SLVERR_EN: u1,
                reserved20: u3,
                ///  RD_POISON_INTR_EN
                RD_POISON_INTR_EN: u1,
                reserved24: u3,
                ///  RD_POISON_INTR_CLR
                RD_POISON_INTR_CLR: u1,
                padding: u7,
            }),
            ///  DDRCTRL AXI Poison status register
            DDRCTRL_POISONSTAT: mmio.Mmio(packed struct(u32) {
                ///  WR_POISON_INTR_0
                WR_POISON_INTR_0: u1,
                ///  WR_POISON_INTR_1
                WR_POISON_INTR_1: u1,
                reserved16: u14,
                ///  RD_POISON_INTR_0
                RD_POISON_INTR_0: u1,
                ///  RD_POISON_INTR_1
                RD_POISON_INTR_1: u1,
                padding: u14,
            }),
            reserved1020: [136]u8,
            ///  DDRCTRL port status register
            DDRCTRL_PSTAT: mmio.Mmio(packed struct(u32) {
                ///  RD_PORT_BUSY_0
                RD_PORT_BUSY_0: u1,
                ///  RD_PORT_BUSY_1
                RD_PORT_BUSY_1: u1,
                reserved16: u14,
                ///  WR_PORT_BUSY_0
                WR_PORT_BUSY_0: u1,
                ///  WR_PORT_BUSY_1
                WR_PORT_BUSY_1: u1,
                padding: u14,
            }),
            ///  DDRCTRL port common configuration register
            DDRCTRL_PCCFG: mmio.Mmio(packed struct(u32) {
                ///  GO2CRITICAL_EN
                GO2CRITICAL_EN: u1,
                reserved4: u3,
                ///  PAGEMATCH_LIMIT
                PAGEMATCH_LIMIT: u1,
                reserved8: u3,
                ///  BL_EXP_MODE
                BL_EXP_MODE: u1,
                padding: u23,
            }),
            ///  DDRCTRL port 0 configuration read register
            DDRCTRL_PCFGR_0: mmio.Mmio(packed struct(u32) {
                ///  RD_PORT_PRIORITY
                RD_PORT_PRIORITY: u10,
                reserved12: u2,
                ///  RD_PORT_AGING_EN
                RD_PORT_AGING_EN: u1,
                ///  RD_PORT_URGENT_EN
                RD_PORT_URGENT_EN: u1,
                ///  RD_PORT_PAGEMATCH_EN
                RD_PORT_PAGEMATCH_EN: u1,
                reserved16: u1,
                ///  RDWR_ORDERED_EN
                RDWR_ORDERED_EN: u1,
                padding: u15,
            }),
            ///  DDRCTRL port 0 configuration write register
            DDRCTRL_PCFGW_0: mmio.Mmio(packed struct(u32) {
                ///  WR_PORT_PRIORITY
                WR_PORT_PRIORITY: u10,
                reserved12: u2,
                ///  WR_PORT_AGING_EN
                WR_PORT_AGING_EN: u1,
                ///  WR_PORT_URGENT_EN
                WR_PORT_URGENT_EN: u1,
                ///  WR_PORT_PAGEMATCH_EN
                WR_PORT_PAGEMATCH_EN: u1,
                padding: u17,
            }),
            reserved1168: [132]u8,
            ///  DDRCTRL port 0 control register
            DDRCTRL_PCTRL_0: mmio.Mmio(packed struct(u32) {
                ///  PORT_EN
                PORT_EN: u1,
                padding: u31,
            }),
            ///  DDRCTRL port 0 read Q0S configuration register 0
            DDRCTRL_PCFGQOS0_0: mmio.Mmio(packed struct(u32) {
                ///  RQOS_MAP_LEVEL1
                RQOS_MAP_LEVEL1: u4,
                reserved8: u4,
                ///  RQOS_MAP_LEVEL2
                RQOS_MAP_LEVEL2: u4,
                reserved16: u4,
                ///  RQOS_MAP_REGION0
                RQOS_MAP_REGION0: u2,
                reserved20: u2,
                ///  RQOS_MAP_REGION1
                RQOS_MAP_REGION1: u2,
                reserved24: u2,
                ///  RQOS_MAP_REGION2
                RQOS_MAP_REGION2: u2,
                padding: u6,
            }),
            ///  DDRCTRL port 0 read Q0S configuration register 1
            DDRCTRL_PCFGQOS1_0: mmio.Mmio(packed struct(u32) {
                ///  RQOS_MAP_TIMEOUTB
                RQOS_MAP_TIMEOUTB: u11,
                reserved16: u5,
                ///  RQOS_MAP_TIMEOUTR
                RQOS_MAP_TIMEOUTR: u11,
                padding: u5,
            }),
            ///  DDRCTRL port 0 write Q0S configuration register 0
            DDRCTRL_PCFGWQOS0_0: mmio.Mmio(packed struct(u32) {
                ///  WQOS_MAP_LEVEL1
                WQOS_MAP_LEVEL1: u4,
                reserved8: u4,
                ///  WQOS_MAP_LEVEL2
                WQOS_MAP_LEVEL2: u4,
                reserved16: u4,
                ///  WQOS_MAP_REGION0
                WQOS_MAP_REGION0: u2,
                reserved20: u2,
                ///  WQOS_MAP_REGION1
                WQOS_MAP_REGION1: u2,
                reserved24: u2,
                ///  WQOS_MAP_REGION2
                WQOS_MAP_REGION2: u2,
                padding: u6,
            }),
            ///  DDRCTRL port 0 write Q0S configuration register 1
            DDRCTRL_PCFGWQOS1_0: mmio.Mmio(packed struct(u32) {
                ///  WQOS_MAP_TIMEOUT1
                WQOS_MAP_TIMEOUT1: u11,
                reserved16: u5,
                ///  WQOS_MAP_TIMEOUT2
                WQOS_MAP_TIMEOUT2: u11,
                padding: u5,
            }),
            reserved1204: [16]u8,
            ///  DDRCTRL port 1 configuration read register
            DDRCTRL_PCFGR_1: mmio.Mmio(packed struct(u32) {
                ///  RD_PORT_PRIORITY
                RD_PORT_PRIORITY: u10,
                reserved12: u2,
                ///  RD_PORT_AGING_EN
                RD_PORT_AGING_EN: u1,
                ///  RD_PORT_URGENT_EN
                RD_PORT_URGENT_EN: u1,
                ///  RD_PORT_PAGEMATCH_EN
                RD_PORT_PAGEMATCH_EN: u1,
                reserved16: u1,
                ///  RDWR_ORDERED_EN
                RDWR_ORDERED_EN: u1,
                padding: u15,
            }),
            ///  DDRCTRL port 1 configuration write register
            DDRCTRL_PCFGW_1: mmio.Mmio(packed struct(u32) {
                ///  WR_PORT_PRIORITY
                WR_PORT_PRIORITY: u10,
                reserved12: u2,
                ///  WR_PORT_AGING_EN
                WR_PORT_AGING_EN: u1,
                ///  WR_PORT_URGENT_EN
                WR_PORT_URGENT_EN: u1,
                ///  WR_PORT_PAGEMATCH_EN
                WR_PORT_PAGEMATCH_EN: u1,
                padding: u17,
            }),
            reserved1344: [132]u8,
            ///  DDRCTRL port 1 control register
            DDRCTRL_PCTRL_1: mmio.Mmio(packed struct(u32) {
                ///  PORT_EN
                PORT_EN: u1,
                padding: u31,
            }),
            ///  DDRCTRL port 1 read Q0S configuration register 0
            DDRCTRL_PCFGQOS0_1: mmio.Mmio(packed struct(u32) {
                ///  RQOS_MAP_LEVEL1
                RQOS_MAP_LEVEL1: u4,
                reserved8: u4,
                ///  RQOS_MAP_LEVEL2
                RQOS_MAP_LEVEL2: u4,
                reserved16: u4,
                ///  RQOS_MAP_REGION0
                RQOS_MAP_REGION0: u2,
                reserved20: u2,
                ///  RQOS_MAP_REGION1
                RQOS_MAP_REGION1: u2,
                reserved24: u2,
                ///  RQOS_MAP_REGION2
                RQOS_MAP_REGION2: u2,
                padding: u6,
            }),
            ///  DDRCTRL port 1 read Q0S configuration register 1
            DDRCTRL_PCFGQOS1_1: mmio.Mmio(packed struct(u32) {
                ///  RQOS_MAP_TIMEOUTB
                RQOS_MAP_TIMEOUTB: u11,
                reserved16: u5,
                ///  RQOS_MAP_TIMEOUTR
                RQOS_MAP_TIMEOUTR: u11,
                padding: u5,
            }),
            ///  DDRCTRL port 1 write Q0S configuration register 0
            DDRCTRL_PCFGWQOS0_1: mmio.Mmio(packed struct(u32) {
                ///  WQOS_MAP_LEVEL1
                WQOS_MAP_LEVEL1: u4,
                reserved8: u4,
                ///  WQOS_MAP_LEVEL2
                WQOS_MAP_LEVEL2: u4,
                reserved16: u4,
                ///  WQOS_MAP_REGION0
                WQOS_MAP_REGION0: u2,
                reserved20: u2,
                ///  WQOS_MAP_REGION1
                WQOS_MAP_REGION1: u2,
                reserved24: u2,
                ///  WQOS_MAP_REGION2
                WQOS_MAP_REGION2: u2,
                padding: u6,
            }),
            ///  DDRCTRL port 1 write Q0S configuration register 1
            DDRCTRL_PCFGWQOS1_1: mmio.Mmio(packed struct(u32) {
                ///  WQOS_MAP_TIMEOUT1
                WQOS_MAP_TIMEOUT1: u11,
                reserved16: u5,
                ///  WQOS_MAP_TIMEOUT2
                WQOS_MAP_TIMEOUT2: u11,
                padding: u5,
            }),
        };

        ///  DDRPERFM
        pub const DDRPERFM = extern struct {
            ///  Write-only register. A read request returns all zeros.
            DDRPERFM_CTL: mmio.Mmio(packed struct(u32) {
                ///  START
                START: u1,
                ///  STOP
                STOP: u1,
                padding: u30,
            }),
            ///  DDRPERFM configurationl register
            DDRPERFM_CFG: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u4,
                reserved16: u12,
                ///  SEL
                SEL: u2,
                padding: u14,
            }),
            ///  DDRPERFM status register
            DDRPERFM_STATUS: mmio.Mmio(packed struct(u32) {
                ///  COVF
                COVF: u4,
                reserved16: u12,
                ///  BUSY
                BUSY: u1,
                reserved31: u14,
                ///  TOVF
                TOVF: u1,
            }),
            ///  Write-only register. A read request returns all zeros
            DDRPERFM_CCR: mmio.Mmio(packed struct(u32) {
                ///  CCLR
                CCLR: u4,
                reserved31: u27,
                ///  TCLR
                TCLR: u1,
            }),
            ///  DDRPERFM interrupt enable register
            DDRPERFM_IER: mmio.Mmio(packed struct(u32) {
                ///  OVFIE
                OVFIE: u1,
                padding: u31,
            }),
            ///  DDRPERFM interrupt status register
            DDRPERFM_ISR: mmio.Mmio(packed struct(u32) {
                ///  OVFF
                OVFF: u1,
                padding: u31,
            }),
            ///  Write-only register. A read request returns all zeros
            DDRPERFM_ICR: mmio.Mmio(packed struct(u32) {
                ///  OVF
                OVF: u1,
                padding: u31,
            }),
            reserved32: [4]u8,
            ///  DDRPERFM time counter register
            DDRPERFM_TCNT: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u32,
            }),
            reserved96: [60]u8,
            ///  DDRPERFM event counter 0 register
            DDRPERFM_CNT0: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u32,
            }),
            reserved104: [4]u8,
            ///  DDRPERFM event counter 1 register
            DDRPERFM_CNT1: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u32,
            }),
            reserved112: [4]u8,
            ///  DDRPERFM event counter 2 register
            DDRPERFM_CNT2: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u32,
            }),
            reserved120: [4]u8,
            ///  DDRPERFM event counter 3 register
            DDRPERFM_CNT3: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u32,
            }),
            reserved1008: [884]u8,
            ///  DDRPERFM hardware configuration register
            DDRPERFM_HWCFG: mmio.Mmio(packed struct(u32) {
                ///  NCNT
                NCNT: u4,
                padding: u28,
            }),
            ///  DDRPERFM version register
            DDRPERFM_VER: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  DDRPERFM ID register
            DDRPERFM_ID: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  DDRPERFM magic ID register
            DDRPERFM_SID: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  DDRPHYC
        pub const DDRPHYC = extern struct {
            ///  DDRPHYC revision ID register
            DDRPHYC_RIDR: mmio.Mmio(packed struct(u32) {
                ///  PUBMNR
                PUBMNR: u4,
                ///  PUBMDR
                PUBMDR: u4,
                ///  PUBMJR
                PUBMJR: u4,
                ///  PHYMNR
                PHYMNR: u4,
                ///  PHYMDR
                PHYMDR: u4,
                ///  PHYMJR
                PHYMJR: u4,
                ///  UDRID
                UDRID: u8,
            }),
            ///  DDRPHYC PHY initialization register
            DDRPHYC_PIR: mmio.Mmio(packed struct(u32) {
                ///  INIT
                INIT: u1,
                ///  DLLSRST
                DLLSRST: u1,
                ///  DLLLOCK
                DLLLOCK: u1,
                ///  ZCAL
                ZCAL: u1,
                ///  ITMSRST
                ITMSRST: u1,
                ///  DRAMRST
                DRAMRST: u1,
                ///  DRAMINIT
                DRAMINIT: u1,
                ///  QSTRN
                QSTRN: u1,
                ///  RVTRN
                RVTRN: u1,
                reserved16: u7,
                ///  ICPC
                ICPC: u1,
                ///  DLLBYP
                DLLBYP: u1,
                ///  CTLDINIT
                CTLDINIT: u1,
                reserved28: u9,
                ///  CLRSR
                CLRSR: u1,
                ///  LOCKBYP
                LOCKBYP: u1,
                ///  ZCALBYP
                ZCALBYP: u1,
                ///  INITBYP
                INITBYP: u1,
            }),
            ///  DDRPHYC PHY global control register
            DDRPHYC_PGCR: mmio.Mmio(packed struct(u32) {
                ///  ITMDMD
                ITMDMD: u1,
                ///  DQSCFG
                DQSCFG: u1,
                ///  DFTCMP
                DFTCMP: u1,
                ///  DFTLMT
                DFTLMT: u2,
                ///  DTOSEL
                DTOSEL: u4,
                ///  CKEN
                CKEN: u3,
                ///  CKDV
                CKDV: u2,
                ///  CKINV
                CKINV: u1,
                ///  IOLB
                IOLB: u1,
                ///  IODDRM
                IODDRM: u2,
                ///  RANKEN
                RANKEN: u4,
                ///  ZKSEL
                ZKSEL: u2,
                ///  PDDISDX
                PDDISDX: u1,
                ///  RFSHDT
                RFSHDT: u4,
                ///  LBDQSS
                LBDQSS: u1,
                ///  LBGDQS
                LBGDQS: u1,
                ///  LBMODE
                LBMODE: u1,
            }),
            ///  DDRPHYC PHY global status register
            DDRPHYC_PGSR: mmio.Mmio(packed struct(u32) {
                ///  IDONE
                IDONE: u1,
                ///  DLDONE
                DLDONE: u1,
                ///  ZCDDONE
                ZCDDONE: u1,
                ///  DIDONE
                DIDONE: u1,
                ///  DTDONE
                DTDONE: u1,
                ///  DTERR
                DTERR: u1,
                ///  DTIERR
                DTIERR: u1,
                ///  DFTERR
                DFTERR: u1,
                ///  RVERR
                RVERR: u1,
                ///  RVEIRR
                RVEIRR: u1,
                reserved31: u21,
                ///  TQ
                TQ: u1,
            }),
            ///  DDRPHYC DDR global control register
            DDRPHYC_DLLGCR: mmio.Mmio(packed struct(u32) {
                ///  DRES
                DRES: u2,
                ///  IPUMP
                IPUMP: u3,
                ///  TESTEN
                TESTEN: u1,
                ///  DTC
                DTC: u3,
                ///  ATC
                ATC: u2,
                ///  TESTSW
                TESTSW: u1,
                ///  MBIAS
                MBIAS: u8,
                ///  SBIAS2_0
                SBIAS2_0: u3,
                ///  BPS200
                BPS200: u1,
                ///  SBIAS5_3
                SBIAS5_3: u3,
                ///  FDTRMSL
                FDTRMSL: u2,
                ///  LOCKDET
                LOCKDET: u1,
                ///  DLLRSVD2
                DLLRSVD2: u2,
            }),
            ///  DDRPHYC AC DLL control register
            DDRPHYC_ACDLLCR: mmio.Mmio(packed struct(u32) {
                reserved6: u6,
                ///  MFBDLY
                MFBDLY: u3,
                ///  MFWDLY
                MFWDLY: u3,
                reserved18: u6,
                ///  ATESTEN
                ATESTEN: u1,
                reserved30: u11,
                ///  DLLSRST
                DLLSRST: u1,
                ///  DLLDIS
                DLLDIS: u1,
            }),
            ///  DDRPHYC PT register 0
            DDRPHYC_PTR0: mmio.Mmio(packed struct(u32) {
                ///  TDLLSRST
                TDLLSRST: u6,
                ///  TDLLLOCK
                TDLLLOCK: u12,
                ///  TITMSRST
                TITMSRST: u4,
                padding: u10,
            }),
            ///  DDRPHYC PT register 1
            DDRPHYC_PTR1: mmio.Mmio(packed struct(u32) {
                ///  TDINIT0
                TDINIT0: u19,
                ///  TDINIT1
                TDINIT1: u8,
                padding: u5,
            }),
            ///  DDRPHYC PT register 2
            DDRPHYC_PTR2: mmio.Mmio(packed struct(u32) {
                ///  TDINIT2
                TDINIT2: u17,
                ///  TDINIT3
                TDINIT3: u10,
                padding: u5,
            }),
            ///  DDRPHYC ACIOC register
            DDRPHYC_ACIOCR: mmio.Mmio(packed struct(u32) {
                ///  ACIOM
                ACIOM: u1,
                ///  ACOE
                ACOE: u1,
                ///  ACODT
                ACODT: u1,
                ///  ACPDD
                ACPDD: u1,
                ///  ACPDR
                ACPDR: u1,
                ///  CKODT
                CKODT: u3,
                ///  CKPDD
                CKPDD: u3,
                ///  CKPDR
                CKPDR: u3,
                ///  RANKODT
                RANKODT: u1,
                reserved18: u3,
                ///  CSPDD
                CSPDD: u1,
                reserved22: u3,
                ///  RANKPDR
                RANKPDR: u1,
                reserved26: u3,
                ///  RSTODT
                RSTODT: u1,
                ///  RSTPDD
                RSTPDD: u1,
                ///  RSTPDR
                RSTPDR: u1,
                ///  RSTIOM
                RSTIOM: u1,
                ///  ACSR
                ACSR: u2,
            }),
            ///  DDRPHYC DXCC register
            DDRPHYC_DXCCR: mmio.Mmio(packed struct(u32) {
                ///  DXODT
                DXODT: u1,
                ///  DXIOM
                DXIOM: u1,
                ///  DXPDD
                DXPDD: u1,
                ///  DXPDR
                DXPDR: u1,
                ///  DQSRES
                DQSRES: u4,
                ///  DQSNRES
                DQSNRES: u4,
                reserved14: u2,
                ///  DQSNRST
                DQSNRST: u1,
                ///  RVSEL
                RVSEL: u1,
                ///  AWDT
                AWDT: u1,
                padding: u15,
            }),
            ///  DDRPHYC DSGC register
            DDRPHYC_DSGCR: mmio.Mmio(packed struct(u32) {
                ///  PUREN
                PUREN: u1,
                ///  BDISEN
                BDISEN: u1,
                ///  ZUEN
                ZUEN: u1,
                ///  LPIOPD
                LPIOPD: u1,
                ///  LPDLLPD
                LPDLLPD: u1,
                ///  DQSGX
                DQSGX: u3,
                ///  DQSGE
                DQSGE: u3,
                ///  NOBUB
                NOBUB: u1,
                ///  FXDLAT
                FXDLAT: u1,
                reserved16: u3,
                ///  CKEPDD
                CKEPDD: u1,
                reserved20: u3,
                ///  ODTPDD
                ODTPDD: u1,
                reserved24: u3,
                ///  NL2PD
                NL2PD: u1,
                ///  NL2OE
                NL2OE: u1,
                ///  TPDPD
                TPDPD: u1,
                ///  TPDOE
                TPDOE: u1,
                ///  CKOE
                CKOE: u1,
                ///  ODTOE
                ODTOE: u1,
                ///  RSTOE
                RSTOE: u1,
                ///  CKEOE
                CKEOE: u1,
            }),
            ///  DDRPHYC DC register
            DDRPHYC_DCR: mmio.Mmio(packed struct(u32) {
                ///  DDRMD
                DDRMD: u3,
                ///  DDR8BNK
                DDR8BNK: u1,
                ///  PDQ
                PDQ: u3,
                ///  MPRDQ
                MPRDQ: u1,
                ///  DDRTYPE
                DDRTYPE: u2,
                reserved27: u17,
                ///  NOSRA
                NOSRA: u1,
                ///  DDR2T
                DDR2T: u1,
                ///  UDIMM
                UDIMM: u1,
                ///  RDIMM
                RDIMM: u1,
                ///  TPD
                TPD: u1,
            }),
            ///  DDRPHYC DTP register 0
            DDRPHYC_DTPR0: mmio.Mmio(packed struct(u32) {
                ///  TMRD
                TMRD: u2,
                ///  TRTP
                TRTP: u3,
                ///  TWTR
                TWTR: u3,
                ///  TRP
                TRP: u4,
                ///  TRCD
                TRCD: u4,
                ///  TRAS
                TRAS: u5,
                ///  TRRD
                TRRD: u4,
                ///  TRC
                TRC: u6,
                ///  TCCD
                TCCD: u1,
            }),
            ///  DDRPHYC DTP register 1
            DDRPHYC_DTPR1: mmio.Mmio(packed struct(u32) {
                ///  TAOND
                TAOND: u2,
                ///  TRTW
                TRTW: u1,
                ///  TFAW
                TFAW: u6,
                ///  TMOD
                TMOD: u2,
                ///  TRTODT
                TRTODT: u1,
                reserved16: u4,
                ///  TRFC
                TRFC: u8,
                ///  TDQSCKMIN
                TDQSCKMIN: u3,
                ///  TDQSCKMAX
                TDQSCKMAX: u3,
                padding: u2,
            }),
            ///  DDRPHYC DTP register 2
            DDRPHYC_DTPR2: mmio.Mmio(packed struct(u32) {
                ///  TXS
                TXS: u10,
                ///  TXP
                TXP: u5,
                ///  TCKE
                TCKE: u4,
                ///  TDLLK
                TDLLK: u10,
                padding: u3,
            }),
            ///  DDRPHYC MR0 register for DDR3
            DDRPHYC_DDR3_MR0: mmio.Mmio(packed struct(u16) {
                ///  BL
                BL: u2,
                ///  CL0
                CL0: u1,
                ///  BT
                BT: u1,
                ///  CL
                CL: u3,
                ///  TM
                TM: u1,
                ///  DR
                DR: u1,
                ///  WR
                WR: u3,
                ///  PD
                PD: u1,
                ///  RSVD
                RSVD: u3,
            }),
            reserved68: [2]u8,
            ///  DDRPHYC MR1 register for DDR3
            DDRPHYC_DDR3_MR1: mmio.Mmio(packed struct(u16) {
                ///  DE
                DE: u1,
                ///  DIC0
                DIC0: u1,
                ///  RTT0
                RTT0: u1,
                ///  AL
                AL: u2,
                ///  DIC1
                DIC1: u1,
                ///  RTT1
                RTT1: u1,
                ///  LEVEL
                LEVEL: u1,
                reserved9: u1,
                ///  RTT2
                RTT2: u1,
                reserved11: u1,
                ///  TDQS
                TDQS: u1,
                ///  QOFF
                QOFF: u1,
                padding: u3,
            }),
            reserved72: [2]u8,
            ///  DDRPHYC MR2 register for DDR3
            DDRPHYC_DDR3_MR2: mmio.Mmio(packed struct(u16) {
                ///  PASR
                PASR: u3,
                ///  CWL
                CWL: u3,
                ///  ASR
                ASR: u1,
                ///  SRT
                SRT: u1,
                reserved9: u1,
                ///  RTTWR
                RTTWR: u2,
                padding: u5,
            }),
            reserved76: [2]u8,
            ///  DDRPHYC MR3 register for DDR3
            DDRPHYC_DDR3_MR3: mmio.Mmio(packed struct(u8) {
                ///  MPRLOC
                MPRLOC: u2,
                ///  MPR
                MPR: u1,
                padding: u5,
            }),
            reserved80: [3]u8,
            ///  DDRPHYC ODTC register
            DDRPHYC_ODTCR: mmio.Mmio(packed struct(u32) {
                ///  RDODT
                RDODT: u1,
                reserved16: u15,
                ///  WRODT
                WRODT: u1,
                padding: u15,
            }),
            ///  DDRPHYC DTA register
            DDRPHYC_DTAR: mmio.Mmio(packed struct(u32) {
                ///  DTCOL
                DTCOL: u12,
                ///  DTROW
                DTROW: u16,
                ///  DTBANK
                DTBANK: u3,
                ///  DTMPR
                DTMPR: u1,
            }),
            ///  DDRPHYC DTD register 0
            DDRPHYC_DTDR0: mmio.Mmio(packed struct(u32) {
                ///  DTBYTE0
                DTBYTE0: u8,
                ///  DTBYTE1
                DTBYTE1: u8,
                ///  DTBYTE2
                DTBYTE2: u8,
                ///  DTBYTE3
                DTBYTE3: u8,
            }),
            ///  DDRPHYC DTD register 1
            DDRPHYC_DTDR1: mmio.Mmio(packed struct(u32) {
                ///  DTBYTE4
                DTBYTE4: u8,
                ///  DTBYTE5
                DTBYTE5: u8,
                ///  DTBYTE6
                DTBYTE6: u8,
                ///  DTBYTE7
                DTBYTE7: u8,
            }),
            reserved376: [280]u8,
            ///  DDRPHYC general purpose register 0
            DDRPHYC_GPR0: mmio.Mmio(packed struct(u32) {
                ///  GPR0
                GPR0: u32,
            }),
            ///  DDRPHYC general purpose register 1
            DDRPHYC_GPR1: mmio.Mmio(packed struct(u32) {
                ///  GPR1
                GPR1: u32,
            }),
            ///  DDRPHYC ZQ0C register 0
            DDRPHYC_ZQ0CR0: mmio.Mmio(packed struct(u32) {
                ///  ZDATA
                ZDATA: u20,
                reserved28: u8,
                ///  ZDEN
                ZDEN: u1,
                ///  ZCALBYP
                ZCALBYP: u1,
                ///  ZCAL
                ZCAL: u1,
                ///  ZQPD
                ZQPD: u1,
            }),
            ///  DDRPHYC ZQ0CR1 register
            DDRPHYC_ZQ0CR1: mmio.Mmio(packed struct(u8) {
                ///  ZPROG
                ZPROG: u8,
            }),
            reserved392: [3]u8,
            ///  DDRPHYC ZQ0S register 0
            DDRPHYC_ZQ0SR0: mmio.Mmio(packed struct(u32) {
                ///  ZCTRL
                ZCTRL: u20,
                reserved30: u10,
                ///  ZERR
                ZERR: u1,
                ///  ZDONE
                ZDONE: u1,
            }),
            ///  DDRPHYC ZQ0S register 1
            DDRPHYC_ZQ0SR1: mmio.Mmio(packed struct(u8) {
                ///  ZPD
                ZPD: u2,
                ///  ZPU
                ZPU: u2,
                ///  OPD
                OPD: u2,
                ///  OPU
                OPU: u2,
            }),
            reserved448: [51]u8,
            ///  DDRPHYC byte lane 0 GC register
            DDRPHYC_DX0GCR: mmio.Mmio(packed struct(u32) {
                ///  DXEN
                DXEN: u1,
                ///  DQSODT
                DQSODT: u1,
                ///  DQODT
                DQODT: u1,
                ///  DXIOM
                DXIOM: u1,
                ///  DXPDD
                DXPDD: u1,
                ///  DXPDR
                DXPDR: u1,
                ///  DQSRPD
                DQSRPD: u1,
                ///  DSEN
                DSEN: u2,
                ///  DQSRTT
                DQSRTT: u1,
                ///  DQRTT
                DQRTT: u1,
                ///  RTTOH
                RTTOH: u2,
                ///  RTTOAL
                RTTOAL: u1,
                ///  R0RVSL
                R0RVSL: u3,
                padding: u15,
            }),
            ///  DDRPHYC byte lane 0 GS register 0
            DDRPHYC_DX0GSR0: mmio.Mmio(packed struct(u16) {
                ///  DTDONE
                DTDONE: u1,
                reserved4: u3,
                ///  DTERR
                DTERR: u1,
                reserved8: u3,
                ///  DTIERR
                DTIERR: u1,
                reserved13: u4,
                ///  DTPASS
                DTPASS: u3,
            }),
            reserved456: [2]u8,
            ///  DDRPHYC byte lane 0 GS register 1
            DDRPHYC_DX0GSR1: mmio.Mmio(packed struct(u32) {
                ///  DFTERR
                DFTERR: u1,
                reserved4: u3,
                ///  DQSDFT
                DQSDFT: u2,
                reserved12: u6,
                ///  RVERR
                RVERR: u1,
                reserved16: u3,
                ///  RVIERR
                RVIERR: u1,
                reserved20: u3,
                ///  RVPASS
                RVPASS: u3,
                padding: u9,
            }),
            ///  DDRPHYC byte lane 0 DLLC register
            DDRPHYC_DX0DLLCR: mmio.Mmio(packed struct(u32) {
                ///  SFBDLY
                SFBDLY: u3,
                ///  SFWDLY
                SFWDLY: u3,
                ///  MFBDLY
                MFBDLY: u3,
                ///  MFWDLY
                MFWDLY: u3,
                ///  SSTART
                SSTART: u2,
                ///  SDPHASE
                SDPHASE: u4,
                ///  ATESTEN
                ATESTEN: u1,
                ///  SDLBMODE
                SDLBMODE: u1,
                reserved30: u10,
                ///  DLLSRST
                DLLSRST: u1,
                ///  DLLDIS
                DLLDIS: u1,
            }),
            ///  DDRPHYC byte lane 0 DQT register
            DDRPHYC_DX0DQTR: mmio.Mmio(packed struct(u32) {
                ///  DQDLY0
                DQDLY0: u4,
                ///  DQDLY1
                DQDLY1: u4,
                ///  DQDLY2
                DQDLY2: u4,
                ///  DQDLY3
                DQDLY3: u4,
                ///  DQDLY4
                DQDLY4: u4,
                ///  DQDLY5
                DQDLY5: u4,
                ///  DQDLY6
                DQDLY6: u4,
                ///  DQDLY7
                DQDLY7: u4,
            }),
            ///  DDRPHYC byte lane 0 DQST register
            DDRPHYC_DX0DQSTR: mmio.Mmio(packed struct(u32) {
                ///  R0DGSL
                R0DGSL: u3,
                reserved12: u9,
                ///  R0DGPS
                R0DGPS: u2,
                reserved20: u6,
                ///  DQSDLY
                DQSDLY: u3,
                ///  DQSNDLY
                DQSNDLY: u3,
                ///  DMDLY
                DMDLY: u4,
                padding: u2,
            }),
            reserved512: [40]u8,
            ///  DDRPHYC byte lane 1 GC register
            DDRPHYC_DX1GCR: mmio.Mmio(packed struct(u32) {
                ///  DXEN
                DXEN: u1,
                ///  DQSODT
                DQSODT: u1,
                ///  DQODT
                DQODT: u1,
                ///  DXIOM
                DXIOM: u1,
                ///  DXPDD
                DXPDD: u1,
                ///  DXPDR
                DXPDR: u1,
                ///  DQSRPD
                DQSRPD: u1,
                ///  DSEN
                DSEN: u2,
                ///  DQSRTT
                DQSRTT: u1,
                ///  DQRTT
                DQRTT: u1,
                ///  RTTOH
                RTTOH: u2,
                ///  RTTOAL
                RTTOAL: u1,
                ///  R0RVSL
                R0RVSL: u3,
                padding: u15,
            }),
            ///  DDRPHYC byte lane 1 GS register 0
            DDRPHYC_DX1GSR0: mmio.Mmio(packed struct(u16) {
                ///  DTDONE
                DTDONE: u1,
                reserved4: u3,
                ///  DTERR
                DTERR: u1,
                reserved8: u3,
                ///  DTIERR
                DTIERR: u1,
                reserved13: u4,
                ///  DTPASS
                DTPASS: u3,
            }),
            reserved520: [2]u8,
            ///  DDRPHYC byte lane 1 GS register 1
            DDRPHYC_DX1GSR1: mmio.Mmio(packed struct(u32) {
                ///  DFTERR
                DFTERR: u1,
                reserved4: u3,
                ///  DQSDFT
                DQSDFT: u2,
                reserved12: u6,
                ///  RVERR
                RVERR: u1,
                reserved16: u3,
                ///  RVIERR
                RVIERR: u1,
                reserved20: u3,
                ///  RVPASS
                RVPASS: u3,
                padding: u9,
            }),
            ///  DDRPHYC byte lane 1 DLLC register
            DDRPHYC_DX1DLLCR: mmio.Mmio(packed struct(u32) {
                ///  SFBDLY
                SFBDLY: u3,
                ///  SFWDLY
                SFWDLY: u3,
                ///  MFBDLY
                MFBDLY: u3,
                ///  MFWDLY
                MFWDLY: u3,
                ///  SSTART
                SSTART: u2,
                ///  SDPHASE
                SDPHASE: u4,
                ///  ATESTEN
                ATESTEN: u1,
                ///  SDLBMODE
                SDLBMODE: u1,
                reserved30: u10,
                ///  DLLSRST
                DLLSRST: u1,
                ///  DLLDIS
                DLLDIS: u1,
            }),
            ///  DDRPHYC byte lane 1 DQT register
            DDRPHYC_DX1DQTR: mmio.Mmio(packed struct(u32) {
                ///  DQDLY0
                DQDLY0: u4,
                ///  DQDLY1
                DQDLY1: u4,
                ///  DQDLY2
                DQDLY2: u4,
                ///  DQDLY3
                DQDLY3: u4,
                ///  DQDLY4
                DQDLY4: u4,
                ///  DQDLY5
                DQDLY5: u4,
                ///  DQDLY6
                DQDLY6: u4,
                ///  DQDLY7
                DQDLY7: u4,
            }),
            ///  DDRPHYC byte lane 1 DQST register
            DDRPHYC_DX1DQSTR: mmio.Mmio(packed struct(u32) {
                ///  R0DGSL
                R0DGSL: u3,
                reserved12: u9,
                ///  R0DGPS
                R0DGPS: u2,
                reserved20: u6,
                ///  DQSDLY
                DQSDLY: u3,
                ///  DQSNDLY
                DQSNDLY: u3,
                ///  DMDLY
                DMDLY: u4,
                padding: u2,
            }),
            reserved576: [40]u8,
            ///  DDRPHYC byte lane 2 GC register
            DDRPHYC_DX2GCR: mmio.Mmio(packed struct(u32) {
                ///  DXEN
                DXEN: u1,
                ///  DQSODT
                DQSODT: u1,
                ///  DQODT
                DQODT: u1,
                ///  DXIOM
                DXIOM: u1,
                ///  DXPDD
                DXPDD: u1,
                ///  DXPDR
                DXPDR: u1,
                ///  DQSRPD
                DQSRPD: u1,
                ///  DSEN
                DSEN: u2,
                ///  DQSRTT
                DQSRTT: u1,
                ///  DQRTT
                DQRTT: u1,
                ///  RTTOH
                RTTOH: u2,
                ///  RTTOAL
                RTTOAL: u1,
                ///  R0RVSL
                R0RVSL: u3,
                padding: u15,
            }),
            ///  DDRPHYC byte lane 2 GS register 0
            DDRPHYC_DX2GSR0: mmio.Mmio(packed struct(u16) {
                ///  DTDONE
                DTDONE: u1,
                reserved4: u3,
                ///  DTERR
                DTERR: u1,
                reserved8: u3,
                ///  DTIERR
                DTIERR: u1,
                reserved13: u4,
                ///  DTPASS
                DTPASS: u3,
            }),
            reserved584: [2]u8,
            ///  DDRPHYC byte lane 2 GS register 1
            DDRPHYC_DX2GSR1: mmio.Mmio(packed struct(u32) {
                ///  DFTERR
                DFTERR: u1,
                reserved4: u3,
                ///  DQSDFT
                DQSDFT: u2,
                reserved12: u6,
                ///  RVERR
                RVERR: u1,
                reserved16: u3,
                ///  RVIERR
                RVIERR: u1,
                reserved20: u3,
                ///  RVPASS
                RVPASS: u3,
                padding: u9,
            }),
            ///  DDRPHYC byte lane 2 DLLC register
            DDRPHYC_DX2DLLCR: mmio.Mmio(packed struct(u32) {
                ///  SFBDLY
                SFBDLY: u3,
                ///  SFWDLY
                SFWDLY: u3,
                ///  MFBDLY
                MFBDLY: u3,
                ///  MFWDLY
                MFWDLY: u3,
                ///  SSTART
                SSTART: u2,
                ///  SDPHASE
                SDPHASE: u4,
                ///  ATESTEN
                ATESTEN: u1,
                ///  SDLBMODE
                SDLBMODE: u1,
                reserved30: u10,
                ///  DLLSRST
                DLLSRST: u1,
                ///  DLLDIS
                DLLDIS: u1,
            }),
            ///  DDRPHYC byte lane 2 DQT register
            DDRPHYC_DX2DQTR: mmio.Mmio(packed struct(u32) {
                ///  DQDLY0
                DQDLY0: u4,
                ///  DQDLY1
                DQDLY1: u4,
                ///  DQDLY2
                DQDLY2: u4,
                ///  DQDLY3
                DQDLY3: u4,
                ///  DQDLY4
                DQDLY4: u4,
                ///  DQDLY5
                DQDLY5: u4,
                ///  DQDLY6
                DQDLY6: u4,
                ///  DQDLY7
                DQDLY7: u4,
            }),
            ///  DDRPHYC byte lane 2 DQST register
            DDRPHYC_DX2DQSTR: mmio.Mmio(packed struct(u32) {
                ///  R0DGSL
                R0DGSL: u3,
                reserved12: u9,
                ///  R0DGPS
                R0DGPS: u2,
                reserved20: u6,
                ///  DQSDLY
                DQSDLY: u3,
                ///  DQSNDLY
                DQSNDLY: u3,
                ///  DMDLY
                DMDLY: u4,
                padding: u2,
            }),
            reserved640: [40]u8,
            ///  DDRPHYC byte lane 3 GC register
            DDRPHYC_DX3GCR: mmio.Mmio(packed struct(u32) {
                ///  DXEN
                DXEN: u1,
                ///  DQSODT
                DQSODT: u1,
                ///  DQODT
                DQODT: u1,
                ///  DXIOM
                DXIOM: u1,
                ///  DXPDD
                DXPDD: u1,
                ///  DXPDR
                DXPDR: u1,
                ///  DQSRPD
                DQSRPD: u1,
                ///  DSEN
                DSEN: u2,
                ///  DQSRTT
                DQSRTT: u1,
                ///  DQRTT
                DQRTT: u1,
                ///  RTTOH
                RTTOH: u2,
                ///  RTTOAL
                RTTOAL: u1,
                ///  R0RVSL
                R0RVSL: u3,
                padding: u15,
            }),
            ///  DDRPHYC byte lane 3 GS register 0
            DDRPHYC_DX3GSR0: mmio.Mmio(packed struct(u16) {
                ///  DTDONE
                DTDONE: u1,
                reserved4: u3,
                ///  DTERR
                DTERR: u1,
                reserved8: u3,
                ///  DTIERR
                DTIERR: u1,
                reserved13: u4,
                ///  DTPASS
                DTPASS: u3,
            }),
            reserved648: [2]u8,
            ///  DDRPHYC byte lane 3 GS register 1
            DDRPHYC_DX3GSR1: mmio.Mmio(packed struct(u32) {
                ///  DFTERR
                DFTERR: u1,
                reserved4: u3,
                ///  DQSDFT
                DQSDFT: u2,
                reserved12: u6,
                ///  RVERR
                RVERR: u1,
                reserved16: u3,
                ///  RVIERR
                RVIERR: u1,
                reserved20: u3,
                ///  RVPASS
                RVPASS: u3,
                padding: u9,
            }),
            ///  DDRPHYC byte lane 3 DLLC register
            DDRPHYC_DX3DLLCR: mmio.Mmio(packed struct(u32) {
                ///  SFBDLY
                SFBDLY: u3,
                ///  SFWDLY
                SFWDLY: u3,
                ///  MFBDLY
                MFBDLY: u3,
                ///  MFWDLY
                MFWDLY: u3,
                ///  SSTART
                SSTART: u2,
                ///  SDPHASE
                SDPHASE: u4,
                ///  ATESTEN
                ATESTEN: u1,
                ///  SDLBMODE
                SDLBMODE: u1,
                reserved30: u10,
                ///  DLLSRST
                DLLSRST: u1,
                ///  DLLDIS
                DLLDIS: u1,
            }),
            ///  DDRPHYC byte lane 3 DQT register
            DDRPHYC_DX3DQTR: mmio.Mmio(packed struct(u32) {
                ///  DQDLY0
                DQDLY0: u4,
                ///  DQDLY1
                DQDLY1: u4,
                ///  DQDLY2
                DQDLY2: u4,
                ///  DQDLY3
                DQDLY3: u4,
                ///  DQDLY4
                DQDLY4: u4,
                ///  DQDLY5
                DQDLY5: u4,
                ///  DQDLY6
                DQDLY6: u4,
                ///  DQDLY7
                DQDLY7: u4,
            }),
            ///  DDRPHYC byte lane 3 DQST register
            DDRPHYC_DX3DQSTR: mmio.Mmio(packed struct(u32) {
                ///  R0DGSL
                R0DGSL: u3,
                reserved12: u9,
                ///  R0DGPS
                R0DGPS: u2,
                reserved20: u6,
                ///  DQSDLY
                DQSDLY: u3,
                ///  DQSNDLY
                DQSNDLY: u3,
                ///  DMDLY
                DMDLY: u4,
                padding: u2,
            }),
        };

        ///  DFSDM1
        pub const DFSDM1 = extern struct {
            ///  This register specifies the parameters used by channel y.
            DFSDM_CH0CFGR1: mmio.Mmio(packed struct(u32) {
                ///  SITP
                SITP: u2,
                ///  SPICKSEL
                SPICKSEL: u2,
                reserved5: u1,
                ///  SCDEN
                SCDEN: u1,
                ///  CKABEN
                CKABEN: u1,
                ///  CHEN
                CHEN: u1,
                ///  CHINSEL
                CHINSEL: u1,
                reserved12: u3,
                ///  DATMPX
                DATMPX: u2,
                ///  DATPACK
                DATPACK: u2,
                ///  CKOUTDIV
                CKOUTDIV: u8,
                reserved30: u6,
                ///  CKOUTSRC
                CKOUTSRC: u1,
                ///  DFSDMEN
                DFSDMEN: u1,
            }),
            ///  This register specifies the parameters used by channel y.
            DFSDM_CH0CFGR2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  DTRBS
                DTRBS: u5,
                ///  OFFSET
                OFFSET: u24,
            }),
            ///  Short-circuit detector and analog watchdog settings for channel y.
            DFSDM_CH0AWSCDR: mmio.Mmio(packed struct(u32) {
                ///  SCDT
                SCDT: u8,
                reserved12: u4,
                ///  BKSCD
                BKSCD: u4,
                ///  AWFOSR
                AWFOSR: u5,
                reserved22: u1,
                ///  AWFORD
                AWFORD: u2,
                padding: u8,
            }),
            ///  This register contains the data resulting from the analog watchdog filter associated to the input channel y.
            DFSDM_CH0WDATR: mmio.Mmio(packed struct(u32) {
                ///  WDATA
                WDATA: u16,
                padding: u16,
            }),
            ///  This register contains 16-bit input data to be processed by DFSDM filter module.
            DFSDM_CH0DATINR: mmio.Mmio(packed struct(u32) {
                ///  INDAT0
                INDAT0: u16,
                ///  INDAT1
                INDAT1: u16,
            }),
            ///  DFSDM channel 0 delay register
            DFSDM_CH0DLYR: mmio.Mmio(packed struct(u32) {
                ///  PLSSKP
                PLSSKP: u6,
                padding: u26,
            }),
            reserved32: [8]u8,
            ///  This register specifies the parameters used by channel y.
            DFSDM_CH1CFGR1: mmio.Mmio(packed struct(u32) {
                ///  SITP
                SITP: u2,
                ///  SPICKSEL
                SPICKSEL: u2,
                reserved5: u1,
                ///  SCDEN
                SCDEN: u1,
                ///  CKABEN
                CKABEN: u1,
                ///  CHEN
                CHEN: u1,
                ///  CHINSEL
                CHINSEL: u1,
                reserved12: u3,
                ///  DATMPX
                DATMPX: u2,
                ///  DATPACK
                DATPACK: u2,
                ///  CKOUTDIV
                CKOUTDIV: u8,
                reserved30: u6,
                ///  CKOUTSRC
                CKOUTSRC: u1,
                ///  DFSDMEN
                DFSDMEN: u1,
            }),
            ///  This register specifies the parameters used by channel y.
            DFSDM_CH1CFGR2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  DTRBS
                DTRBS: u5,
                ///  OFFSET
                OFFSET: u24,
            }),
            ///  Short-circuit detector and analog watchdog settings for channel y.
            DFSDM_CH1AWSCDR: mmio.Mmio(packed struct(u32) {
                ///  SCDT
                SCDT: u8,
                reserved12: u4,
                ///  BKSCD
                BKSCD: u4,
                ///  AWFOSR
                AWFOSR: u5,
                reserved22: u1,
                ///  AWFORD
                AWFORD: u2,
                padding: u8,
            }),
            ///  This register contains the data resulting from the analog watchdog filter associated to the input channel y.
            DFSDM_CH1WDATR: mmio.Mmio(packed struct(u32) {
                ///  WDATA
                WDATA: u16,
                padding: u16,
            }),
            ///  This register contains 16-bit input data to be processed by DFSDM filter module.
            DFSDM_CH1DATINR: mmio.Mmio(packed struct(u32) {
                ///  INDAT0
                INDAT0: u16,
                ///  INDAT1
                INDAT1: u16,
            }),
            ///  DFSDM channel 1 delay register
            DFSDM_CH1DLYR: mmio.Mmio(packed struct(u32) {
                ///  PLSSKP
                PLSSKP: u6,
                padding: u26,
            }),
            reserved64: [8]u8,
            ///  This register specifies the parameters used by channel y.
            DFSDM_CH2CFGR1: mmio.Mmio(packed struct(u32) {
                ///  SITP
                SITP: u2,
                ///  SPICKSEL
                SPICKSEL: u2,
                reserved5: u1,
                ///  SCDEN
                SCDEN: u1,
                ///  CKABEN
                CKABEN: u1,
                ///  CHEN
                CHEN: u1,
                ///  CHINSEL
                CHINSEL: u1,
                reserved12: u3,
                ///  DATMPX
                DATMPX: u2,
                ///  DATPACK
                DATPACK: u2,
                ///  CKOUTDIV
                CKOUTDIV: u8,
                reserved30: u6,
                ///  CKOUTSRC
                CKOUTSRC: u1,
                ///  DFSDMEN
                DFSDMEN: u1,
            }),
            ///  This register specifies the parameters used by channel y.
            DFSDM_CH2CFGR2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  DTRBS
                DTRBS: u5,
                ///  OFFSET
                OFFSET: u24,
            }),
            ///  Short-circuit detector and analog watchdog settings for channel y.
            DFSDM_CH2AWSCDR: mmio.Mmio(packed struct(u32) {
                ///  SCDT
                SCDT: u8,
                reserved12: u4,
                ///  BKSCD
                BKSCD: u4,
                ///  AWFOSR
                AWFOSR: u5,
                reserved22: u1,
                ///  AWFORD
                AWFORD: u2,
                padding: u8,
            }),
            ///  This register contains the data resulting from the analog watchdog filter associated to the input channel y.
            DFSDM_CH2WDATR: mmio.Mmio(packed struct(u32) {
                ///  WDATA
                WDATA: u16,
                padding: u16,
            }),
            ///  This register contains 16-bit input data to be processed by DFSDM filter module.
            DFSDM_CH2DATINR: mmio.Mmio(packed struct(u32) {
                ///  INDAT0
                INDAT0: u16,
                ///  INDAT1
                INDAT1: u16,
            }),
            ///  DFSDM channel 2 delay register
            DFSDM_CH2DLYR: mmio.Mmio(packed struct(u32) {
                ///  PLSSKP
                PLSSKP: u6,
                padding: u26,
            }),
            reserved96: [8]u8,
            ///  This register specifies the parameters used by channel y.
            DFSDM_CH3CFGR1: mmio.Mmio(packed struct(u32) {
                ///  SITP
                SITP: u2,
                ///  SPICKSEL
                SPICKSEL: u2,
                reserved5: u1,
                ///  SCDEN
                SCDEN: u1,
                ///  CKABEN
                CKABEN: u1,
                ///  CHEN
                CHEN: u1,
                ///  CHINSEL
                CHINSEL: u1,
                reserved12: u3,
                ///  DATMPX
                DATMPX: u2,
                ///  DATPACK
                DATPACK: u2,
                ///  CKOUTDIV
                CKOUTDIV: u8,
                reserved30: u6,
                ///  CKOUTSRC
                CKOUTSRC: u1,
                ///  DFSDMEN
                DFSDMEN: u1,
            }),
            ///  This register specifies the parameters used by channel y.
            DFSDM_CH3CFGR2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  DTRBS
                DTRBS: u5,
                ///  OFFSET
                OFFSET: u24,
            }),
            ///  Short-circuit detector and analog watchdog settings for channel y.
            DFSDM_CH3AWSCDR: mmio.Mmio(packed struct(u32) {
                ///  SCDT
                SCDT: u8,
                reserved12: u4,
                ///  BKSCD
                BKSCD: u4,
                ///  AWFOSR
                AWFOSR: u5,
                reserved22: u1,
                ///  AWFORD
                AWFORD: u2,
                padding: u8,
            }),
            ///  This register contains the data resulting from the analog watchdog filter associated to the input channel y.
            DFSDM_CH3WDATR: mmio.Mmio(packed struct(u32) {
                ///  WDATA
                WDATA: u16,
                padding: u16,
            }),
            ///  This register contains 16-bit input data to be processed by DFSDM filter module.
            DFSDM_CH3DATINR: mmio.Mmio(packed struct(u32) {
                ///  INDAT0
                INDAT0: u16,
                ///  INDAT1
                INDAT1: u16,
            }),
            ///  DFSDM channel 3 delay register
            DFSDM_CH3DLYR: mmio.Mmio(packed struct(u32) {
                ///  PLSSKP
                PLSSKP: u6,
                padding: u26,
            }),
            reserved128: [8]u8,
            ///  This register specifies the parameters used by channel y.
            DFSDM_CH4CFGR1: mmio.Mmio(packed struct(u32) {
                ///  SITP
                SITP: u2,
                ///  SPICKSEL
                SPICKSEL: u2,
                reserved5: u1,
                ///  SCDEN
                SCDEN: u1,
                ///  CKABEN
                CKABEN: u1,
                ///  CHEN
                CHEN: u1,
                ///  CHINSEL
                CHINSEL: u1,
                reserved12: u3,
                ///  DATMPX
                DATMPX: u2,
                ///  DATPACK
                DATPACK: u2,
                ///  CKOUTDIV
                CKOUTDIV: u8,
                reserved30: u6,
                ///  CKOUTSRC
                CKOUTSRC: u1,
                ///  DFSDMEN
                DFSDMEN: u1,
            }),
            ///  This register specifies the parameters used by channel y.
            DFSDM_CH4CFGR2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  DTRBS
                DTRBS: u5,
                ///  OFFSET
                OFFSET: u24,
            }),
            ///  Short-circuit detector and analog watchdog settings for channel y.
            DFSDM_CH4AWSCDR: mmio.Mmio(packed struct(u32) {
                ///  SCDT
                SCDT: u8,
                reserved12: u4,
                ///  BKSCD
                BKSCD: u4,
                ///  AWFOSR
                AWFOSR: u5,
                reserved22: u1,
                ///  AWFORD
                AWFORD: u2,
                padding: u8,
            }),
            ///  This register contains the data resulting from the analog watchdog filter associated to the input channel y.
            DFSDM_CH4WDATR: mmio.Mmio(packed struct(u32) {
                ///  WDATA
                WDATA: u16,
                padding: u16,
            }),
            ///  This register contains 16-bit input data to be processed by DFSDM filter module.
            DFSDM_CH4DATINR: mmio.Mmio(packed struct(u32) {
                ///  INDAT0
                INDAT0: u16,
                ///  INDAT1
                INDAT1: u16,
            }),
            ///  DFSDM channel 4 delay register
            DFSDM_CH4DLYR: mmio.Mmio(packed struct(u32) {
                ///  PLSSKP
                PLSSKP: u6,
                padding: u26,
            }),
            reserved160: [8]u8,
            ///  This register specifies the parameters used by channel y.
            DFSDM_CH5CFGR1: mmio.Mmio(packed struct(u32) {
                ///  SITP
                SITP: u2,
                ///  SPICKSEL
                SPICKSEL: u2,
                reserved5: u1,
                ///  SCDEN
                SCDEN: u1,
                ///  CKABEN
                CKABEN: u1,
                ///  CHEN
                CHEN: u1,
                ///  CHINSEL
                CHINSEL: u1,
                reserved12: u3,
                ///  DATMPX
                DATMPX: u2,
                ///  DATPACK
                DATPACK: u2,
                ///  CKOUTDIV
                CKOUTDIV: u8,
                reserved30: u6,
                ///  CKOUTSRC
                CKOUTSRC: u1,
                ///  DFSDMEN
                DFSDMEN: u1,
            }),
            ///  This register specifies the parameters used by channel y.
            DFSDM_CH5CFGR2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  DTRBS
                DTRBS: u5,
                ///  OFFSET
                OFFSET: u24,
            }),
            ///  Short-circuit detector and analog watchdog settings for channel y.
            DFSDM_CH5AWSCDR: mmio.Mmio(packed struct(u32) {
                ///  SCDT
                SCDT: u8,
                reserved12: u4,
                ///  BKSCD
                BKSCD: u4,
                ///  AWFOSR
                AWFOSR: u5,
                reserved22: u1,
                ///  AWFORD
                AWFORD: u2,
                padding: u8,
            }),
            ///  This register contains the data resulting from the analog watchdog filter associated to the input channel y.
            DFSDM_CH5WDATR: mmio.Mmio(packed struct(u32) {
                ///  WDATA
                WDATA: u16,
                padding: u16,
            }),
            ///  This register contains 16-bit input data to be processed by DFSDM filter module.
            DFSDM_CH5DATINR: mmio.Mmio(packed struct(u32) {
                ///  INDAT0
                INDAT0: u16,
                ///  INDAT1
                INDAT1: u16,
            }),
            ///  DFSDM channel 5 delay register
            DFSDM_CH5DLYR: mmio.Mmio(packed struct(u32) {
                ///  PLSSKP
                PLSSKP: u6,
                padding: u26,
            }),
            reserved192: [8]u8,
            ///  This register specifies the parameters used by channel y.
            DFSDM_CH6CFGR1: mmio.Mmio(packed struct(u32) {
                ///  SITP
                SITP: u2,
                ///  SPICKSEL
                SPICKSEL: u2,
                reserved5: u1,
                ///  SCDEN
                SCDEN: u1,
                ///  CKABEN
                CKABEN: u1,
                ///  CHEN
                CHEN: u1,
                ///  CHINSEL
                CHINSEL: u1,
                reserved12: u3,
                ///  DATMPX
                DATMPX: u2,
                ///  DATPACK
                DATPACK: u2,
                ///  CKOUTDIV
                CKOUTDIV: u8,
                reserved30: u6,
                ///  CKOUTSRC
                CKOUTSRC: u1,
                ///  DFSDMEN
                DFSDMEN: u1,
            }),
            ///  This register specifies the parameters used by channel y.
            DFSDM_CH6CFGR2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  DTRBS
                DTRBS: u5,
                ///  OFFSET
                OFFSET: u24,
            }),
            ///  Short-circuit detector and analog watchdog settings for channel y.
            DFSDM_CH6AWSCDR: mmio.Mmio(packed struct(u32) {
                ///  SCDT
                SCDT: u8,
                reserved12: u4,
                ///  BKSCD
                BKSCD: u4,
                ///  AWFOSR
                AWFOSR: u5,
                reserved22: u1,
                ///  AWFORD
                AWFORD: u2,
                padding: u8,
            }),
            ///  This register contains the data resulting from the analog watchdog filter associated to the input channel y.
            DFSDM_CH6WDATR: mmio.Mmio(packed struct(u32) {
                ///  WDATA
                WDATA: u16,
                padding: u16,
            }),
            ///  This register contains 16-bit input data to be processed by DFSDM filter module.
            DFSDM_CH6DATINR: mmio.Mmio(packed struct(u32) {
                ///  INDAT0
                INDAT0: u16,
                ///  INDAT1
                INDAT1: u16,
            }),
            ///  DFSDM channel 6 delay register
            DFSDM_CH6DLYR: mmio.Mmio(packed struct(u32) {
                ///  PLSSKP
                PLSSKP: u6,
                padding: u26,
            }),
            reserved224: [8]u8,
            ///  This register specifies the parameters used by channel y.
            DFSDM_CH7CFGR1: mmio.Mmio(packed struct(u32) {
                ///  SITP
                SITP: u2,
                ///  SPICKSEL
                SPICKSEL: u2,
                reserved5: u1,
                ///  SCDEN
                SCDEN: u1,
                ///  CKABEN
                CKABEN: u1,
                ///  CHEN
                CHEN: u1,
                ///  CHINSEL
                CHINSEL: u1,
                reserved12: u3,
                ///  DATMPX
                DATMPX: u2,
                ///  DATPACK
                DATPACK: u2,
                ///  CKOUTDIV
                CKOUTDIV: u8,
                reserved30: u6,
                ///  CKOUTSRC
                CKOUTSRC: u1,
                ///  DFSDMEN
                DFSDMEN: u1,
            }),
            ///  This register specifies the parameters used by channel y.
            DFSDM_CH7CFGR2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  DTRBS
                DTRBS: u5,
                ///  OFFSET
                OFFSET: u24,
            }),
            ///  Short-circuit detector and analog watchdog settings for channel y.
            DFSDM_CH7AWSCDR: mmio.Mmio(packed struct(u32) {
                ///  SCDT
                SCDT: u8,
                reserved12: u4,
                ///  BKSCD
                BKSCD: u4,
                ///  AWFOSR
                AWFOSR: u5,
                reserved22: u1,
                ///  AWFORD
                AWFORD: u2,
                padding: u8,
            }),
            ///  This register contains the data resulting from the analog watchdog filter associated to the input channel y.
            DFSDM_CH7WDATR: mmio.Mmio(packed struct(u32) {
                ///  WDATA
                WDATA: u16,
                padding: u16,
            }),
            ///  This register contains 16-bit input data to be processed by DFSDM filter module.
            DFSDM_CH7DATINR: mmio.Mmio(packed struct(u32) {
                ///  INDAT0
                INDAT0: u16,
                ///  INDAT1
                INDAT1: u16,
            }),
            ///  DFSDM channel 7 delay register
            DFSDM_CH7DLYR: mmio.Mmio(packed struct(u32) {
                ///  PLSSKP
                PLSSKP: u6,
                padding: u26,
            }),
            reserved256: [8]u8,
            ///  DFSDM filter 0 control register 1
            DFSDM_FLT0CR1: mmio.Mmio(packed struct(u32) {
                ///  DFEN
                DFEN: u1,
                ///  JSWSTART
                JSWSTART: u1,
                reserved3: u1,
                ///  JSYNC
                JSYNC: u1,
                ///  JSCAN
                JSCAN: u1,
                ///  JDMAEN
                JDMAEN: u1,
                reserved8: u2,
                ///  JEXTSEL
                JEXTSEL: u5,
                ///  JEXTEN
                JEXTEN: u2,
                reserved17: u2,
                ///  RSWSTART
                RSWSTART: u1,
                ///  RCONT
                RCONT: u1,
                ///  RSYNC
                RSYNC: u1,
                reserved21: u1,
                ///  RDMAEN
                RDMAEN: u1,
                reserved24: u2,
                ///  RCH
                RCH: u3,
                reserved29: u2,
                ///  FAST
                FAST: u1,
                ///  AWFSEL
                AWFSEL: u1,
                padding: u1,
            }),
            ///  DFSDM filter 0 control register 2
            DFSDM_FLT0CR2: mmio.Mmio(packed struct(u32) {
                ///  JEOCIE
                JEOCIE: u1,
                ///  REOCIE
                REOCIE: u1,
                ///  JOVRIE
                JOVRIE: u1,
                ///  ROVRIE
                ROVRIE: u1,
                ///  AWDIE
                AWDIE: u1,
                ///  SCDIE
                SCDIE: u1,
                ///  CKABIE
                CKABIE: u1,
                reserved8: u1,
                ///  EXCH
                EXCH: u8,
                ///  AWDCH
                AWDCH: u8,
                padding: u8,
            }),
            ///  DFSDM filter 0 interrupt and status register
            DFSDM_FLT0ISR: mmio.Mmio(packed struct(u32) {
                ///  JEOCF
                JEOCF: u1,
                ///  REOCF
                REOCF: u1,
                ///  JOVRF
                JOVRF: u1,
                ///  ROVRF
                ROVRF: u1,
                ///  AWDF
                AWDF: u1,
                reserved13: u8,
                ///  JCIP
                JCIP: u1,
                ///  RCIP
                RCIP: u1,
                reserved16: u1,
                ///  CKABF
                CKABF: u8,
                ///  SCDF
                SCDF: u8,
            }),
            ///  DFSDM filter 0 interrupt flag clear register
            DFSDM_FLT0ICR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  CLRJOVRF
                CLRJOVRF: u1,
                ///  CLRROVRF
                CLRROVRF: u1,
                reserved16: u12,
                ///  CLRCKABF
                CLRCKABF: u8,
                ///  CLRSCDF
                CLRSCDF: u8,
            }),
            ///  DFSDM filter 0 injected channel group selection register
            DFSDM_FLT0JCHGR: mmio.Mmio(packed struct(u32) {
                ///  JCHG
                JCHG: u8,
                padding: u24,
            }),
            ///  DFSDM filter 0 control register
            DFSDM_FLT0FCR: mmio.Mmio(packed struct(u32) {
                ///  IOSR
                IOSR: u8,
                reserved16: u8,
                ///  FOSR
                FOSR: u10,
                reserved29: u3,
                ///  FORD
                FORD: u3,
            }),
            ///  DFSDM filter 0 data register for injected group
            DFSDM_FLT0JDATAR: mmio.Mmio(packed struct(u32) {
                ///  JDATACH
                JDATACH: u3,
                reserved8: u5,
                ///  JDATA
                JDATA: u24,
            }),
            ///  DFSDM filter 0 data register for the regular channel
            DFSDM_FLT0RDATAR: mmio.Mmio(packed struct(u32) {
                ///  RDATACH
                RDATACH: u3,
                reserved4: u1,
                ///  RPEND
                RPEND: u1,
                reserved8: u3,
                ///  RDATA
                RDATA: u24,
            }),
            ///  DFSDM filter 0 analog watchdog high threshold register
            DFSDM_FLT0AWHTR: mmio.Mmio(packed struct(u32) {
                ///  BKAWH
                BKAWH: u4,
                reserved8: u4,
                ///  AWHT
                AWHT: u24,
            }),
            ///  DFSDM filter 0 analog watchdog low threshold register
            DFSDM_FLT0AWLTR: mmio.Mmio(packed struct(u32) {
                ///  BKAWL
                BKAWL: u4,
                reserved8: u4,
                ///  AWLT
                AWLT: u24,
            }),
            ///  DFSDM filter 0 analog watchdog status register
            DFSDM_FLT0AWSR: mmio.Mmio(packed struct(u32) {
                ///  AWLTF
                AWLTF: u8,
                ///  AWHTF
                AWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM filter 0 analog watchdog clear flag register
            DFSDM_FLT0AWCFR: mmio.Mmio(packed struct(u32) {
                ///  CLRAWLTF
                CLRAWLTF: u8,
                ///  CLRAWHTF
                CLRAWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM filter 0 extremes detector maximum register
            DFSDM_FLT0EXMAX: mmio.Mmio(packed struct(u32) {
                ///  EXMAXCH
                EXMAXCH: u3,
                reserved8: u5,
                ///  EXMAX
                EXMAX: u24,
            }),
            ///  DFSDM filter 0 extremes detector minimum register
            DFSDM_FLT0EXMIN: mmio.Mmio(packed struct(u32) {
                ///  EXMINCH
                EXMINCH: u3,
                reserved8: u5,
                ///  EXMIN
                EXMIN: u24,
            }),
            ///  DFSDM filter 0 conversion timer register
            DFSDM_FLT0CNVTIMR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  CNVCNT
                CNVCNT: u28,
            }),
            reserved384: [68]u8,
            ///  DFSDM filter 1 control register 1
            DFSDM_FLT1CR1: mmio.Mmio(packed struct(u32) {
                ///  DFEN
                DFEN: u1,
                ///  JSWSTART
                JSWSTART: u1,
                reserved3: u1,
                ///  JSYNC
                JSYNC: u1,
                ///  JSCAN
                JSCAN: u1,
                ///  JDMAEN
                JDMAEN: u1,
                reserved8: u2,
                ///  JEXTSEL
                JEXTSEL: u5,
                ///  JEXTEN
                JEXTEN: u2,
                reserved17: u2,
                ///  RSWSTART
                RSWSTART: u1,
                ///  RCONT
                RCONT: u1,
                ///  RSYNC
                RSYNC: u1,
                reserved21: u1,
                ///  RDMAEN
                RDMAEN: u1,
                reserved24: u2,
                ///  RCH
                RCH: u3,
                reserved29: u2,
                ///  FAST
                FAST: u1,
                ///  AWFSEL
                AWFSEL: u1,
                padding: u1,
            }),
            ///  DFSDM filter 1 control register 2
            DFSDM_FLT1CR2: mmio.Mmio(packed struct(u32) {
                ///  JEOCIE
                JEOCIE: u1,
                ///  REOCIE
                REOCIE: u1,
                ///  JOVRIE
                JOVRIE: u1,
                ///  ROVRIE
                ROVRIE: u1,
                ///  AWDIE
                AWDIE: u1,
                ///  SCDIE
                SCDIE: u1,
                ///  CKABIE
                CKABIE: u1,
                reserved8: u1,
                ///  EXCH
                EXCH: u8,
                ///  AWDCH
                AWDCH: u8,
                padding: u8,
            }),
            ///  DFSDM filter 1 interrupt and status register
            DFSDM_FLT1ISR: mmio.Mmio(packed struct(u32) {
                ///  JEOCF
                JEOCF: u1,
                ///  REOCF
                REOCF: u1,
                ///  JOVRF
                JOVRF: u1,
                ///  ROVRF
                ROVRF: u1,
                ///  AWDF
                AWDF: u1,
                reserved13: u8,
                ///  JCIP
                JCIP: u1,
                ///  RCIP
                RCIP: u1,
                reserved16: u1,
                ///  CKABF
                CKABF: u8,
                ///  SCDF
                SCDF: u8,
            }),
            ///  DFSDM filter 1 interrupt flag clear register
            DFSDM_FLT1ICR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  CLRJOVRF
                CLRJOVRF: u1,
                ///  CLRROVRF
                CLRROVRF: u1,
                reserved16: u12,
                ///  CLRCKABF
                CLRCKABF: u8,
                ///  CLRSCDF
                CLRSCDF: u8,
            }),
            ///  DFSDM filter 1 injected channel group selection register
            DFSDM_FLT1JCHGR: mmio.Mmio(packed struct(u32) {
                ///  JCHG
                JCHG: u8,
                padding: u24,
            }),
            ///  DFSDM filter 1 control register
            DFSDM_FLT1FCR: mmio.Mmio(packed struct(u32) {
                ///  IOSR
                IOSR: u8,
                reserved16: u8,
                ///  FOSR
                FOSR: u10,
                reserved29: u3,
                ///  FORD
                FORD: u3,
            }),
            ///  DFSDM filter 1 data register for injected group
            DFSDM_FLT1JDATAR: mmio.Mmio(packed struct(u32) {
                ///  JDATACH
                JDATACH: u3,
                reserved8: u5,
                ///  JDATA
                JDATA: u24,
            }),
            ///  DFSDM filter 1 data register for the regular channel
            DFSDM_FLT1RDATAR: mmio.Mmio(packed struct(u32) {
                ///  RDATACH
                RDATACH: u3,
                reserved4: u1,
                ///  RPEND
                RPEND: u1,
                reserved8: u3,
                ///  RDATA
                RDATA: u24,
            }),
            ///  DFSDM filter 1 analog watchdog high threshold register
            DFSDM_FLT1AWHTR: mmio.Mmio(packed struct(u32) {
                ///  BKAWH
                BKAWH: u4,
                reserved8: u4,
                ///  AWHT
                AWHT: u24,
            }),
            ///  DFSDM filter 1 analog watchdog low threshold register
            DFSDM_FLT1AWLTR: mmio.Mmio(packed struct(u32) {
                ///  BKAWL
                BKAWL: u4,
                reserved8: u4,
                ///  AWLT
                AWLT: u24,
            }),
            ///  DFSDM filter 1 analog watchdog status register
            DFSDM_FLT1AWSR: mmio.Mmio(packed struct(u32) {
                ///  AWLTF
                AWLTF: u8,
                ///  AWHTF
                AWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM filter 1 analog watchdog clear flag register
            DFSDM_FLT1AWCFR: mmio.Mmio(packed struct(u32) {
                ///  CLRAWLTF
                CLRAWLTF: u8,
                ///  CLRAWHTF
                CLRAWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM filter 1 extremes detector maximum register
            DFSDM_FLT1EXMAX: mmio.Mmio(packed struct(u32) {
                ///  EXMAXCH
                EXMAXCH: u3,
                reserved8: u5,
                ///  EXMAX
                EXMAX: u24,
            }),
            ///  DFSDM filter 1 extremes detector minimum register
            DFSDM_FLT1EXMIN: mmio.Mmio(packed struct(u32) {
                ///  EXMINCH
                EXMINCH: u3,
                reserved8: u5,
                ///  EXMIN
                EXMIN: u24,
            }),
            ///  DFSDM filter 1 conversion timer register
            DFSDM_FLT1CNVTIMR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  CNVCNT
                CNVCNT: u28,
            }),
            reserved512: [68]u8,
            ///  DFSDM filter 2 control register 1
            DFSDM_FLT2CR1: mmio.Mmio(packed struct(u32) {
                ///  DFEN
                DFEN: u1,
                ///  JSWSTART
                JSWSTART: u1,
                reserved3: u1,
                ///  JSYNC
                JSYNC: u1,
                ///  JSCAN
                JSCAN: u1,
                ///  JDMAEN
                JDMAEN: u1,
                reserved8: u2,
                ///  JEXTSEL
                JEXTSEL: u5,
                ///  JEXTEN
                JEXTEN: u2,
                reserved17: u2,
                ///  RSWSTART
                RSWSTART: u1,
                ///  RCONT
                RCONT: u1,
                ///  RSYNC
                RSYNC: u1,
                reserved21: u1,
                ///  RDMAEN
                RDMAEN: u1,
                reserved24: u2,
                ///  RCH
                RCH: u3,
                reserved29: u2,
                ///  FAST
                FAST: u1,
                ///  AWFSEL
                AWFSEL: u1,
                padding: u1,
            }),
            ///  DFSDM filter 2 control register 2
            DFSDM_FLT2CR2: mmio.Mmio(packed struct(u32) {
                ///  JEOCIE
                JEOCIE: u1,
                ///  REOCIE
                REOCIE: u1,
                ///  JOVRIE
                JOVRIE: u1,
                ///  ROVRIE
                ROVRIE: u1,
                ///  AWDIE
                AWDIE: u1,
                ///  SCDIE
                SCDIE: u1,
                ///  CKABIE
                CKABIE: u1,
                reserved8: u1,
                ///  EXCH
                EXCH: u8,
                ///  AWDCH
                AWDCH: u8,
                padding: u8,
            }),
            ///  DFSDM filter 2 interrupt and status register
            DFSDM_FLT2ISR: mmio.Mmio(packed struct(u32) {
                ///  JEOCF
                JEOCF: u1,
                ///  REOCF
                REOCF: u1,
                ///  JOVRF
                JOVRF: u1,
                ///  ROVRF
                ROVRF: u1,
                ///  AWDF
                AWDF: u1,
                reserved13: u8,
                ///  JCIP
                JCIP: u1,
                ///  RCIP
                RCIP: u1,
                reserved16: u1,
                ///  CKABF
                CKABF: u8,
                ///  SCDF
                SCDF: u8,
            }),
            ///  DFSDM filter 2 interrupt flag clear register
            DFSDM_FLT2ICR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  CLRJOVRF
                CLRJOVRF: u1,
                ///  CLRROVRF
                CLRROVRF: u1,
                reserved16: u12,
                ///  CLRCKABF
                CLRCKABF: u8,
                ///  CLRSCDF
                CLRSCDF: u8,
            }),
            ///  DFSDM filter 2 injected channel group selection register
            DFSDM_FLT2JCHGR: mmio.Mmio(packed struct(u32) {
                ///  JCHG
                JCHG: u8,
                padding: u24,
            }),
            ///  DFSDM filter 2 control register
            DFSDM_FLT2FCR: mmio.Mmio(packed struct(u32) {
                ///  IOSR
                IOSR: u8,
                reserved16: u8,
                ///  FOSR
                FOSR: u10,
                reserved29: u3,
                ///  FORD
                FORD: u3,
            }),
            ///  DFSDM filter 2 data register for injected group
            DFSDM_FLT2JDATAR: mmio.Mmio(packed struct(u32) {
                ///  JDATACH
                JDATACH: u3,
                reserved8: u5,
                ///  JDATA
                JDATA: u24,
            }),
            ///  DFSDM filter 2 data register for the regular channel
            DFSDM_FLT2RDATAR: mmio.Mmio(packed struct(u32) {
                ///  RDATACH
                RDATACH: u3,
                reserved4: u1,
                ///  RPEND
                RPEND: u1,
                reserved8: u3,
                ///  RDATA
                RDATA: u24,
            }),
            ///  DFSDM filter 2 analog watchdog high threshold register
            DFSDM_FLT2AWHTR: mmio.Mmio(packed struct(u32) {
                ///  BKAWH
                BKAWH: u4,
                reserved8: u4,
                ///  AWHT
                AWHT: u24,
            }),
            ///  DFSDM filter 2 analog watchdog low threshold register
            DFSDM_FLT2AWLTR: mmio.Mmio(packed struct(u32) {
                ///  BKAWL
                BKAWL: u4,
                reserved8: u4,
                ///  AWLT
                AWLT: u24,
            }),
            ///  DFSDM filter 2 analog watchdog status register
            DFSDM_FLT2AWSR: mmio.Mmio(packed struct(u32) {
                ///  AWLTF
                AWLTF: u8,
                ///  AWHTF
                AWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM filter 2 analog watchdog clear flag register
            DFSDM_FLT2AWCFR: mmio.Mmio(packed struct(u32) {
                ///  CLRAWLTF
                CLRAWLTF: u8,
                ///  CLRAWHTF
                CLRAWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM filter 2 extremes detector maximum register
            DFSDM_FLT2EXMAX: mmio.Mmio(packed struct(u32) {
                ///  EXMAXCH
                EXMAXCH: u3,
                reserved8: u5,
                ///  EXMAX
                EXMAX: u24,
            }),
            ///  DFSDM filter 2 extremes detector minimum register
            DFSDM_FLT2EXMIN: mmio.Mmio(packed struct(u32) {
                ///  EXMINCH
                EXMINCH: u3,
                reserved8: u5,
                ///  EXMIN
                EXMIN: u24,
            }),
            ///  DFSDM filter 2 conversion timer register
            DFSDM_FLT2CNVTIMR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  CNVCNT
                CNVCNT: u28,
            }),
            reserved640: [68]u8,
            ///  DFSDM filter 3 control register 1
            DFSDM_FLT3CR1: mmio.Mmio(packed struct(u32) {
                ///  DFEN
                DFEN: u1,
                ///  JSWSTART
                JSWSTART: u1,
                reserved3: u1,
                ///  JSYNC
                JSYNC: u1,
                ///  JSCAN
                JSCAN: u1,
                ///  JDMAEN
                JDMAEN: u1,
                reserved8: u2,
                ///  JEXTSEL
                JEXTSEL: u5,
                ///  JEXTEN
                JEXTEN: u2,
                reserved17: u2,
                ///  RSWSTART
                RSWSTART: u1,
                ///  RCONT
                RCONT: u1,
                ///  RSYNC
                RSYNC: u1,
                reserved21: u1,
                ///  RDMAEN
                RDMAEN: u1,
                reserved24: u2,
                ///  RCH
                RCH: u3,
                reserved29: u2,
                ///  FAST
                FAST: u1,
                ///  AWFSEL
                AWFSEL: u1,
                padding: u1,
            }),
            ///  DFSDM filter 3 control register 2
            DFSDM_FLT3CR2: mmio.Mmio(packed struct(u32) {
                ///  JEOCIE
                JEOCIE: u1,
                ///  REOCIE
                REOCIE: u1,
                ///  JOVRIE
                JOVRIE: u1,
                ///  ROVRIE
                ROVRIE: u1,
                ///  AWDIE
                AWDIE: u1,
                ///  SCDIE
                SCDIE: u1,
                ///  CKABIE
                CKABIE: u1,
                reserved8: u1,
                ///  EXCH
                EXCH: u8,
                ///  AWDCH
                AWDCH: u8,
                padding: u8,
            }),
            ///  DFSDM filter 3 interrupt and status register
            DFSDM_FLT3ISR: mmio.Mmio(packed struct(u32) {
                ///  JEOCF
                JEOCF: u1,
                ///  REOCF
                REOCF: u1,
                ///  JOVRF
                JOVRF: u1,
                ///  ROVRF
                ROVRF: u1,
                ///  AWDF
                AWDF: u1,
                reserved13: u8,
                ///  JCIP
                JCIP: u1,
                ///  RCIP
                RCIP: u1,
                reserved16: u1,
                ///  CKABF
                CKABF: u8,
                ///  SCDF
                SCDF: u8,
            }),
            ///  DFSDM filter 3 interrupt flag clear register
            DFSDM_FLT3ICR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  CLRJOVRF
                CLRJOVRF: u1,
                ///  CLRROVRF
                CLRROVRF: u1,
                reserved16: u12,
                ///  CLRCKABF
                CLRCKABF: u8,
                ///  CLRSCDF
                CLRSCDF: u8,
            }),
            ///  DFSDM filter 3 injected channel group selection register
            DFSDM_FLT3JCHGR: mmio.Mmio(packed struct(u32) {
                ///  JCHG
                JCHG: u8,
                padding: u24,
            }),
            ///  DFSDM filter 3 control register
            DFSDM_FLT3FCR: mmio.Mmio(packed struct(u32) {
                ///  IOSR
                IOSR: u8,
                reserved16: u8,
                ///  FOSR
                FOSR: u10,
                reserved29: u3,
                ///  FORD
                FORD: u3,
            }),
            ///  DFSDM filter 3 data register for injected group
            DFSDM_FLT3JDATAR: mmio.Mmio(packed struct(u32) {
                ///  JDATACH
                JDATACH: u3,
                reserved8: u5,
                ///  JDATA
                JDATA: u24,
            }),
            ///  DFSDM filter 3 data register for the regular channel
            DFSDM_FLT3RDATAR: mmio.Mmio(packed struct(u32) {
                ///  RDATACH
                RDATACH: u3,
                reserved4: u1,
                ///  RPEND
                RPEND: u1,
                reserved8: u3,
                ///  RDATA
                RDATA: u24,
            }),
            ///  DFSDM filter 3 analog watchdog high threshold register
            DFSDM_FLT3AWHTR: mmio.Mmio(packed struct(u32) {
                ///  BKAWH
                BKAWH: u4,
                reserved8: u4,
                ///  AWHT
                AWHT: u24,
            }),
            ///  DFSDM filter 3 analog watchdog low threshold register
            DFSDM_FLT3AWLTR: mmio.Mmio(packed struct(u32) {
                ///  BKAWL
                BKAWL: u4,
                reserved8: u4,
                ///  AWLT
                AWLT: u24,
            }),
            ///  DFSDM filter 3 analog watchdog status register
            DFSDM_FLT3AWSR: mmio.Mmio(packed struct(u32) {
                ///  AWLTF
                AWLTF: u8,
                ///  AWHTF
                AWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM filter 3 analog watchdog clear flag register
            DFSDM_FLT3AWCFR: mmio.Mmio(packed struct(u32) {
                ///  CLRAWLTF
                CLRAWLTF: u8,
                ///  CLRAWHTF
                CLRAWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM filter 3 extremes detector maximum register
            DFSDM_FLT3EXMAX: mmio.Mmio(packed struct(u32) {
                ///  EXMAXCH
                EXMAXCH: u3,
                reserved8: u5,
                ///  EXMAX
                EXMAX: u24,
            }),
            ///  DFSDM filter 3 extremes detector minimum register
            DFSDM_FLT3EXMIN: mmio.Mmio(packed struct(u32) {
                ///  EXMINCH
                EXMINCH: u3,
                reserved8: u5,
                ///  EXMIN
                EXMIN: u24,
            }),
            ///  DFSDM filter 3 conversion timer register
            DFSDM_FLT3CNVTIMR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  CNVCNT
                CNVCNT: u28,
            }),
            reserved768: [68]u8,
            ///  DFSDM filter 4 control register 1
            DFSDM_FLT4CR1: mmio.Mmio(packed struct(u32) {
                ///  DFEN
                DFEN: u1,
                ///  JSWSTART
                JSWSTART: u1,
                reserved3: u1,
                ///  JSYNC
                JSYNC: u1,
                ///  JSCAN
                JSCAN: u1,
                ///  JDMAEN
                JDMAEN: u1,
                reserved8: u2,
                ///  JEXTSEL
                JEXTSEL: u5,
                ///  JEXTEN
                JEXTEN: u2,
                reserved17: u2,
                ///  RSWSTART
                RSWSTART: u1,
                ///  RCONT
                RCONT: u1,
                ///  RSYNC
                RSYNC: u1,
                reserved21: u1,
                ///  RDMAEN
                RDMAEN: u1,
                reserved24: u2,
                ///  RCH
                RCH: u3,
                reserved29: u2,
                ///  FAST
                FAST: u1,
                ///  AWFSEL
                AWFSEL: u1,
                padding: u1,
            }),
            ///  DFSDM filter 4 control register 2
            DFSDM_FLT4CR2: mmio.Mmio(packed struct(u32) {
                ///  JEOCIE
                JEOCIE: u1,
                ///  REOCIE
                REOCIE: u1,
                ///  JOVRIE
                JOVRIE: u1,
                ///  ROVRIE
                ROVRIE: u1,
                ///  AWDIE
                AWDIE: u1,
                ///  SCDIE
                SCDIE: u1,
                ///  CKABIE
                CKABIE: u1,
                reserved8: u1,
                ///  EXCH
                EXCH: u8,
                ///  AWDCH
                AWDCH: u8,
                padding: u8,
            }),
            ///  DFSDM filter 4 interrupt and status register
            DFSDM_FLT4ISR: mmio.Mmio(packed struct(u32) {
                ///  JEOCF
                JEOCF: u1,
                ///  REOCF
                REOCF: u1,
                ///  JOVRF
                JOVRF: u1,
                ///  ROVRF
                ROVRF: u1,
                ///  AWDF
                AWDF: u1,
                reserved13: u8,
                ///  JCIP
                JCIP: u1,
                ///  RCIP
                RCIP: u1,
                reserved16: u1,
                ///  CKABF
                CKABF: u8,
                ///  SCDF
                SCDF: u8,
            }),
            ///  DFSDM filter 4 interrupt flag clear register
            DFSDM_FLT4ICR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  CLRJOVRF
                CLRJOVRF: u1,
                ///  CLRROVRF
                CLRROVRF: u1,
                reserved16: u12,
                ///  CLRCKABF
                CLRCKABF: u8,
                ///  CLRSCDF
                CLRSCDF: u8,
            }),
            ///  DFSDM filter 4 injected channel group selection register
            DFSDM_FLT4JCHGR: mmio.Mmio(packed struct(u32) {
                ///  JCHG
                JCHG: u8,
                padding: u24,
            }),
            ///  DFSDM filter 4 control register
            DFSDM_FLT4FCR: mmio.Mmio(packed struct(u32) {
                ///  IOSR
                IOSR: u8,
                reserved16: u8,
                ///  FOSR
                FOSR: u10,
                reserved29: u3,
                ///  FORD
                FORD: u3,
            }),
            ///  DFSDM filter 4 data register for injected group
            DFSDM_FLT4JDATAR: mmio.Mmio(packed struct(u32) {
                ///  JDATACH
                JDATACH: u3,
                reserved8: u5,
                ///  JDATA
                JDATA: u24,
            }),
            ///  DFSDM filter 4 data register for the regular channel
            DFSDM_FLT4RDATAR: mmio.Mmio(packed struct(u32) {
                ///  RDATACH
                RDATACH: u3,
                reserved4: u1,
                ///  RPEND
                RPEND: u1,
                reserved8: u3,
                ///  RDATA
                RDATA: u24,
            }),
            ///  DFSDM filter 4 analog watchdog high threshold register
            DFSDM_FLT4AWHTR: mmio.Mmio(packed struct(u32) {
                ///  BKAWH
                BKAWH: u4,
                reserved8: u4,
                ///  AWHT
                AWHT: u24,
            }),
            ///  DFSDM filter 4 analog watchdog low threshold register
            DFSDM_FLT4AWLTR: mmio.Mmio(packed struct(u32) {
                ///  BKAWL
                BKAWL: u4,
                reserved8: u4,
                ///  AWLT
                AWLT: u24,
            }),
            ///  DFSDM filter 4 analog watchdog status register
            DFSDM_FLT4AWSR: mmio.Mmio(packed struct(u32) {
                ///  AWLTF
                AWLTF: u8,
                ///  AWHTF
                AWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM filter 4 analog watchdog clear flag register
            DFSDM_FLT4AWCFR: mmio.Mmio(packed struct(u32) {
                ///  CLRAWLTF
                CLRAWLTF: u8,
                ///  CLRAWHTF
                CLRAWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM filter 4 extremes detector maximum register
            DFSDM_FLT4EXMAX: mmio.Mmio(packed struct(u32) {
                ///  EXMAXCH
                EXMAXCH: u3,
                reserved8: u5,
                ///  EXMAX
                EXMAX: u24,
            }),
            ///  DFSDM filter 4 extremes detector minimum register
            DFSDM_FLT4EXMIN: mmio.Mmio(packed struct(u32) {
                ///  EXMINCH
                EXMINCH: u3,
                reserved8: u5,
                ///  EXMIN
                EXMIN: u24,
            }),
            ///  DFSDM filter 4 conversion timer register
            DFSDM_FLT4CNVTIMR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  CNVCNT
                CNVCNT: u28,
            }),
            reserved896: [68]u8,
            ///  DFSDM filter 5 control register 1
            DFSDM_FLT5CR1: mmio.Mmio(packed struct(u32) {
                ///  DFEN
                DFEN: u1,
                ///  JSWSTART
                JSWSTART: u1,
                reserved3: u1,
                ///  JSYNC
                JSYNC: u1,
                ///  JSCAN
                JSCAN: u1,
                ///  JDMAEN
                JDMAEN: u1,
                reserved8: u2,
                ///  JEXTSEL
                JEXTSEL: u5,
                ///  JEXTEN
                JEXTEN: u2,
                reserved17: u2,
                ///  RSWSTART
                RSWSTART: u1,
                ///  RCONT
                RCONT: u1,
                ///  RSYNC
                RSYNC: u1,
                reserved21: u1,
                ///  RDMAEN
                RDMAEN: u1,
                reserved24: u2,
                ///  RCH
                RCH: u3,
                reserved29: u2,
                ///  FAST
                FAST: u1,
                ///  AWFSEL
                AWFSEL: u1,
                padding: u1,
            }),
            ///  DFSDM filter 5 control register 2
            DFSDM_FLT5CR2: mmio.Mmio(packed struct(u32) {
                ///  JEOCIE
                JEOCIE: u1,
                ///  REOCIE
                REOCIE: u1,
                ///  JOVRIE
                JOVRIE: u1,
                ///  ROVRIE
                ROVRIE: u1,
                ///  AWDIE
                AWDIE: u1,
                ///  SCDIE
                SCDIE: u1,
                ///  CKABIE
                CKABIE: u1,
                reserved8: u1,
                ///  EXCH
                EXCH: u8,
                ///  AWDCH
                AWDCH: u8,
                padding: u8,
            }),
            ///  DFSDM filter 5 interrupt and status register
            DFSDM_FLT5ISR: mmio.Mmio(packed struct(u32) {
                ///  JEOCF
                JEOCF: u1,
                ///  REOCF
                REOCF: u1,
                ///  JOVRF
                JOVRF: u1,
                ///  ROVRF
                ROVRF: u1,
                ///  AWDF
                AWDF: u1,
                reserved13: u8,
                ///  JCIP
                JCIP: u1,
                ///  RCIP
                RCIP: u1,
                reserved16: u1,
                ///  CKABF
                CKABF: u8,
                ///  SCDF
                SCDF: u8,
            }),
            ///  DFSDM filter 5 interrupt flag clear register
            DFSDM_FLT5ICR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  CLRJOVRF
                CLRJOVRF: u1,
                ///  CLRROVRF
                CLRROVRF: u1,
                reserved16: u12,
                ///  CLRCKABF
                CLRCKABF: u8,
                ///  CLRSCDF
                CLRSCDF: u8,
            }),
            ///  DFSDM filter 5 injected channel group selection register
            DFSDM_FLT5JCHGR: mmio.Mmio(packed struct(u32) {
                ///  JCHG
                JCHG: u8,
                padding: u24,
            }),
            ///  DFSDM filter 5 control register
            DFSDM_FLT5FCR: mmio.Mmio(packed struct(u32) {
                ///  IOSR
                IOSR: u8,
                reserved16: u8,
                ///  FOSR
                FOSR: u10,
                reserved29: u3,
                ///  FORD
                FORD: u3,
            }),
            ///  DFSDM filter 5 data register for injected group
            DFSDM_FLT5JDATAR: mmio.Mmio(packed struct(u32) {
                ///  JDATACH
                JDATACH: u3,
                reserved8: u5,
                ///  JDATA
                JDATA: u24,
            }),
            ///  DFSDM filter 5 data register for the regular channel
            DFSDM_FLT5RDATAR: mmio.Mmio(packed struct(u32) {
                ///  RDATACH
                RDATACH: u3,
                reserved4: u1,
                ///  RPEND
                RPEND: u1,
                reserved8: u3,
                ///  RDATA
                RDATA: u24,
            }),
            ///  DFSDM filter 5 analog watchdog high threshold register
            DFSDM_FLT5AWHTR: mmio.Mmio(packed struct(u32) {
                ///  BKAWH
                BKAWH: u4,
                reserved8: u4,
                ///  AWHT
                AWHT: u24,
            }),
            ///  DFSDM filter 5 analog watchdog low threshold register
            DFSDM_FLT5AWLTR: mmio.Mmio(packed struct(u32) {
                ///  BKAWL
                BKAWL: u4,
                reserved8: u4,
                ///  AWLT
                AWLT: u24,
            }),
            ///  DFSDM filter 5 analog watchdog status register
            DFSDM_FLT5AWSR: mmio.Mmio(packed struct(u32) {
                ///  AWLTF
                AWLTF: u8,
                ///  AWHTF
                AWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM filter 5 analog watchdog clear flag register
            DFSDM_FLT5AWCFR: mmio.Mmio(packed struct(u32) {
                ///  CLRAWLTF
                CLRAWLTF: u8,
                ///  CLRAWHTF
                CLRAWHTF: u8,
                padding: u16,
            }),
            ///  DFSDM filter 5 extremes detector maximum register
            DFSDM_FLT5EXMAX: mmio.Mmio(packed struct(u32) {
                ///  EXMAXCH
                EXMAXCH: u3,
                reserved8: u5,
                ///  EXMAX
                EXMAX: u24,
            }),
            ///  DFSDM filter 5 extremes detector minimum register
            DFSDM_FLT5EXMIN: mmio.Mmio(packed struct(u32) {
                ///  EXMINCH
                EXMINCH: u3,
                reserved8: u5,
                ///  EXMIN
                EXMIN: u24,
            }),
            ///  DFSDM filter 5 conversion timer register
            DFSDM_FLT5CNVTIMR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  CNVCNT
                CNVCNT: u28,
            }),
            reserved2032: [1076]u8,
            ///  This register specifies the hardware configuration of DFSDM peripheral.
            DFSDM_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  NBT
                NBT: u8,
                ///  NBF
                NBF: u8,
                padding: u16,
            }),
            ///  This register specifies the version of DFSDM peripheral.
            DFSDM_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  This register specifies the identification of DFSDM peripheral.
            DFSDM_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  This register specifies the size allocated to DFSDM registers.
            DFSDM_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  DLYBQS
        pub const DLYBQS = extern struct {
            ///  DLYB control register
            DLYB_CR: mmio.Mmio(packed struct(u32) {
                ///  DEN
                DEN: u1,
                ///  SEN
                SEN: u1,
                padding: u30,
            }),
            ///  DLYB configuration register
            DLYB_CFGR: mmio.Mmio(packed struct(u32) {
                ///  SEL
                SEL: u4,
                reserved8: u4,
                ///  UNIT
                UNIT: u7,
                reserved16: u1,
                ///  LNG
                LNG: u12,
                reserved31: u3,
                ///  LNGF
                LNGF: u1,
            }),
            reserved1012: [1004]u8,
            ///  DLYB IP version register
            DLYB_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  DLYB IP identification register
            DLYB_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  DLYB size ID register
            DLYB_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  DLYBSD1
        pub const DLYBSD1 = extern struct {
            ///  DLYB control register
            DLYB_CR: mmio.Mmio(packed struct(u32) {
                ///  DEN
                DEN: u1,
                ///  SEN
                SEN: u1,
                padding: u30,
            }),
            ///  DLYB configuration register
            DLYB_CFGR: mmio.Mmio(packed struct(u32) {
                ///  SEL
                SEL: u4,
                reserved8: u4,
                ///  UNIT
                UNIT: u7,
                reserved16: u1,
                ///  LNG
                LNG: u12,
                reserved31: u3,
                ///  LNGF
                LNGF: u1,
            }),
            reserved1012: [1004]u8,
            ///  DLYB IP version register
            DLYB_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  DLYB IP identification register
            DLYB_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  DLYB size ID register
            DLYB_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  USBPHYC
        pub const USBPHYC = extern struct {
            ///  This register is used to control the PLL of the HS PHY.
            USBPHYC_PLL: mmio.Mmio(packed struct(u32) {
                ///  PLLNDIV
                PLLNDIV: u7,
                ///  PLLODF
                PLLODF: u3,
                ///  PLLFRACIN
                PLLFRACIN: u16,
                ///  PLLEN
                PLLEN: u1,
                ///  PLLSTRB
                PLLSTRB: u1,
                ///  PLLSTRBYP
                PLLSTRBYP: u1,
                ///  PLLFRACCTL
                PLLFRACCTL: u1,
                ///  PLLDITHEN0
                PLLDITHEN0: u1,
                ///  PLLDITHEN1
                PLLDITHEN1: u1,
            }),
            reserved8: [4]u8,
            ///  This register is used to control the switch between controllers for the HS PHY.
            USBPHYC_MISC: mmio.Mmio(packed struct(u32) {
                ///  SWITHOST
                SWITHOST: u1,
                ///  PPCKDIS
                PPCKDIS: u2,
                padding: u29,
            }),
            reserved268: [256]u8,
            ///  This register is used to control the tune interface of the HS PHY, port #x.
            USBPHYC_TUNE1: mmio.Mmio(packed struct(u32) {
                ///  INCURREN
                INCURREN: u1,
                ///  INCURRINT
                INCURRINT: u1,
                ///  LFSCAPEN
                LFSCAPEN: u1,
                ///  HSDRVSLEW
                HSDRVSLEW: u1,
                ///  HSDRVDCCUR
                HSDRVDCCUR: u1,
                ///  HSDRVDCLEV
                HSDRVDCLEV: u1,
                ///  HSDRVCURINCR
                HSDRVCURINCR: u1,
                ///  FSDRVRFADJ
                FSDRVRFADJ: u1,
                ///  HSDRVRFRED
                HSDRVRFRED: u1,
                ///  HSDRVCHKITRM
                HSDRVCHKITRM: u4,
                ///  HSDRVCHKZTRM
                HSDRVCHKZTRM: u2,
                ///  OTPCOMP
                OTPCOMP: u5,
                ///  SQLCHCTL
                SQLCHCTL: u2,
                ///  HDRXGNEQEN
                HDRXGNEQEN: u1,
                ///  HSRXOFF
                HSRXOFF: u2,
                ///  HSFALLPREEM
                HSFALLPREEM: u1,
                ///  SHTCCTCTLPROT
                SHTCCTCTLPROT: u1,
                ///  STAGSEL
                STAGSEL: u1,
                padding: u4,
            }),
            reserved524: [252]u8,
            ///  This register is used to control the tune interface of the HS PHY, port #x.
            USBPHYC_TUNE2: mmio.Mmio(packed struct(u32) {
                ///  INCURREN
                INCURREN: u1,
                ///  INCURRINT
                INCURRINT: u1,
                ///  LFSCAPEN
                LFSCAPEN: u1,
                ///  HSDRVSLEW
                HSDRVSLEW: u1,
                ///  HSDRVDCCUR
                HSDRVDCCUR: u1,
                ///  HSDRVDCLEV
                HSDRVDCLEV: u1,
                ///  HSDRVCURINCR
                HSDRVCURINCR: u1,
                ///  FSDRVRFADJ
                FSDRVRFADJ: u1,
                ///  HSDRVRFRED
                HSDRVRFRED: u1,
                ///  HSDRVCHKITRM
                HSDRVCHKITRM: u4,
                ///  HSDRVCHKZTRM
                HSDRVCHKZTRM: u2,
                ///  OTPCOMP
                OTPCOMP: u5,
                ///  SQLCHCTL
                SQLCHCTL: u2,
                ///  HDRXGNEQEN
                HDRXGNEQEN: u1,
                ///  HSRXOFF
                HSRXOFF: u2,
                ///  HSFALLPREEM
                HSFALLPREEM: u1,
                ///  SHTCCTCTLPROT
                SHTCCTCTLPROT: u1,
                ///  STAGSEL
                STAGSEL: u1,
                padding: u4,
            }),
            reserved4092: [3564]u8,
            ///  This register defines the version of this IP.
            USBPHYC_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
        };

        ///  TIM4
        pub const TIM4 = extern struct {
            ///  TIM4 control register 1
            TIM4_CR1: mmio.Mmio(packed struct(u16) {
                ///  CEN
                CEN: u1,
                ///  UDIS
                UDIS: u1,
                ///  URS
                URS: u1,
                ///  OPM
                OPM: u1,
                ///  DIR
                DIR: u1,
                ///  CMS
                CMS: u2,
                ///  ARPE
                ARPE: u1,
                ///  CKD
                CKD: u2,
                reserved11: u1,
                ///  UIFREMAP
                UIFREMAP: u1,
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM4 control register 2
            TIM4_CR2: mmio.Mmio(packed struct(u32) {
                ///  CCPC
                CCPC: u1,
                reserved2: u1,
                ///  CCUS
                CCUS: u1,
                ///  CCDS
                CCDS: u1,
                ///  MMS
                MMS: u3,
                ///  TI1S
                TI1S: u1,
                ///  OIS1
                OIS1: u1,
                ///  OIS1N
                OIS1N: u1,
                ///  OIS2
                OIS2: u1,
                ///  OIS2N
                OIS2N: u1,
                ///  OIS3
                OIS3: u1,
                ///  OIS3N
                OIS3N: u1,
                ///  OIS4
                OIS4: u1,
                reserved16: u1,
                ///  OIS5
                OIS5: u1,
                reserved18: u1,
                ///  OIS6
                OIS6: u1,
                reserved20: u1,
                ///  MMS2
                MMS2: u4,
                padding: u8,
            }),
            ///  TIM4 slave mode control register
            TIM4_SMCR: mmio.Mmio(packed struct(u32) {
                ///  SMS
                SMS: u3,
                reserved4: u1,
                ///  TS
                TS: u3,
                ///  MSM
                MSM: u1,
                ///  ETF
                ETF: u4,
                ///  ETPS
                ETPS: u2,
                ///  ECE
                ECE: u1,
                ///  ETP
                ETP: u1,
                ///  SMS3
                SMS3: u1,
                reserved20: u3,
                ///  TS3
                TS3: u1,
                ///  TS4
                TS4: u1,
                padding: u10,
            }),
            ///  TIM4 DMA/interrupt enable register
            TIM4_DIER: mmio.Mmio(packed struct(u16) {
                ///  UIE
                UIE: u1,
                ///  CC1IE
                CC1IE: u1,
                ///  CC2IE
                CC2IE: u1,
                ///  CC3IE
                CC3IE: u1,
                ///  CC4IE
                CC4IE: u1,
                ///  COMIE
                COMIE: u1,
                ///  TIE
                TIE: u1,
                ///  BIE
                BIE: u1,
                ///  UDE
                UDE: u1,
                ///  CC1DE
                CC1DE: u1,
                ///  CC2DE
                CC2DE: u1,
                ///  CC3DE
                CC3DE: u1,
                ///  CC4DE
                CC4DE: u1,
                ///  COMDE
                COMDE: u1,
                ///  TDE
                TDE: u1,
                padding: u1,
            }),
            reserved16: [2]u8,
            ///  TIM4 status register
            TIM4_SR: mmio.Mmio(packed struct(u32) {
                ///  UIF
                UIF: u1,
                ///  CC1IF
                CC1IF: u1,
                ///  CC2IF
                CC2IF: u1,
                ///  CC3IF
                CC3IF: u1,
                ///  CC4IF
                CC4IF: u1,
                ///  COMIF
                COMIF: u1,
                ///  TIF
                TIF: u1,
                ///  BIF
                BIF: u1,
                ///  B2IF
                B2IF: u1,
                ///  CC1OF
                CC1OF: u1,
                ///  CC2OF
                CC2OF: u1,
                ///  CC3OF
                CC3OF: u1,
                ///  CC4OF
                CC4OF: u1,
                ///  SBIF
                SBIF: u1,
                reserved16: u2,
                ///  CC5IF
                CC5IF: u1,
                ///  CC6IF
                CC6IF: u1,
                padding: u14,
            }),
            ///  TIM4 event generation register
            TIM4_EGR: mmio.Mmio(packed struct(u16) {
                ///  UG
                UG: u1,
                ///  CC1G
                CC1G: u1,
                ///  CC2G
                CC2G: u1,
                ///  CC3G
                CC3G: u1,
                ///  CC4G
                CC4G: u1,
                ///  COMG
                COMG: u1,
                ///  TG
                TG: u1,
                ///  BG
                BG: u1,
                ///  B2G
                B2G: u1,
                padding: u7,
            }),
            reserved24: [2]u8,
            ///  The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
            TIM4_CCMR1ALTERNATE4: mmio.Mmio(packed struct(u32) {
                ///  CC1S
                CC1S: u2,
                ///  IC1PSC
                IC1PSC: u2,
                ///  IC1F
                IC1F: u4,
                ///  CC2S
                CC2S: u2,
                ///  IC2PSC
                IC2PSC: u2,
                ///  IC2F
                IC2F: u4,
                padding: u16,
            }),
            ///  The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
            TIM4_CCMR2ALTERNATE20: mmio.Mmio(packed struct(u32) {
                ///  CC3S
                CC3S: u2,
                ///  IC3PSC
                IC3PSC: u2,
                ///  IC3F
                IC3F: u4,
                ///  CC4S
                CC4S: u2,
                ///  IC4PSC
                IC4PSC: u2,
                ///  IC4F
                IC4F: u4,
                padding: u16,
            }),
            ///  TIM4 capture/compare enable register
            TIM4_CCER: mmio.Mmio(packed struct(u32) {
                ///  CC1E
                CC1E: u1,
                ///  CC1P
                CC1P: u1,
                ///  CC1NE
                CC1NE: u1,
                ///  CC1NP
                CC1NP: u1,
                ///  CC2E
                CC2E: u1,
                ///  CC2P
                CC2P: u1,
                ///  CC2NE
                CC2NE: u1,
                ///  CC2NP
                CC2NP: u1,
                ///  CC3E
                CC3E: u1,
                ///  CC3P
                CC3P: u1,
                ///  CC3NE
                CC3NE: u1,
                ///  CC3NP
                CC3NP: u1,
                ///  CC4E
                CC4E: u1,
                ///  CC4P
                CC4P: u1,
                reserved15: u1,
                ///  CC4NP
                CC4NP: u1,
                ///  CC5E
                CC5E: u1,
                ///  CC5P
                CC5P: u1,
                reserved20: u2,
                ///  CC6E
                CC6E: u1,
                ///  CC6P
                CC6P: u1,
                padding: u10,
            }),
            ///  TIM4 counter
            TIM4_CNT: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u16,
                reserved31: u15,
                ///  UIFCPY
                UIFCPY: u1,
            }),
            ///  TIM4 prescaler
            TIM4_PSC: mmio.Mmio(packed struct(u16) {
                ///  PSC
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM4 auto-reload register
            TIM4_ARR: mmio.Mmio(packed struct(u16) {
                ///  ARR
                ARR: u16,
            }),
            reserved48: [2]u8,
            ///  TIM4 repetition counter register
            TIM4_RCR: mmio.Mmio(packed struct(u16) {
                ///  REP
                REP: u16,
            }),
            reserved52: [2]u8,
            ///  TIM4 capture/compare register 1
            TIM4_CCR1: mmio.Mmio(packed struct(u16) {
                ///  CCR1
                CCR1: u16,
            }),
            reserved56: [2]u8,
            ///  TIM4 capture/compare register 2
            TIM4_CCR2: mmio.Mmio(packed struct(u16) {
                ///  CCR2
                CCR2: u16,
            }),
            reserved60: [2]u8,
            ///  TIM4 capture/compare register 3
            TIM4_CCR3: mmio.Mmio(packed struct(u16) {
                ///  CCR3
                CCR3: u16,
            }),
            reserved64: [2]u8,
            ///  TIM4 capture/compare register 4
            TIM4_CCR4: mmio.Mmio(packed struct(u16) {
                ///  CCR4
                CCR4: u16,
            }),
            reserved68: [2]u8,
            ///  As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
            TIM4_BDTR: mmio.Mmio(packed struct(u32) {
                ///  DTG
                DTG: u8,
                ///  LOCK
                LOCK: u2,
                ///  OSSI
                OSSI: u1,
                ///  OSSR
                OSSR: u1,
                ///  BKE
                BKE: u1,
                ///  BKP
                BKP: u1,
                ///  AOE
                AOE: u1,
                ///  MOE
                MOE: u1,
                ///  BKF
                BKF: u4,
                ///  BK2F
                BK2F: u4,
                ///  BK2E
                BK2E: u1,
                ///  BK2P
                BK2P: u1,
                ///  BKDSRM
                BKDSRM: u1,
                ///  BK2DSRM
                BK2DSRM: u1,
                ///  BKBID
                BKBID: u1,
                ///  BK2BID
                BK2BID: u1,
                padding: u2,
            }),
            ///  TIM4 DMA control register
            TIM4_DCR: mmio.Mmio(packed struct(u16) {
                ///  DBA
                DBA: u5,
                reserved8: u3,
                ///  DBL
                DBL: u5,
                padding: u3,
            }),
            reserved76: [2]u8,
            ///  TIM4 DMA address for full transfer
            TIM4_DMAR: mmio.Mmio(packed struct(u32) {
                ///  DMAB
                DMAB: u32,
            }),
            reserved84: [4]u8,
            ///  The channels 5 and 6 can only be configured in output. Output compare mode:
            TIM4_CCMR3: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  OC5FE
                OC5FE: u1,
                ///  OC5PE
                OC5PE: u1,
                ///  OC5M
                OC5M: u3,
                ///  OC5CE
                OC5CE: u1,
                reserved10: u2,
                ///  OC6FE
                OC6FE: u1,
                ///  OC6PE
                OC6PE: u1,
                ///  OC6M
                OC6M: u3,
                ///  OC6CE
                OC6CE: u1,
                ///  OC5M3
                OC5M3: u1,
                reserved24: u7,
                ///  OC6M3
                OC6M3: u1,
                padding: u7,
            }),
            ///  TIM4 capture/compare register 5
            TIM4_CCR5: mmio.Mmio(packed struct(u32) {
                ///  CCR5
                CCR5: u16,
                reserved29: u13,
                ///  GC5C1
                GC5C1: u1,
                ///  GC5C2
                GC5C2: u1,
                ///  GC5C3
                GC5C3: u1,
            }),
            ///  TIM4 capture/compare register 6
            TIM4_CCR6: mmio.Mmio(packed struct(u16) {
                ///  CCR6
                CCR6: u16,
            }),
        };

        ///  DMA1
        pub const DMA1 = extern struct {
            ///  DMA low interrupt status register
            DMA_LISR: mmio.Mmio(packed struct(u32) {
                ///  FEIF0
                FEIF0: u1,
                reserved2: u1,
                ///  DMEIF0
                DMEIF0: u1,
                ///  TEIF0
                TEIF0: u1,
                ///  HTIF0
                HTIF0: u1,
                ///  TCIF0
                TCIF0: u1,
                ///  FEIF1
                FEIF1: u1,
                reserved8: u1,
                ///  DMEIF1
                DMEIF1: u1,
                ///  TEIF1
                TEIF1: u1,
                ///  HTIF1
                HTIF1: u1,
                ///  TCIF1
                TCIF1: u1,
                reserved16: u4,
                ///  FEIF2
                FEIF2: u1,
                reserved18: u1,
                ///  DMEIF2
                DMEIF2: u1,
                ///  TEIF2
                TEIF2: u1,
                ///  HTIF2
                HTIF2: u1,
                ///  TCIF2
                TCIF2: u1,
                ///  FEIF3
                FEIF3: u1,
                reserved24: u1,
                ///  DMEIF3
                DMEIF3: u1,
                ///  TEIF3
                TEIF3: u1,
                ///  HTIF3
                HTIF3: u1,
                ///  TCIF3
                TCIF3: u1,
                padding: u4,
            }),
            ///  DMA high interrupt status register
            DMA_HISR: mmio.Mmio(packed struct(u32) {
                ///  FEIF4
                FEIF4: u1,
                reserved2: u1,
                ///  DMEIF4
                DMEIF4: u1,
                ///  TEIF4
                TEIF4: u1,
                ///  HTIF4
                HTIF4: u1,
                ///  TCIF4
                TCIF4: u1,
                ///  FEIF5
                FEIF5: u1,
                reserved8: u1,
                ///  DMEIF5
                DMEIF5: u1,
                ///  TEIF5
                TEIF5: u1,
                ///  HTIF5
                HTIF5: u1,
                ///  TCIF5
                TCIF5: u1,
                reserved16: u4,
                ///  FEIF6
                FEIF6: u1,
                reserved18: u1,
                ///  DMEIF6
                DMEIF6: u1,
                ///  TEIF6
                TEIF6: u1,
                ///  HTIF6
                HTIF6: u1,
                ///  TCIF6
                TCIF6: u1,
                ///  FEIF7
                FEIF7: u1,
                reserved24: u1,
                ///  DMEIF7
                DMEIF7: u1,
                ///  TEIF7
                TEIF7: u1,
                ///  HTIF7
                HTIF7: u1,
                ///  TCIF7
                TCIF7: u1,
                padding: u4,
            }),
            ///  DMA low interrupt flag clear register
            DMA_LIFCR: mmio.Mmio(packed struct(u32) {
                ///  CFEIF0
                CFEIF0: u1,
                reserved2: u1,
                ///  CDMEIF0
                CDMEIF0: u1,
                ///  CTEIF0
                CTEIF0: u1,
                ///  CHTIF0
                CHTIF0: u1,
                ///  CTCIF0
                CTCIF0: u1,
                ///  CFEIF1
                CFEIF1: u1,
                reserved8: u1,
                ///  CDMEIF1
                CDMEIF1: u1,
                ///  CTEIF1
                CTEIF1: u1,
                ///  CHTIF1
                CHTIF1: u1,
                ///  CTCIF1
                CTCIF1: u1,
                reserved16: u4,
                ///  CFEIF2
                CFEIF2: u1,
                reserved18: u1,
                ///  CDMEIF2
                CDMEIF2: u1,
                ///  CTEIF2
                CTEIF2: u1,
                ///  CHTIF2
                CHTIF2: u1,
                ///  CTCIF2
                CTCIF2: u1,
                ///  CFEIF3
                CFEIF3: u1,
                reserved24: u1,
                ///  CDMEIF3
                CDMEIF3: u1,
                ///  CTEIF3
                CTEIF3: u1,
                ///  CHTIF3
                CHTIF3: u1,
                ///  CTCIF3
                CTCIF3: u1,
                padding: u4,
            }),
            ///  DMA high interrupt flag clear register
            DMA_HIFCR: mmio.Mmio(packed struct(u32) {
                ///  CFEIF4
                CFEIF4: u1,
                reserved2: u1,
                ///  CDMEIF4
                CDMEIF4: u1,
                ///  CTEIF4
                CTEIF4: u1,
                ///  CHTIF4
                CHTIF4: u1,
                ///  CTCIF4
                CTCIF4: u1,
                ///  CFEIF5
                CFEIF5: u1,
                reserved8: u1,
                ///  CDMEIF5
                CDMEIF5: u1,
                ///  CTEIF5
                CTEIF5: u1,
                ///  CHTIF5
                CHTIF5: u1,
                ///  CTCIF5
                CTCIF5: u1,
                reserved16: u4,
                ///  CFEIF6
                CFEIF6: u1,
                reserved18: u1,
                ///  CDMEIF6
                CDMEIF6: u1,
                ///  CTEIF6
                CTEIF6: u1,
                ///  CHTIF6
                CHTIF6: u1,
                ///  CTCIF6
                CTCIF6: u1,
                ///  CFEIF7
                CFEIF7: u1,
                reserved24: u1,
                ///  CDMEIF7
                CDMEIF7: u1,
                ///  CTEIF7
                CTEIF7: u1,
                ///  CHTIF7
                CHTIF7: u1,
                ///  CTCIF7
                CTCIF7: u1,
                padding: u4,
            }),
            ///  This register is used to configure the concerned stream.
            DMA_S0CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  DMEIE
                DMEIE: u1,
                ///  TEIE
                TEIE: u1,
                ///  HTIE
                HTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PFCTRL
                PFCTRL: u1,
                ///  DIR
                DIR: u2,
                ///  CIRC
                CIRC: u1,
                ///  PINC
                PINC: u1,
                ///  MINC
                MINC: u1,
                ///  PSIZE
                PSIZE: u2,
                ///  MSIZE
                MSIZE: u2,
                ///  PINCOS
                PINCOS: u1,
                ///  PL
                PL: u2,
                ///  DBM
                DBM: u1,
                ///  CT
                CT: u1,
                reserved21: u1,
                ///  PBURST
                PBURST: u2,
                ///  MBURST
                MBURST: u2,
                padding: u7,
            }),
            ///  DMA stream 0 number of data register
            DMA_S0NDTR: mmio.Mmio(packed struct(u32) {
                ///  NDT
                NDT: u16,
                padding: u16,
            }),
            ///  DMA stream 0 peripheral address register
            DMA_S0PAR: mmio.Mmio(packed struct(u32) {
                ///  PAR
                PAR: u32,
            }),
            ///  DMA stream 0 memory 0 address register
            DMA_S0M0AR: mmio.Mmio(packed struct(u32) {
                ///  M0A
                M0A: u32,
            }),
            ///  DMA stream 0 memory 1 address register
            DMA_S0M1AR: mmio.Mmio(packed struct(u32) {
                ///  M1A
                M1A: u32,
            }),
            ///  DMA stream 0 FIFO control register
            DMA_S0FCR: mmio.Mmio(packed struct(u32) {
                ///  FTH
                FTH: u2,
                ///  DMDIS
                DMDIS: u1,
                ///  FS
                FS: u3,
                reserved7: u1,
                ///  FEIE
                FEIE: u1,
                padding: u24,
            }),
            ///  This register is used to configure the concerned stream.
            DMA_S1CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  DMEIE
                DMEIE: u1,
                ///  TEIE
                TEIE: u1,
                ///  HTIE
                HTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PFCTRL
                PFCTRL: u1,
                ///  DIR
                DIR: u2,
                ///  CIRC
                CIRC: u1,
                ///  PINC
                PINC: u1,
                ///  MINC
                MINC: u1,
                ///  PSIZE
                PSIZE: u2,
                ///  MSIZE
                MSIZE: u2,
                ///  PINCOS
                PINCOS: u1,
                ///  PL
                PL: u2,
                ///  DBM
                DBM: u1,
                ///  CT
                CT: u1,
                reserved21: u1,
                ///  PBURST
                PBURST: u2,
                ///  MBURST
                MBURST: u2,
                padding: u7,
            }),
            ///  DMA stream 1 number of data register
            DMA_S1NDTR: mmio.Mmio(packed struct(u32) {
                ///  NDT
                NDT: u16,
                padding: u16,
            }),
            ///  DMA stream 1 peripheral address register
            DMA_S1PAR: mmio.Mmio(packed struct(u32) {
                ///  PAR
                PAR: u32,
            }),
            ///  DMA stream 1 memory 0 address register
            DMA_S1M0AR: mmio.Mmio(packed struct(u32) {
                ///  M0A
                M0A: u32,
            }),
            ///  DMA stream 1 memory 1 address register
            DMA_S1M1AR: mmio.Mmio(packed struct(u32) {
                ///  M1A
                M1A: u32,
            }),
            ///  DMA stream 1 FIFO control register
            DMA_S1FCR: mmio.Mmio(packed struct(u32) {
                ///  FTH
                FTH: u2,
                ///  DMDIS
                DMDIS: u1,
                ///  FS
                FS: u3,
                reserved7: u1,
                ///  FEIE
                FEIE: u1,
                padding: u24,
            }),
            ///  This register is used to configure the concerned stream.
            DMA_S2CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  DMEIE
                DMEIE: u1,
                ///  TEIE
                TEIE: u1,
                ///  HTIE
                HTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PFCTRL
                PFCTRL: u1,
                ///  DIR
                DIR: u2,
                ///  CIRC
                CIRC: u1,
                ///  PINC
                PINC: u1,
                ///  MINC
                MINC: u1,
                ///  PSIZE
                PSIZE: u2,
                ///  MSIZE
                MSIZE: u2,
                ///  PINCOS
                PINCOS: u1,
                ///  PL
                PL: u2,
                ///  DBM
                DBM: u1,
                ///  CT
                CT: u1,
                reserved21: u1,
                ///  PBURST
                PBURST: u2,
                ///  MBURST
                MBURST: u2,
                padding: u7,
            }),
            ///  DMA stream 2 number of data register
            DMA_S2NDTR: mmio.Mmio(packed struct(u32) {
                ///  NDT
                NDT: u16,
                padding: u16,
            }),
            ///  DMA stream 2 peripheral address register
            DMA_S2PAR: mmio.Mmio(packed struct(u32) {
                ///  PAR
                PAR: u32,
            }),
            ///  DMA stream 2 memory 0 address register
            DMA_S2M0AR: mmio.Mmio(packed struct(u32) {
                ///  M0A
                M0A: u32,
            }),
            ///  DMA stream 2 memory 1 address register
            DMA_S2M1AR: mmio.Mmio(packed struct(u32) {
                ///  M1A
                M1A: u32,
            }),
            ///  DMA stream 2 FIFO control register
            DMA_S2FCR: mmio.Mmio(packed struct(u32) {
                ///  FTH
                FTH: u2,
                ///  DMDIS
                DMDIS: u1,
                ///  FS
                FS: u3,
                reserved7: u1,
                ///  FEIE
                FEIE: u1,
                padding: u24,
            }),
            ///  This register is used to configure the concerned stream.
            DMA_S3CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  DMEIE
                DMEIE: u1,
                ///  TEIE
                TEIE: u1,
                ///  HTIE
                HTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PFCTRL
                PFCTRL: u1,
                ///  DIR
                DIR: u2,
                ///  CIRC
                CIRC: u1,
                ///  PINC
                PINC: u1,
                ///  MINC
                MINC: u1,
                ///  PSIZE
                PSIZE: u2,
                ///  MSIZE
                MSIZE: u2,
                ///  PINCOS
                PINCOS: u1,
                ///  PL
                PL: u2,
                ///  DBM
                DBM: u1,
                ///  CT
                CT: u1,
                reserved21: u1,
                ///  PBURST
                PBURST: u2,
                ///  MBURST
                MBURST: u2,
                padding: u7,
            }),
            ///  DMA stream 3 number of data register
            DMA_S3NDTR: mmio.Mmio(packed struct(u32) {
                ///  NDT
                NDT: u16,
                padding: u16,
            }),
            ///  DMA stream 3 peripheral address register
            DMA_S3PAR: mmio.Mmio(packed struct(u32) {
                ///  PAR
                PAR: u32,
            }),
            ///  DMA stream 3 memory 0 address register
            DMA_S3M0AR: mmio.Mmio(packed struct(u32) {
                ///  M0A
                M0A: u32,
            }),
            ///  DMA stream 3 memory 1 address register
            DMA_S3M1AR: mmio.Mmio(packed struct(u32) {
                ///  M1A
                M1A: u32,
            }),
            ///  DMA stream 3 FIFO control register
            DMA_S3FCR: mmio.Mmio(packed struct(u32) {
                ///  FTH
                FTH: u2,
                ///  DMDIS
                DMDIS: u1,
                ///  FS
                FS: u3,
                reserved7: u1,
                ///  FEIE
                FEIE: u1,
                padding: u24,
            }),
            ///  This register is used to configure the concerned stream.
            DMA_S4CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  DMEIE
                DMEIE: u1,
                ///  TEIE
                TEIE: u1,
                ///  HTIE
                HTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PFCTRL
                PFCTRL: u1,
                ///  DIR
                DIR: u2,
                ///  CIRC
                CIRC: u1,
                ///  PINC
                PINC: u1,
                ///  MINC
                MINC: u1,
                ///  PSIZE
                PSIZE: u2,
                ///  MSIZE
                MSIZE: u2,
                ///  PINCOS
                PINCOS: u1,
                ///  PL
                PL: u2,
                ///  DBM
                DBM: u1,
                ///  CT
                CT: u1,
                reserved21: u1,
                ///  PBURST
                PBURST: u2,
                ///  MBURST
                MBURST: u2,
                padding: u7,
            }),
            ///  DMA stream 4 number of data register
            DMA_S4NDTR: mmio.Mmio(packed struct(u32) {
                ///  NDT
                NDT: u16,
                padding: u16,
            }),
            ///  DMA stream 4 peripheral address register
            DMA_S4PAR: mmio.Mmio(packed struct(u32) {
                ///  PAR
                PAR: u32,
            }),
            ///  DMA stream 4 memory 0 address register
            DMA_S4M0AR: mmio.Mmio(packed struct(u32) {
                ///  M0A
                M0A: u32,
            }),
            ///  DMA stream 4 memory 1 address register
            DMA_S4M1AR: mmio.Mmio(packed struct(u32) {
                ///  M1A
                M1A: u32,
            }),
            ///  DMA stream 4 FIFO control register
            DMA_S4FCR: mmio.Mmio(packed struct(u32) {
                ///  FTH
                FTH: u2,
                ///  DMDIS
                DMDIS: u1,
                ///  FS
                FS: u3,
                reserved7: u1,
                ///  FEIE
                FEIE: u1,
                padding: u24,
            }),
            ///  This register is used to configure the concerned stream.
            DMA_S5CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  DMEIE
                DMEIE: u1,
                ///  TEIE
                TEIE: u1,
                ///  HTIE
                HTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PFCTRL
                PFCTRL: u1,
                ///  DIR
                DIR: u2,
                ///  CIRC
                CIRC: u1,
                ///  PINC
                PINC: u1,
                ///  MINC
                MINC: u1,
                ///  PSIZE
                PSIZE: u2,
                ///  MSIZE
                MSIZE: u2,
                ///  PINCOS
                PINCOS: u1,
                ///  PL
                PL: u2,
                ///  DBM
                DBM: u1,
                ///  CT
                CT: u1,
                reserved21: u1,
                ///  PBURST
                PBURST: u2,
                ///  MBURST
                MBURST: u2,
                padding: u7,
            }),
            ///  DMA stream 5 number of data register
            DMA_S5NDTR: mmio.Mmio(packed struct(u32) {
                ///  NDT
                NDT: u16,
                padding: u16,
            }),
            ///  DMA stream 5 peripheral address register
            DMA_S5PAR: mmio.Mmio(packed struct(u32) {
                ///  PAR
                PAR: u32,
            }),
            ///  DMA stream 5 memory 0 address register
            DMA_S5M0AR: mmio.Mmio(packed struct(u32) {
                ///  M0A
                M0A: u32,
            }),
            ///  DMA stream 5 memory 1 address register
            DMA_S5M1AR: mmio.Mmio(packed struct(u32) {
                ///  M1A
                M1A: u32,
            }),
            ///  DMA stream 5 FIFO control register
            DMA_S5FCR: mmio.Mmio(packed struct(u32) {
                ///  FTH
                FTH: u2,
                ///  DMDIS
                DMDIS: u1,
                ///  FS
                FS: u3,
                reserved7: u1,
                ///  FEIE
                FEIE: u1,
                padding: u24,
            }),
            ///  This register is used to configure the concerned stream.
            DMA_S6CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  DMEIE
                DMEIE: u1,
                ///  TEIE
                TEIE: u1,
                ///  HTIE
                HTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PFCTRL
                PFCTRL: u1,
                ///  DIR
                DIR: u2,
                ///  CIRC
                CIRC: u1,
                ///  PINC
                PINC: u1,
                ///  MINC
                MINC: u1,
                ///  PSIZE
                PSIZE: u2,
                ///  MSIZE
                MSIZE: u2,
                ///  PINCOS
                PINCOS: u1,
                ///  PL
                PL: u2,
                ///  DBM
                DBM: u1,
                ///  CT
                CT: u1,
                reserved21: u1,
                ///  PBURST
                PBURST: u2,
                ///  MBURST
                MBURST: u2,
                padding: u7,
            }),
            ///  DMA stream 6 number of data register
            DMA_S6NDTR: mmio.Mmio(packed struct(u32) {
                ///  NDT
                NDT: u16,
                padding: u16,
            }),
            ///  DMA stream 6 peripheral address register
            DMA_S6PAR: mmio.Mmio(packed struct(u32) {
                ///  PAR
                PAR: u32,
            }),
            ///  DMA stream 6 memory 0 address register
            DMA_S6M0AR: mmio.Mmio(packed struct(u32) {
                ///  M0A
                M0A: u32,
            }),
            ///  DMA stream 6 memory 1 address register
            DMA_S6M1AR: mmio.Mmio(packed struct(u32) {
                ///  M1A
                M1A: u32,
            }),
            ///  DMA stream 6 FIFO control register
            DMA_S6FCR: mmio.Mmio(packed struct(u32) {
                ///  FTH
                FTH: u2,
                ///  DMDIS
                DMDIS: u1,
                ///  FS
                FS: u3,
                reserved7: u1,
                ///  FEIE
                FEIE: u1,
                padding: u24,
            }),
            ///  This register is used to configure the concerned stream.
            DMA_S7CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  DMEIE
                DMEIE: u1,
                ///  TEIE
                TEIE: u1,
                ///  HTIE
                HTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PFCTRL
                PFCTRL: u1,
                ///  DIR
                DIR: u2,
                ///  CIRC
                CIRC: u1,
                ///  PINC
                PINC: u1,
                ///  MINC
                MINC: u1,
                ///  PSIZE
                PSIZE: u2,
                ///  MSIZE
                MSIZE: u2,
                ///  PINCOS
                PINCOS: u1,
                ///  PL
                PL: u2,
                ///  DBM
                DBM: u1,
                ///  CT
                CT: u1,
                reserved21: u1,
                ///  PBURST
                PBURST: u2,
                ///  MBURST
                MBURST: u2,
                padding: u7,
            }),
            ///  DMA stream 7 number of data register
            DMA_S7NDTR: mmio.Mmio(packed struct(u32) {
                ///  NDT
                NDT: u16,
                padding: u16,
            }),
            ///  DMA stream 7 peripheral address register
            DMA_S7PAR: mmio.Mmio(packed struct(u32) {
                ///  PAR
                PAR: u32,
            }),
            ///  DMA stream 7 memory 0 address register
            DMA_S7M0AR: mmio.Mmio(packed struct(u32) {
                ///  M0A
                M0A: u32,
            }),
            ///  DMA stream 7 memory 1 address register
            DMA_S7M1AR: mmio.Mmio(packed struct(u32) {
                ///  M1A
                M1A: u32,
            }),
            ///  DMA stream 7 FIFO control register
            DMA_S7FCR: mmio.Mmio(packed struct(u32) {
                ///  FTH
                FTH: u2,
                ///  DMDIS
                DMDIS: u1,
                ///  FS
                FS: u3,
                reserved7: u1,
                ///  FEIE
                FEIE: u1,
                padding: u24,
            }),
            reserved1004: [796]u8,
            ///  DMA hardware configuration 2register
            DMA_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  FIFO_SIZE
                FIFO_SIZE: u2,
                reserved4: u2,
                ///  WRITE_BUFFERABLE
                WRITE_BUFFERABLE: u1,
                reserved8: u3,
                ///  CHSEL_WIDTH
                CHSEL_WIDTH: u3,
                padding: u21,
            }),
            ///  DMA hardware configuration 1 register
            DMA_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  DMA_DEF0
                DMA_DEF0: u2,
                reserved4: u2,
                ///  DMA_DEF1
                DMA_DEF1: u2,
                reserved8: u2,
                ///  DMA_DEF2
                DMA_DEF2: u2,
                reserved12: u2,
                ///  DMA_DEF3
                DMA_DEF3: u2,
                reserved16: u2,
                ///  DMA_DEF4
                DMA_DEF4: u2,
                reserved20: u2,
                ///  DMA_DEF5
                DMA_DEF5: u2,
                reserved24: u2,
                ///  DMA_DEF6
                DMA_DEF6: u2,
                reserved28: u2,
                ///  DMA_DEF7
                DMA_DEF7: u2,
                padding: u2,
            }),
            ///  This register identifies the version of the IP.
            DMA_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  DMA IP identification register
            DMA_IPDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  DMA size identification register
            DMA_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  TIM3
        pub const TIM3 = extern struct {
            ///  TIM3 control register 1
            TIM3_CR1: mmio.Mmio(packed struct(u16) {
                ///  CEN
                CEN: u1,
                ///  UDIS
                UDIS: u1,
                ///  URS
                URS: u1,
                ///  OPM
                OPM: u1,
                ///  DIR
                DIR: u1,
                ///  CMS
                CMS: u2,
                ///  ARPE
                ARPE: u1,
                ///  CKD
                CKD: u2,
                reserved11: u1,
                ///  UIFREMAP
                UIFREMAP: u1,
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM3 control register 2
            TIM3_CR2: mmio.Mmio(packed struct(u32) {
                ///  CCPC
                CCPC: u1,
                reserved2: u1,
                ///  CCUS
                CCUS: u1,
                ///  CCDS
                CCDS: u1,
                ///  MMS
                MMS: u3,
                ///  TI1S
                TI1S: u1,
                ///  OIS1
                OIS1: u1,
                ///  OIS1N
                OIS1N: u1,
                ///  OIS2
                OIS2: u1,
                ///  OIS2N
                OIS2N: u1,
                ///  OIS3
                OIS3: u1,
                ///  OIS3N
                OIS3N: u1,
                ///  OIS4
                OIS4: u1,
                reserved16: u1,
                ///  OIS5
                OIS5: u1,
                reserved18: u1,
                ///  OIS6
                OIS6: u1,
                reserved20: u1,
                ///  MMS2
                MMS2: u4,
                padding: u8,
            }),
            ///  TIM3 slave mode control register
            TIM3_SMCR: mmio.Mmio(packed struct(u32) {
                ///  SMS
                SMS: u3,
                reserved4: u1,
                ///  TS
                TS: u3,
                ///  MSM
                MSM: u1,
                ///  ETF
                ETF: u4,
                ///  ETPS
                ETPS: u2,
                ///  ECE
                ECE: u1,
                ///  ETP
                ETP: u1,
                ///  SMS3
                SMS3: u1,
                reserved20: u3,
                ///  TS3
                TS3: u1,
                ///  TS4
                TS4: u1,
                padding: u10,
            }),
            ///  TIM3 DMA/interrupt enable register
            TIM3_DIER: mmio.Mmio(packed struct(u16) {
                ///  UIE
                UIE: u1,
                ///  CC1IE
                CC1IE: u1,
                ///  CC2IE
                CC2IE: u1,
                ///  CC3IE
                CC3IE: u1,
                ///  CC4IE
                CC4IE: u1,
                ///  COMIE
                COMIE: u1,
                ///  TIE
                TIE: u1,
                ///  BIE
                BIE: u1,
                ///  UDE
                UDE: u1,
                ///  CC1DE
                CC1DE: u1,
                ///  CC2DE
                CC2DE: u1,
                ///  CC3DE
                CC3DE: u1,
                ///  CC4DE
                CC4DE: u1,
                ///  COMDE
                COMDE: u1,
                ///  TDE
                TDE: u1,
                padding: u1,
            }),
            reserved16: [2]u8,
            ///  TIM3 status register
            TIM3_SR: mmio.Mmio(packed struct(u32) {
                ///  UIF
                UIF: u1,
                ///  CC1IF
                CC1IF: u1,
                ///  CC2IF
                CC2IF: u1,
                ///  CC3IF
                CC3IF: u1,
                ///  CC4IF
                CC4IF: u1,
                ///  COMIF
                COMIF: u1,
                ///  TIF
                TIF: u1,
                ///  BIF
                BIF: u1,
                ///  B2IF
                B2IF: u1,
                ///  CC1OF
                CC1OF: u1,
                ///  CC2OF
                CC2OF: u1,
                ///  CC3OF
                CC3OF: u1,
                ///  CC4OF
                CC4OF: u1,
                ///  SBIF
                SBIF: u1,
                reserved16: u2,
                ///  CC5IF
                CC5IF: u1,
                ///  CC6IF
                CC6IF: u1,
                padding: u14,
            }),
            ///  TIM3 event generation register
            TIM3_EGR: mmio.Mmio(packed struct(u16) {
                ///  UG
                UG: u1,
                ///  CC1G
                CC1G: u1,
                ///  CC2G
                CC2G: u1,
                ///  CC3G
                CC3G: u1,
                ///  CC4G
                CC4G: u1,
                ///  COMG
                COMG: u1,
                ///  TG
                TG: u1,
                ///  BG
                BG: u1,
                ///  B2G
                B2G: u1,
                padding: u7,
            }),
            reserved24: [2]u8,
            ///  The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
            TIM3_CCMR1ALTERNATE3: mmio.Mmio(packed struct(u32) {
                ///  CC1S
                CC1S: u2,
                ///  IC1PSC
                IC1PSC: u2,
                ///  IC1F
                IC1F: u4,
                ///  CC2S
                CC2S: u2,
                ///  IC2PSC
                IC2PSC: u2,
                ///  IC2F
                IC2F: u4,
                padding: u16,
            }),
            ///  The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
            TIM3_CCMR2ALTERNATE19: mmio.Mmio(packed struct(u32) {
                ///  CC3S
                CC3S: u2,
                ///  IC3PSC
                IC3PSC: u2,
                ///  IC3F
                IC3F: u4,
                ///  CC4S
                CC4S: u2,
                ///  IC4PSC
                IC4PSC: u2,
                ///  IC4F
                IC4F: u4,
                padding: u16,
            }),
            ///  TIM3 capture/compare enable register
            TIM3_CCER: mmio.Mmio(packed struct(u32) {
                ///  CC1E
                CC1E: u1,
                ///  CC1P
                CC1P: u1,
                ///  CC1NE
                CC1NE: u1,
                ///  CC1NP
                CC1NP: u1,
                ///  CC2E
                CC2E: u1,
                ///  CC2P
                CC2P: u1,
                ///  CC2NE
                CC2NE: u1,
                ///  CC2NP
                CC2NP: u1,
                ///  CC3E
                CC3E: u1,
                ///  CC3P
                CC3P: u1,
                ///  CC3NE
                CC3NE: u1,
                ///  CC3NP
                CC3NP: u1,
                ///  CC4E
                CC4E: u1,
                ///  CC4P
                CC4P: u1,
                reserved15: u1,
                ///  CC4NP
                CC4NP: u1,
                ///  CC5E
                CC5E: u1,
                ///  CC5P
                CC5P: u1,
                reserved20: u2,
                ///  CC6E
                CC6E: u1,
                ///  CC6P
                CC6P: u1,
                padding: u10,
            }),
            ///  TIM3 counter
            TIM3_CNT: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u16,
                reserved31: u15,
                ///  UIFCPY
                UIFCPY: u1,
            }),
            ///  TIM3 prescaler
            TIM3_PSC: mmio.Mmio(packed struct(u16) {
                ///  PSC
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM3 auto-reload register
            TIM3_ARR: mmio.Mmio(packed struct(u16) {
                ///  ARR
                ARR: u16,
            }),
            reserved48: [2]u8,
            ///  TIM3 repetition counter register
            TIM3_RCR: mmio.Mmio(packed struct(u16) {
                ///  REP
                REP: u16,
            }),
            reserved52: [2]u8,
            ///  TIM3 capture/compare register 1
            TIM3_CCR1: mmio.Mmio(packed struct(u16) {
                ///  CCR1
                CCR1: u16,
            }),
            reserved56: [2]u8,
            ///  TIM3 capture/compare register 2
            TIM3_CCR2: mmio.Mmio(packed struct(u16) {
                ///  CCR2
                CCR2: u16,
            }),
            reserved60: [2]u8,
            ///  TIM3 capture/compare register 3
            TIM3_CCR3: mmio.Mmio(packed struct(u16) {
                ///  CCR3
                CCR3: u16,
            }),
            reserved64: [2]u8,
            ///  TIM3 capture/compare register 4
            TIM3_CCR4: mmio.Mmio(packed struct(u16) {
                ///  CCR4
                CCR4: u16,
            }),
            reserved68: [2]u8,
            ///  As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
            TIM3_BDTR: mmio.Mmio(packed struct(u32) {
                ///  DTG
                DTG: u8,
                ///  LOCK
                LOCK: u2,
                ///  OSSI
                OSSI: u1,
                ///  OSSR
                OSSR: u1,
                ///  BKE
                BKE: u1,
                ///  BKP
                BKP: u1,
                ///  AOE
                AOE: u1,
                ///  MOE
                MOE: u1,
                ///  BKF
                BKF: u4,
                ///  BK2F
                BK2F: u4,
                ///  BK2E
                BK2E: u1,
                ///  BK2P
                BK2P: u1,
                ///  BKDSRM
                BKDSRM: u1,
                ///  BK2DSRM
                BK2DSRM: u1,
                ///  BKBID
                BKBID: u1,
                ///  BK2BID
                BK2BID: u1,
                padding: u2,
            }),
            ///  TIM3 DMA control register
            TIM3_DCR: mmio.Mmio(packed struct(u16) {
                ///  DBA
                DBA: u5,
                reserved8: u3,
                ///  DBL
                DBL: u5,
                padding: u3,
            }),
            reserved76: [2]u8,
            ///  TIM3 DMA address for full transfer
            TIM3_DMAR: mmio.Mmio(packed struct(u32) {
                ///  DMAB
                DMAB: u32,
            }),
            reserved84: [4]u8,
            ///  The channels 5 and 6 can only be configured in output. Output compare mode:
            TIM3_CCMR3: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  OC5FE
                OC5FE: u1,
                ///  OC5PE
                OC5PE: u1,
                ///  OC5M
                OC5M: u3,
                ///  OC5CE
                OC5CE: u1,
                reserved10: u2,
                ///  OC6FE
                OC6FE: u1,
                ///  OC6PE
                OC6PE: u1,
                ///  OC6M
                OC6M: u3,
                ///  OC6CE
                OC6CE: u1,
                ///  OC5M3
                OC5M3: u1,
                reserved24: u7,
                ///  OC6M3
                OC6M3: u1,
                padding: u7,
            }),
            ///  TIM3 capture/compare register 5
            TIM3_CCR5: mmio.Mmio(packed struct(u32) {
                ///  CCR5
                CCR5: u16,
                reserved29: u13,
                ///  GC5C1
                GC5C1: u1,
                ///  GC5C2
                GC5C2: u1,
                ///  GC5C3
                GC5C3: u1,
            }),
            ///  TIM3 capture/compare register 6
            TIM3_CCR6: mmio.Mmio(packed struct(u16) {
                ///  CCR6
                CCR6: u16,
            }),
        };

        ///  DMAMUX1
        pub const DMAMUX1 = extern struct {
            ///  DMAMUX request line multiplexer channel 0 configuration register
            DMAMUX_C0CR: mmio.Mmio(packed struct(u32) {
                ///  DMAREQ_ID
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  SOIE
                SOIE: u1,
                ///  EGE
                EGE: u1,
                reserved16: u6,
                ///  SE
                SE: u1,
                ///  SPOL
                SPOL: u2,
                ///  NBREQ
                NBREQ: u5,
                ///  SYNC_ID
                SYNC_ID: u3,
                padding: u5,
            }),
            ///  DMAMUX request line multiplexer channel 1 configuration register
            DMAMUX_C1CR: mmio.Mmio(packed struct(u32) {
                ///  DMAREQ_ID
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  SOIE
                SOIE: u1,
                ///  EGE
                EGE: u1,
                reserved16: u6,
                ///  SE
                SE: u1,
                ///  SPOL
                SPOL: u2,
                ///  NBREQ
                NBREQ: u5,
                ///  SYNC_ID
                SYNC_ID: u3,
                padding: u5,
            }),
            ///  DMAMUX request line multiplexer channel 2 configuration register
            DMAMUX_C2CR: mmio.Mmio(packed struct(u32) {
                ///  DMAREQ_ID
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  SOIE
                SOIE: u1,
                ///  EGE
                EGE: u1,
                reserved16: u6,
                ///  SE
                SE: u1,
                ///  SPOL
                SPOL: u2,
                ///  NBREQ
                NBREQ: u5,
                ///  SYNC_ID
                SYNC_ID: u3,
                padding: u5,
            }),
            ///  DMAMUX request line multiplexer channel 3 configuration register
            DMAMUX_C3CR: mmio.Mmio(packed struct(u32) {
                ///  DMAREQ_ID
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  SOIE
                SOIE: u1,
                ///  EGE
                EGE: u1,
                reserved16: u6,
                ///  SE
                SE: u1,
                ///  SPOL
                SPOL: u2,
                ///  NBREQ
                NBREQ: u5,
                ///  SYNC_ID
                SYNC_ID: u3,
                padding: u5,
            }),
            ///  DMAMUX request line multiplexer channel 4 configuration register
            DMAMUX_C4CR: mmio.Mmio(packed struct(u32) {
                ///  DMAREQ_ID
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  SOIE
                SOIE: u1,
                ///  EGE
                EGE: u1,
                reserved16: u6,
                ///  SE
                SE: u1,
                ///  SPOL
                SPOL: u2,
                ///  NBREQ
                NBREQ: u5,
                ///  SYNC_ID
                SYNC_ID: u3,
                padding: u5,
            }),
            ///  DMAMUX request line multiplexer channel 5 configuration register
            DMAMUX_C5CR: mmio.Mmio(packed struct(u32) {
                ///  DMAREQ_ID
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  SOIE
                SOIE: u1,
                ///  EGE
                EGE: u1,
                reserved16: u6,
                ///  SE
                SE: u1,
                ///  SPOL
                SPOL: u2,
                ///  NBREQ
                NBREQ: u5,
                ///  SYNC_ID
                SYNC_ID: u3,
                padding: u5,
            }),
            ///  DMAMUX request line multiplexer channel 6 configuration register
            DMAMUX_C6CR: mmio.Mmio(packed struct(u32) {
                ///  DMAREQ_ID
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  SOIE
                SOIE: u1,
                ///  EGE
                EGE: u1,
                reserved16: u6,
                ///  SE
                SE: u1,
                ///  SPOL
                SPOL: u2,
                ///  NBREQ
                NBREQ: u5,
                ///  SYNC_ID
                SYNC_ID: u3,
                padding: u5,
            }),
            ///  DMAMUX request line multiplexer channel 7 configuration register
            DMAMUX_C7CR: mmio.Mmio(packed struct(u32) {
                ///  DMAREQ_ID
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  SOIE
                SOIE: u1,
                ///  EGE
                EGE: u1,
                reserved16: u6,
                ///  SE
                SE: u1,
                ///  SPOL
                SPOL: u2,
                ///  NBREQ
                NBREQ: u5,
                ///  SYNC_ID
                SYNC_ID: u3,
                padding: u5,
            }),
            ///  DMAMUX request line multiplexer channel 8 configuration register
            DMAMUX_C8CR: mmio.Mmio(packed struct(u32) {
                ///  DMAREQ_ID
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  SOIE
                SOIE: u1,
                ///  EGE
                EGE: u1,
                reserved16: u6,
                ///  SE
                SE: u1,
                ///  SPOL
                SPOL: u2,
                ///  NBREQ
                NBREQ: u5,
                ///  SYNC_ID
                SYNC_ID: u3,
                padding: u5,
            }),
            ///  DMAMUX request line multiplexer channel 9 configuration register
            DMAMUX_C9CR: mmio.Mmio(packed struct(u32) {
                ///  DMAREQ_ID
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  SOIE
                SOIE: u1,
                ///  EGE
                EGE: u1,
                reserved16: u6,
                ///  SE
                SE: u1,
                ///  SPOL
                SPOL: u2,
                ///  NBREQ
                NBREQ: u5,
                ///  SYNC_ID
                SYNC_ID: u3,
                padding: u5,
            }),
            ///  DMAMUX request line multiplexer channel 10 configuration register
            DMAMUX_C10CR: mmio.Mmio(packed struct(u32) {
                ///  DMAREQ_ID
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  SOIE
                SOIE: u1,
                ///  EGE
                EGE: u1,
                reserved16: u6,
                ///  SE
                SE: u1,
                ///  SPOL
                SPOL: u2,
                ///  NBREQ
                NBREQ: u5,
                ///  SYNC_ID
                SYNC_ID: u3,
                padding: u5,
            }),
            ///  DMAMUX request line multiplexer channel 11 configuration register
            DMAMUX_C11CR: mmio.Mmio(packed struct(u32) {
                ///  DMAREQ_ID
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  SOIE
                SOIE: u1,
                ///  EGE
                EGE: u1,
                reserved16: u6,
                ///  SE
                SE: u1,
                ///  SPOL
                SPOL: u2,
                ///  NBREQ
                NBREQ: u5,
                ///  SYNC_ID
                SYNC_ID: u3,
                padding: u5,
            }),
            ///  DMAMUX request line multiplexer channel 12 configuration register
            DMAMUX_C12CR: mmio.Mmio(packed struct(u32) {
                ///  DMAREQ_ID
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  SOIE
                SOIE: u1,
                ///  EGE
                EGE: u1,
                reserved16: u6,
                ///  SE
                SE: u1,
                ///  SPOL
                SPOL: u2,
                ///  NBREQ
                NBREQ: u5,
                ///  SYNC_ID
                SYNC_ID: u3,
                padding: u5,
            }),
            ///  DMAMUX request line multiplexer channel 13 configuration register
            DMAMUX_C13CR: mmio.Mmio(packed struct(u32) {
                ///  DMAREQ_ID
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  SOIE
                SOIE: u1,
                ///  EGE
                EGE: u1,
                reserved16: u6,
                ///  SE
                SE: u1,
                ///  SPOL
                SPOL: u2,
                ///  NBREQ
                NBREQ: u5,
                ///  SYNC_ID
                SYNC_ID: u3,
                padding: u5,
            }),
            ///  DMAMUX request line multiplexer channel 14 configuration register
            DMAMUX_C14CR: mmio.Mmio(packed struct(u32) {
                ///  DMAREQ_ID
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  SOIE
                SOIE: u1,
                ///  EGE
                EGE: u1,
                reserved16: u6,
                ///  SE
                SE: u1,
                ///  SPOL
                SPOL: u2,
                ///  NBREQ
                NBREQ: u5,
                ///  SYNC_ID
                SYNC_ID: u3,
                padding: u5,
            }),
            ///  DMAMUX request line multiplexer channel 15 configuration register
            DMAMUX_C15CR: mmio.Mmio(packed struct(u32) {
                ///  DMAREQ_ID
                DMAREQ_ID: u7,
                reserved8: u1,
                ///  SOIE
                SOIE: u1,
                ///  EGE
                EGE: u1,
                reserved16: u6,
                ///  SE
                SE: u1,
                ///  SPOL
                SPOL: u2,
                ///  NBREQ
                NBREQ: u5,
                ///  SYNC_ID
                SYNC_ID: u3,
                padding: u5,
            }),
            reserved128: [64]u8,
            ///  DMAMUX request line multiplexer interrupt channel status register
            DMAMUX_CSR: mmio.Mmio(packed struct(u32) {
                ///  SOF0
                SOF0: u1,
                ///  SOF1
                SOF1: u1,
                ///  SOF2
                SOF2: u1,
                ///  SOF3
                SOF3: u1,
                ///  SOF4
                SOF4: u1,
                ///  SOF5
                SOF5: u1,
                ///  SOF6
                SOF6: u1,
                ///  SOF7
                SOF7: u1,
                ///  SOF8
                SOF8: u1,
                ///  SOF9
                SOF9: u1,
                ///  SOF10
                SOF10: u1,
                ///  SOF11
                SOF11: u1,
                ///  SOF12
                SOF12: u1,
                ///  SOF13
                SOF13: u1,
                ///  SOF14
                SOF14: u1,
                ///  SOF15
                SOF15: u1,
                padding: u16,
            }),
            ///  DMAMUX request line multiplexer interrupt clear flag register
            DMAMUX_CFR: mmio.Mmio(packed struct(u32) {
                ///  CSOF0
                CSOF0: u1,
                ///  CSOF1
                CSOF1: u1,
                ///  CSOF2
                CSOF2: u1,
                ///  CSOF3
                CSOF3: u1,
                ///  CSOF4
                CSOF4: u1,
                ///  CSOF5
                CSOF5: u1,
                ///  CSOF6
                CSOF6: u1,
                ///  CSOF7
                CSOF7: u1,
                ///  CSOF8
                CSOF8: u1,
                ///  CSOF9
                CSOF9: u1,
                ///  CSOF10
                CSOF10: u1,
                ///  CSOF11
                CSOF11: u1,
                ///  CSOF12
                CSOF12: u1,
                ///  CSOF13
                CSOF13: u1,
                ///  CSOF14
                CSOF14: u1,
                ///  CSOF15
                CSOF15: u1,
                padding: u16,
            }),
            reserved256: [120]u8,
            ///  DMAMUX request generator channel 0 configuration register
            DMAMUX_RG0CR: mmio.Mmio(packed struct(u32) {
                ///  SIG_ID
                SIG_ID: u3,
                reserved8: u5,
                ///  OIE
                OIE: u1,
                reserved16: u7,
                ///  GE
                GE: u1,
                ///  GPOL
                GPOL: u2,
                ///  GNBREQ
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMUX request generator channel 1 configuration register
            DMAMUX_RG1CR: mmio.Mmio(packed struct(u32) {
                ///  SIG_ID
                SIG_ID: u3,
                reserved8: u5,
                ///  OIE
                OIE: u1,
                reserved16: u7,
                ///  GE
                GE: u1,
                ///  GPOL
                GPOL: u2,
                ///  GNBREQ
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMUX request generator channel 2 configuration register
            DMAMUX_RG2CR: mmio.Mmio(packed struct(u32) {
                ///  SIG_ID
                SIG_ID: u3,
                reserved8: u5,
                ///  OIE
                OIE: u1,
                reserved16: u7,
                ///  GE
                GE: u1,
                ///  GPOL
                GPOL: u2,
                ///  GNBREQ
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMUX request generator channel 3 configuration register
            DMAMUX_RG3CR: mmio.Mmio(packed struct(u32) {
                ///  SIG_ID
                SIG_ID: u3,
                reserved8: u5,
                ///  OIE
                OIE: u1,
                reserved16: u7,
                ///  GE
                GE: u1,
                ///  GPOL
                GPOL: u2,
                ///  GNBREQ
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMUX request generator channel 4 configuration register
            DMAMUX_RG4CR: mmio.Mmio(packed struct(u32) {
                ///  SIG_ID
                SIG_ID: u3,
                reserved8: u5,
                ///  OIE
                OIE: u1,
                reserved16: u7,
                ///  GE
                GE: u1,
                ///  GPOL
                GPOL: u2,
                ///  GNBREQ
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMUX request generator channel 5 configuration register
            DMAMUX_RG5CR: mmio.Mmio(packed struct(u32) {
                ///  SIG_ID
                SIG_ID: u3,
                reserved8: u5,
                ///  OIE
                OIE: u1,
                reserved16: u7,
                ///  GE
                GE: u1,
                ///  GPOL
                GPOL: u2,
                ///  GNBREQ
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMUX request generator channel 6 configuration register
            DMAMUX_RG6CR: mmio.Mmio(packed struct(u32) {
                ///  SIG_ID
                SIG_ID: u3,
                reserved8: u5,
                ///  OIE
                OIE: u1,
                reserved16: u7,
                ///  GE
                GE: u1,
                ///  GPOL
                GPOL: u2,
                ///  GNBREQ
                GNBREQ: u5,
                padding: u8,
            }),
            ///  DMAMUX request generator channel 7 configuration register
            DMAMUX_RG7CR: mmio.Mmio(packed struct(u32) {
                ///  SIG_ID
                SIG_ID: u3,
                reserved8: u5,
                ///  OIE
                OIE: u1,
                reserved16: u7,
                ///  GE
                GE: u1,
                ///  GPOL
                GPOL: u2,
                ///  GNBREQ
                GNBREQ: u5,
                padding: u8,
            }),
            reserved320: [32]u8,
            ///  DMAMUX request generator interrupt status register
            DMAMUX_RGSR: mmio.Mmio(packed struct(u32) {
                ///  OF0
                OF0: u1,
                ///  OF1
                OF1: u1,
                ///  OF2
                OF2: u1,
                ///  OF3
                OF3: u1,
                ///  OF4
                OF4: u1,
                ///  OF5
                OF5: u1,
                ///  OF6
                OF6: u1,
                ///  OF7
                OF7: u1,
                padding: u24,
            }),
            ///  DMAMUX request generator interrupt clear flag register
            DMAMUX_RGCFR: mmio.Mmio(packed struct(u32) {
                ///  COF0
                COF0: u1,
                ///  COF1
                COF1: u1,
                ///  COF2
                COF2: u1,
                ///  COF3
                COF3: u1,
                ///  COF4
                COF4: u1,
                ///  COF5
                COF5: u1,
                ///  COF6
                COF6: u1,
                ///  COF7
                COF7: u1,
                padding: u24,
            }),
            reserved1004: [676]u8,
            ///  DMAMUX hardware configuration 2 register
            DMAMUX_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  NUM_DMA_EXT_REQ
                NUM_DMA_EXT_REQ: u8,
                padding: u24,
            }),
            ///  DMAMUX hardware configuration 1 register
            DMAMUX_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  NUM_DMA_STREAMS
                NUM_DMA_STREAMS: u8,
                ///  NUM_DMA_PERIPH_REQ
                NUM_DMA_PERIPH_REQ: u8,
                ///  NUM_DMA_TRIG
                NUM_DMA_TRIG: u8,
                ///  NUM_DMA_REQGEN
                NUM_DMA_REQGEN: u8,
            }),
            ///  This register identifies the IP version.
            DMAMUX_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  This register identifies the IP.
            DMAMUX_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  DMAMUX size identification register
            DMAMUX_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  DSIHOST1
        pub const DSIHOST1 = extern struct {
            ///  DSI Host version register
            DSI_VR: mmio.Mmio(packed struct(u32) {
                ///  VERSION
                VERSION: u32,
            }),
            ///  DSI Host control register
            DSI_CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                padding: u31,
            }),
            ///  DSI Host clock control register
            DSI_CCR: mmio.Mmio(packed struct(u32) {
                ///  TXECKDIV
                TXECKDIV: u8,
                ///  TOCKDIV
                TOCKDIV: u8,
                padding: u16,
            }),
            ///  DSI Host LTDC VCID register
            DSI_LVCIDR: mmio.Mmio(packed struct(u32) {
                ///  VCID
                VCID: u2,
                padding: u30,
            }),
            ///  DSI Host LTDC color coding register
            DSI_LCOLCR: mmio.Mmio(packed struct(u32) {
                ///  COLC
                COLC: u4,
                reserved8: u4,
                ///  LPE
                LPE: u1,
                padding: u23,
            }),
            ///  DSI Host LTDC polarity configuration register
            DSI_LPCR: mmio.Mmio(packed struct(u32) {
                ///  DEP
                DEP: u1,
                ///  VSP
                VSP: u1,
                ///  HSP
                HSP: u1,
                padding: u29,
            }),
            ///  DSI Host low-power mode configuration register
            DSI_LPMCR: mmio.Mmio(packed struct(u32) {
                ///  VLPSIZE
                VLPSIZE: u8,
                reserved16: u8,
                ///  LPSIZE
                LPSIZE: u8,
                padding: u8,
            }),
            reserved44: [16]u8,
            ///  DSI Host protocol configuration register
            DSI_PCR: mmio.Mmio(packed struct(u32) {
                ///  ETTXE
                ETTXE: u1,
                ///  ETRXE
                ETRXE: u1,
                ///  BTAE
                BTAE: u1,
                ///  ECCRXE
                ECCRXE: u1,
                ///  CRCRXE
                CRCRXE: u1,
                padding: u27,
            }),
            ///  DSI Host generic VCID register
            DSI_GVCIDR: mmio.Mmio(packed struct(u32) {
                ///  VCID
                VCID: u2,
                padding: u30,
            }),
            ///  DSI Host mode configuration register
            DSI_MCR: mmio.Mmio(packed struct(u32) {
                ///  CMDM
                CMDM: u1,
                padding: u31,
            }),
            ///  DSI Host video mode configuration register
            DSI_VMCR: mmio.Mmio(packed struct(u32) {
                ///  VMT
                VMT: u2,
                reserved8: u6,
                ///  LPVSAE
                LPVSAE: u1,
                ///  LPVBPE
                LPVBPE: u1,
                ///  LPVFPE
                LPVFPE: u1,
                ///  LPVAE
                LPVAE: u1,
                ///  LPHBPE
                LPHBPE: u1,
                ///  LPHFPE
                LPHFPE: u1,
                ///  FBTAAE
                FBTAAE: u1,
                ///  LPCE
                LPCE: u1,
                ///  PGE
                PGE: u1,
                reserved20: u3,
                ///  PGM
                PGM: u1,
                reserved24: u3,
                ///  PGO
                PGO: u1,
                padding: u7,
            }),
            ///  DSI Host video packet configuration register
            DSI_VPCR: mmio.Mmio(packed struct(u32) {
                ///  VPSIZE
                VPSIZE: u14,
                padding: u18,
            }),
            ///  DSI Host video chunks configuration register
            DSI_VCCR: mmio.Mmio(packed struct(u32) {
                ///  NUMC
                NUMC: u13,
                padding: u19,
            }),
            ///  DSI Host video null packet configuration register
            DSI_VNPCR: mmio.Mmio(packed struct(u32) {
                ///  NPSIZE
                NPSIZE: u13,
                padding: u19,
            }),
            ///  DSI Host video HSA configuration register
            DSI_VHSACR: mmio.Mmio(packed struct(u32) {
                ///  HSA
                HSA: u12,
                padding: u20,
            }),
            ///  DSI Host video HBP configuration register
            DSI_VHBPCR: mmio.Mmio(packed struct(u32) {
                ///  HBP
                HBP: u12,
                padding: u20,
            }),
            ///  DSI Host video line configuration register
            DSI_VLCR: mmio.Mmio(packed struct(u32) {
                ///  HLINE
                HLINE: u15,
                padding: u17,
            }),
            ///  DSI Host video VSA configuration register
            DSI_VVSACR: mmio.Mmio(packed struct(u32) {
                ///  VSA
                VSA: u10,
                padding: u22,
            }),
            ///  DSI Host video VBP configuration register
            DSI_VVBPCR: mmio.Mmio(packed struct(u32) {
                ///  VBP
                VBP: u10,
                padding: u22,
            }),
            ///  DSI Host video VFP configuration register
            DSI_VVFPCR: mmio.Mmio(packed struct(u32) {
                ///  VFP
                VFP: u10,
                padding: u22,
            }),
            ///  DSI Host video VA configuration register
            DSI_VVACR: mmio.Mmio(packed struct(u32) {
                ///  VA
                VA: u14,
                padding: u18,
            }),
            ///  DSI Host LTDC command configuration register
            DSI_LCCR: mmio.Mmio(packed struct(u32) {
                ///  CMDSIZE
                CMDSIZE: u16,
                padding: u16,
            }),
            ///  DSI Host command mode configuration register
            DSI_CMCR: mmio.Mmio(packed struct(u32) {
                ///  TEARE
                TEARE: u1,
                ///  ARE
                ARE: u1,
                reserved8: u6,
                ///  GSW0TX
                GSW0TX: u1,
                ///  GSW1TX
                GSW1TX: u1,
                ///  GSW2TX
                GSW2TX: u1,
                ///  GSR0TX
                GSR0TX: u1,
                ///  GSR1TX
                GSR1TX: u1,
                ///  GSR2TX
                GSR2TX: u1,
                ///  GLWTX
                GLWTX: u1,
                reserved16: u1,
                ///  DSW0TX
                DSW0TX: u1,
                ///  DSW1TX
                DSW1TX: u1,
                ///  DSR0TX
                DSR0TX: u1,
                ///  DLWTX
                DLWTX: u1,
                reserved24: u4,
                ///  MRDPS
                MRDPS: u1,
                padding: u7,
            }),
            ///  DSI Host generic header configuration register
            DSI_GHCR: mmio.Mmio(packed struct(u32) {
                ///  DT
                DT: u6,
                ///  VCID
                VCID: u2,
                ///  WCLSB
                WCLSB: u8,
                ///  WCMSB
                WCMSB: u8,
                padding: u8,
            }),
            ///  DSI Host generic payload data register
            DSI_GPDR: mmio.Mmio(packed struct(u32) {
                ///  DATA1
                DATA1: u8,
                ///  DATA2
                DATA2: u8,
                ///  DATA3
                DATA3: u8,
                ///  DATA4
                DATA4: u8,
            }),
            ///  DSI Host generic packet status register
            DSI_GPSR: mmio.Mmio(packed struct(u32) {
                ///  CMDFE
                CMDFE: u1,
                ///  CMDFF
                CMDFF: u1,
                ///  PWRFE
                PWRFE: u1,
                ///  PWRFF
                PWRFF: u1,
                ///  PRDFE
                PRDFE: u1,
                ///  PRDFF
                PRDFF: u1,
                ///  RCB
                RCB: u1,
                padding: u25,
            }),
            ///  DSI Host timeout counter configuration register 0
            DSI_TCCR0: mmio.Mmio(packed struct(u32) {
                ///  LPRX_TOCNT
                LPRX_TOCNT: u16,
                ///  HSTX_TOCNT
                HSTX_TOCNT: u16,
            }),
            ///  DSI Host timeout counter configuration register 1
            DSI_TCCR1: mmio.Mmio(packed struct(u32) {
                ///  HSRD_TOCNT
                HSRD_TOCNT: u16,
                padding: u16,
            }),
            ///  DSI Host timeout counter configuration register 2
            DSI_TCCR2: mmio.Mmio(packed struct(u32) {
                ///  LPRD_TOCNT
                LPRD_TOCNT: u16,
                padding: u16,
            }),
            ///  DSI Host timeout counter configuration register 3
            DSI_TCCR3: mmio.Mmio(packed struct(u32) {
                ///  HSWR_TOCNT
                HSWR_TOCNT: u16,
                reserved24: u8,
                ///  PM
                PM: u1,
                padding: u7,
            }),
            ///  DSI Host timeout counter configuration register 4
            DSI_TCCR4: mmio.Mmio(packed struct(u32) {
                ///  LPWR_TOCNT
                LPWR_TOCNT: u16,
                padding: u16,
            }),
            ///  DSI Host timeout counter configuration register 5
            DSI_TCCR5: mmio.Mmio(packed struct(u32) {
                ///  BTA_TOCNT
                BTA_TOCNT: u16,
                padding: u16,
            }),
            reserved148: [4]u8,
            ///  DSI Host clock lane configuration register
            DSI_CLCR: mmio.Mmio(packed struct(u32) {
                ///  DPCC
                DPCC: u1,
                ///  ACR
                ACR: u1,
                padding: u30,
            }),
            ///  DSI Host clock lane timer configuration register
            DSI_CLTCR: mmio.Mmio(packed struct(u32) {
                ///  LP2HS_TIME
                LP2HS_TIME: u10,
                reserved16: u6,
                ///  HS2LP_TIME
                HS2LP_TIME: u10,
                padding: u6,
            }),
            ///  DSI Host data lane timer configuration register
            DSI_DLTCR: mmio.Mmio(packed struct(u32) {
                ///  LP2HS_TIME
                LP2HS_TIME: u10,
                reserved16: u6,
                ///  HS2LP_TIME
                HS2LP_TIME: u10,
                padding: u6,
            }),
            ///  DSI Host PHY control register
            DSI_PCTLR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  DEN
                DEN: u1,
                ///  CKE
                CKE: u1,
                padding: u29,
            }),
            ///  DSI Host PHY configuration register
            DSI_PCONFR: mmio.Mmio(packed struct(u32) {
                ///  NL
                NL: u2,
                reserved8: u6,
                ///  SW_TIME
                SW_TIME: u8,
                padding: u16,
            }),
            ///  DSI Host PHY ULPS control register
            DSI_PUCR: mmio.Mmio(packed struct(u32) {
                ///  URCL
                URCL: u1,
                ///  UECL
                UECL: u1,
                ///  URDL
                URDL: u1,
                ///  UEDL
                UEDL: u1,
                padding: u28,
            }),
            ///  DSI Host PHY TX triggers configuration register
            DSI_PTTCR: mmio.Mmio(packed struct(u32) {
                ///  TX_TRIG
                TX_TRIG: u4,
                padding: u28,
            }),
            ///  DSI Host PHY status register
            DSI_PSR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  PD
                PD: u1,
                ///  PSSC
                PSSC: u1,
                ///  UANC
                UANC: u1,
                ///  PSS0
                PSS0: u1,
                ///  UAN0
                UAN0: u1,
                ///  RUE0
                RUE0: u1,
                ///  PSS1
                PSS1: u1,
                ///  UAN1
                UAN1: u1,
                padding: u23,
            }),
            reserved188: [8]u8,
            ///  DSI Host interrupt and status register 0
            DSI_ISR0: mmio.Mmio(packed struct(u32) {
                ///  AE0
                AE0: u1,
                ///  AE1
                AE1: u1,
                ///  AE2
                AE2: u1,
                ///  AE3
                AE3: u1,
                ///  AE4
                AE4: u1,
                ///  AE5
                AE5: u1,
                ///  AE6
                AE6: u1,
                ///  AE7
                AE7: u1,
                ///  AE8
                AE8: u1,
                ///  AE9
                AE9: u1,
                ///  AE10
                AE10: u1,
                ///  AE11
                AE11: u1,
                ///  AE12
                AE12: u1,
                ///  AE13
                AE13: u1,
                ///  AE14
                AE14: u1,
                ///  AE15
                AE15: u1,
                ///  PE0
                PE0: u1,
                ///  PE1
                PE1: u1,
                ///  PE2
                PE2: u1,
                ///  PE3
                PE3: u1,
                ///  PE4
                PE4: u1,
                padding: u11,
            }),
            ///  DSI Host interrupt and status register 1
            DSI_ISR1: mmio.Mmio(packed struct(u32) {
                ///  TOHSTX
                TOHSTX: u1,
                ///  TOLPRX
                TOLPRX: u1,
                ///  ECCSE
                ECCSE: u1,
                ///  ECCME
                ECCME: u1,
                ///  CRCE
                CRCE: u1,
                ///  PSE
                PSE: u1,
                ///  EOTPE
                EOTPE: u1,
                ///  LPWRE
                LPWRE: u1,
                ///  GCWRE
                GCWRE: u1,
                ///  GPWRE
                GPWRE: u1,
                ///  GPTXE
                GPTXE: u1,
                ///  GPRDE
                GPRDE: u1,
                ///  GPRXE
                GPRXE: u1,
                padding: u19,
            }),
            ///  DSI Host interrupt enable register 0
            DSI_IER0: mmio.Mmio(packed struct(u32) {
                ///  AE0IE
                AE0IE: u1,
                ///  AE1IE
                AE1IE: u1,
                ///  AE2IE
                AE2IE: u1,
                ///  AE3IE
                AE3IE: u1,
                ///  AE4IE
                AE4IE: u1,
                ///  AE5IE
                AE5IE: u1,
                ///  AE6IE
                AE6IE: u1,
                ///  AE7IE
                AE7IE: u1,
                ///  AE8IE
                AE8IE: u1,
                ///  AE9IE
                AE9IE: u1,
                ///  AE10IE
                AE10IE: u1,
                ///  AE11IE
                AE11IE: u1,
                ///  AE12IE
                AE12IE: u1,
                ///  AE13IE
                AE13IE: u1,
                ///  AE14IE
                AE14IE: u1,
                ///  AE15IE
                AE15IE: u1,
                ///  PE0IE
                PE0IE: u1,
                ///  PE1IE
                PE1IE: u1,
                ///  PE2IE
                PE2IE: u1,
                ///  PE3IE
                PE3IE: u1,
                ///  PE4IE
                PE4IE: u1,
                padding: u11,
            }),
            ///  DSI Host interrupt enable register 1
            DSI_IER1: mmio.Mmio(packed struct(u32) {
                ///  TOHSTXIE
                TOHSTXIE: u1,
                ///  TOLPRXIE
                TOLPRXIE: u1,
                ///  ECCSEIE
                ECCSEIE: u1,
                ///  ECCMEIE
                ECCMEIE: u1,
                ///  CRCEIE
                CRCEIE: u1,
                ///  PSEIE
                PSEIE: u1,
                ///  EOTPEIE
                EOTPEIE: u1,
                ///  LPWREIE
                LPWREIE: u1,
                ///  GCWREIE
                GCWREIE: u1,
                ///  GPWREIE
                GPWREIE: u1,
                ///  GPTXEIE
                GPTXEIE: u1,
                ///  GPRDEIE
                GPRDEIE: u1,
                ///  GPRXEIE
                GPRXEIE: u1,
                padding: u19,
            }),
            reserved216: [12]u8,
            ///  DSI Host force interrupt register 0
            DSI_FIR0: mmio.Mmio(packed struct(u32) {
                ///  FAE0
                FAE0: u1,
                ///  FAE1
                FAE1: u1,
                ///  FAE2
                FAE2: u1,
                ///  FAE3
                FAE3: u1,
                ///  FAE4
                FAE4: u1,
                ///  FAE5
                FAE5: u1,
                ///  FAE6
                FAE6: u1,
                ///  FAE7
                FAE7: u1,
                ///  FAE8
                FAE8: u1,
                ///  FAE9
                FAE9: u1,
                ///  FAE10
                FAE10: u1,
                ///  FAE11
                FAE11: u1,
                ///  FAE12
                FAE12: u1,
                ///  FAE13
                FAE13: u1,
                ///  FAE14
                FAE14: u1,
                ///  FAE15
                FAE15: u1,
                ///  FPE0
                FPE0: u1,
                ///  FPE1
                FPE1: u1,
                ///  FPE2
                FPE2: u1,
                ///  FPE3
                FPE3: u1,
                ///  FPE4
                FPE4: u1,
                padding: u11,
            }),
            ///  DSI Host force interrupt register 1
            DSI_FIR1: mmio.Mmio(packed struct(u32) {
                ///  FTOHSTX
                FTOHSTX: u1,
                ///  FTOLPRX
                FTOLPRX: u1,
                ///  FECCSE
                FECCSE: u1,
                ///  FECCME
                FECCME: u1,
                ///  FCRCE
                FCRCE: u1,
                ///  FPSE
                FPSE: u1,
                ///  FEOTPE
                FEOTPE: u1,
                ///  FLPWRE
                FLPWRE: u1,
                ///  FGCWRE
                FGCWRE: u1,
                ///  FGPWRE
                FGPWRE: u1,
                ///  FGPTXE
                FGPTXE: u1,
                ///  FGPRDE
                FGPRDE: u1,
                ///  FGPRXE
                FGPRXE: u1,
                padding: u19,
            }),
            reserved244: [20]u8,
            ///  DSI Host data lane timer read configuration register
            DSI_DLTRCR: mmio.Mmio(packed struct(u32) {
                ///  MRD_TIME
                MRD_TIME: u15,
                padding: u17,
            }),
            reserved256: [8]u8,
            ///  DSI Host video shadow control register
            DSI_VSCR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                reserved8: u7,
                ///  UR
                UR: u1,
                padding: u23,
            }),
            reserved268: [8]u8,
            ///  DSI Host LTDC current VCID register
            DSI_LCVCIDR: mmio.Mmio(packed struct(u32) {
                ///  VCID
                VCID: u2,
                padding: u30,
            }),
            ///  DSI Host LTDC current color coding register
            DSI_LCCCR: mmio.Mmio(packed struct(u32) {
                ///  COLC
                COLC: u4,
                reserved8: u4,
                ///  LPE
                LPE: u1,
                padding: u23,
            }),
            reserved280: [4]u8,
            ///  DSI Host low-power mode current configuration register
            DSI_LPMCCR: mmio.Mmio(packed struct(u32) {
                ///  VLPSIZE
                VLPSIZE: u8,
                reserved16: u8,
                ///  LPSIZE
                LPSIZE: u8,
                padding: u8,
            }),
            reserved312: [28]u8,
            ///  DSI Host video mode current configuration register
            DSI_VMCCR: mmio.Mmio(packed struct(u32) {
                ///  VMT
                VMT: u2,
                ///  LPVSAE
                LPVSAE: u1,
                ///  LPVBPE
                LPVBPE: u1,
                ///  LPVFPE
                LPVFPE: u1,
                ///  LPVAE
                LPVAE: u1,
                ///  LPHBPE
                LPHBPE: u1,
                ///  LPHFE
                LPHFE: u1,
                ///  FBTAAE
                FBTAAE: u1,
                ///  LPCE
                LPCE: u1,
                padding: u22,
            }),
            ///  DSI Host video packet current configuration register
            DSI_VPCCR: mmio.Mmio(packed struct(u32) {
                ///  VPSIZE
                VPSIZE: u14,
                padding: u18,
            }),
            ///  DSI Host video chunks current configuration register
            DSI_VCCCR: mmio.Mmio(packed struct(u32) {
                ///  NUMC
                NUMC: u13,
                padding: u19,
            }),
            ///  DSI Host video null packet current configuration register
            DSI_VNPCCR: mmio.Mmio(packed struct(u32) {
                ///  NPSIZE
                NPSIZE: u13,
                padding: u19,
            }),
            ///  DSI Host video HSA current configuration register
            DSI_VHSACCR: mmio.Mmio(packed struct(u32) {
                ///  HSA
                HSA: u12,
                padding: u20,
            }),
            ///  DSI Host video HBP current configuration register
            DSI_VHBPCCR: mmio.Mmio(packed struct(u32) {
                ///  HBP
                HBP: u12,
                padding: u20,
            }),
            ///  DSI Host video line current configuration register
            DSI_VLCCR: mmio.Mmio(packed struct(u32) {
                ///  HLINE
                HLINE: u15,
                padding: u17,
            }),
            ///  DSI Host video VSA current configuration register
            DSI_VVSACCR: mmio.Mmio(packed struct(u32) {
                ///  VSA
                VSA: u10,
                padding: u22,
            }),
            ///  DSI Host video VBP current configuration register
            DSI_VVBPCCR: mmio.Mmio(packed struct(u32) {
                ///  VBP
                VBP: u10,
                padding: u22,
            }),
            ///  DSI Host video VFP current configuration register
            DSI_VVFPCCR: mmio.Mmio(packed struct(u32) {
                ///  VFP
                VFP: u10,
                padding: u22,
            }),
            ///  DSI Host video VA current configuration register
            DSI_VVACCR: mmio.Mmio(packed struct(u32) {
                ///  VA
                VA: u14,
                padding: u18,
            }),
            reserved1024: [668]u8,
            ///  DSI wrapper configuration register
            DSI_WCFGR: mmio.Mmio(packed struct(u32) {
                ///  DSIM
                DSIM: u1,
                ///  COLMUX
                COLMUX: u3,
                ///  TESRC
                TESRC: u1,
                ///  TEPOL
                TEPOL: u1,
                ///  AR
                AR: u1,
                ///  VSPOL
                VSPOL: u1,
                padding: u24,
            }),
            ///  DSI wrapper control register
            DSI_WCR: mmio.Mmio(packed struct(u32) {
                ///  COLM
                COLM: u1,
                ///  SHTDN
                SHTDN: u1,
                ///  LTDCEN
                LTDCEN: u1,
                ///  DSIEN
                DSIEN: u1,
                padding: u28,
            }),
            ///  DSI wrapper interrupt enable register
            DSI_WIER: mmio.Mmio(packed struct(u32) {
                ///  TEIE
                TEIE: u1,
                ///  ERIE
                ERIE: u1,
                reserved9: u7,
                ///  PLLLIE
                PLLLIE: u1,
                ///  PLLUIE
                PLLUIE: u1,
                reserved13: u2,
                ///  RRIE
                RRIE: u1,
                padding: u18,
            }),
            ///  DSI wrapper interrupt and status register
            DSI_WISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  ERIF
                ERIF: u1,
                ///  BUSY
                BUSY: u1,
                reserved8: u5,
                ///  PLLLS
                PLLLS: u1,
                ///  PLLLIF
                PLLLIF: u1,
                ///  PLLUIF
                PLLUIF: u1,
                reserved12: u1,
                ///  RRS
                RRS: u1,
                ///  RRIF
                RRIF: u1,
                padding: u18,
            }),
            ///  DSI wrapper interrupt flag clear register
            DSI_WIFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CERIF
                CERIF: u1,
                reserved9: u7,
                ///  CPLLLIF
                CPLLLIF: u1,
                ///  CPLLUIF
                CPLLUIF: u1,
                reserved13: u2,
                ///  CRRIF
                CRRIF: u1,
                padding: u18,
            }),
            reserved1048: [4]u8,
            ///  DSI wrapper PHY configuration register 0
            DSI_WPCR0: mmio.Mmio(packed struct(u32) {
                ///  UIX4
                UIX4: u6,
                ///  SWCL
                SWCL: u1,
                ///  SWDL0
                SWDL0: u1,
                ///  SWDL1
                SWDL1: u1,
                ///  HSICL
                HSICL: u1,
                ///  HSIDL0
                HSIDL0: u1,
                ///  HSIDL1
                HSIDL1: u1,
                ///  FTXSMCL
                FTXSMCL: u1,
                ///  FTXSMDL
                FTXSMDL: u1,
                ///  CDOFFDL
                CDOFFDL: u1,
                reserved16: u1,
                ///  TDDL
                TDDL: u1,
                padding: u15,
            }),
            ///  This register shall be programmed only when DSI is stopped (CR. DSIEN=0 and CR.EN = 0).
            DSI_WPCR1: mmio.Mmio(packed struct(u32) {
                ///  SKEWCL
                SKEWCL: u2,
                ///  SKEWDL
                SKEWDL: u2,
                reserved6: u2,
                ///  LPTXSRCL
                LPTXSRCL: u2,
                ///  LPTXSRDL
                LPTXSRDL: u2,
                reserved12: u2,
                ///  SDDCCL
                SDDCCL: u1,
                ///  SDDCDL
                SDDCDL: u1,
                reserved16: u2,
                ///  HSTXSRUCL
                HSTXSRUCL: u1,
                ///  HSTXSRDCL
                HSTXSRDCL: u1,
                ///  HSTXSRUDL
                HSTXSRUDL: u1,
                ///  HSTXSRDDL
                HSTXSRDDL: u1,
                padding: u12,
            }),
            reserved1072: [16]u8,
            ///  DSI wrapper regulator and PLL control register
            DSI_WRPCR: mmio.Mmio(packed struct(u32) {
                ///  PLLEN
                PLLEN: u1,
                reserved2: u1,
                ///  NDIV
                NDIV: u7,
                reserved11: u2,
                ///  IDF
                IDF: u4,
                reserved16: u1,
                ///  ODF
                ODF: u2,
                reserved24: u6,
                ///  REGEN
                REGEN: u1,
                reserved28: u3,
                ///  BGREN
                BGREN: u1,
                padding: u3,
            }),
            reserved2032: [956]u8,
            ///  DSI Host hardware configuration register
            DSI_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  TECHNO
                TECHNO: u4,
                ///  FIFOSIZE
                FIFOSIZE: u12,
                padding: u16,
            }),
            ///  DSI Host version register
            DSI_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  DSI Host identification register
            DSI_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  DSI Host size identification register
            DSI_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  DTS register block
        pub const DTS = extern struct {
            ///  DTS_CFGR1 is the configuration register for temperature sensor 1.
            DTS_CFGR1: mmio.Mmio(packed struct(u32) {
                ///  TS1_EN
                TS1_EN: u1,
                reserved4: u3,
                ///  TS1_START
                TS1_START: u1,
                reserved8: u3,
                ///  TS1_INTRIG_SEL
                TS1_INTRIG_SEL: u4,
                reserved16: u4,
                ///  TS1_SMP_TIME
                TS1_SMP_TIME: u4,
                ///  REFCLK_SEL
                REFCLK_SEL: u1,
                ///  Q_MEAS_opt
                Q_MEAS_opt: u1,
                reserved24: u2,
                ///  HSREF_CLK_DIV
                HSREF_CLK_DIV: u7,
                padding: u1,
            }),
            reserved8: [4]u8,
            ///  DTS_T0VALR1 contains the value of the factory calibration temperature (T0) for temperature sensor 1. The system reset value is factory trimmed.
            DTS_T0VALR1: mmio.Mmio(packed struct(u32) {
                ///  TS1_FMT0
                TS1_FMT0: u16,
                ///  TS1_T0
                TS1_T0: u2,
                padding: u14,
            }),
            reserved16: [4]u8,
            ///  The DTS_RAMPVALR is the ramp coefficient for the temperature sensor. The system reset value is factory trimmed.
            DTS_RAMPVALR: mmio.Mmio(packed struct(u32) {
                ///  TS1_RAMP_COEFF
                TS1_RAMP_COEFF: u16,
                padding: u16,
            }),
            ///  DTS_ITR1 contains the threshold values for sensor 1.
            DTS_ITR1: mmio.Mmio(packed struct(u32) {
                ///  TS1_LITTHD
                TS1_LITTHD: u16,
                ///  TS1_HITTHD
                TS1_HITTHD: u16,
            }),
            reserved28: [4]u8,
            ///  The DTS_DR contains the number of REF_CLK cycles used to compute the FM(T) frequency.
            DTS_DR: mmio.Mmio(packed struct(u32) {
                ///  TS1_MFREQ
                TS1_MFREQ: u16,
                padding: u16,
            }),
            ///  Temperature sensor status register
            DTS_SR: mmio.Mmio(packed struct(u32) {
                ///  TS1_ITEF
                TS1_ITEF: u1,
                ///  TS1_ITLF
                TS1_ITLF: u1,
                ///  TS1_ITHF
                TS1_ITHF: u1,
                reserved4: u1,
                ///  TS1_AITEF
                TS1_AITEF: u1,
                ///  TS1_AITLF
                TS1_AITLF: u1,
                ///  TS1_AITHF
                TS1_AITHF: u1,
                reserved15: u8,
                ///  TS1_RDY
                TS1_RDY: u1,
                padding: u16,
            }),
            ///  Temperature sensor interrupt enable register
            DTS_ITENR: mmio.Mmio(packed struct(u32) {
                ///  TS1_ITEEN
                TS1_ITEEN: u1,
                ///  TS1_ITLEN
                TS1_ITLEN: u1,
                ///  TS1_ITHEN
                TS1_ITHEN: u1,
                reserved4: u1,
                ///  TS1_AITEEN
                TS1_AITEEN: u1,
                ///  TS1_AITLEN
                TS1_AITLEN: u1,
                ///  TS1_AITHEN
                TS1_AITHEN: u1,
                padding: u25,
            }),
            ///  DTS_ICIFR is the control register for the interrupt flags.
            DTS_ICIFR: mmio.Mmio(packed struct(u32) {
                ///  TS1_CITEF
                TS1_CITEF: u1,
                ///  TS1_CITLF
                TS1_CITLF: u1,
                ///  TS1_CITHF
                TS1_CITHF: u1,
                reserved4: u1,
                ///  TS1_CAITEF
                TS1_CAITEF: u1,
                ///  TS1_CAITLF
                TS1_CAITLF: u1,
                ///  TS1_CAITHF
                TS1_CAITHF: u1,
                padding: u25,
            }),
            ///  The DTS_OR contains general-purpose option bits.
            DTS_OR: mmio.Mmio(packed struct(u32) {
                ///  TS_Op0
                TS_Op0: u1,
                ///  TS_Op1
                TS_Op1: u1,
                ///  TS_Op2
                TS_Op2: u1,
                ///  TS_Op3
                TS_Op3: u1,
                ///  TS_Op4
                TS_Op4: u1,
                ///  TS_Op5
                TS_Op5: u1,
                ///  TS_Op6
                TS_Op6: u1,
                ///  TS_Op7
                TS_Op7: u1,
                ///  TS_Op8
                TS_Op8: u1,
                ///  TS_Op9
                TS_Op9: u1,
                ///  TS_Op10
                TS_Op10: u1,
                ///  TS_Op11
                TS_Op11: u1,
                ///  TS_Op12
                TS_Op12: u1,
                ///  TS_Op13
                TS_Op13: u1,
                ///  TS_Op14
                TS_Op14: u1,
                ///  TS_Op15
                TS_Op15: u1,
                ///  TS_Op16
                TS_Op16: u1,
                ///  TS_Op17
                TS_Op17: u1,
                ///  TS_Op18
                TS_Op18: u1,
                ///  TS_Op19
                TS_Op19: u1,
                ///  TS_Op20
                TS_Op20: u1,
                ///  TS_Op21
                TS_Op21: u1,
                ///  TS_Op22
                TS_Op22: u1,
                ///  TS_Op23
                TS_Op23: u1,
                ///  TS_Op24
                TS_Op24: u1,
                ///  TS_Op25
                TS_Op25: u1,
                ///  TS_Op26
                TS_Op26: u1,
                ///  TS_Op27
                TS_Op27: u1,
                ///  TS_Op28
                TS_Op28: u1,
                ///  TS_Op29
                TS_Op29: u1,
                ///  TS_Op30
                TS_Op30: u1,
                ///  TS_Op31
                TS_Op31: u1,
            }),
        };

        ///  ETH_MAC_MMC
        pub const ETH_MAC_MMC = extern struct {
            ///  The MAC Configuration Register establishes the operating mode of the MAC.
            ETH_MACCR: mmio.Mmio(packed struct(u32) {
                ///  RE
                RE: u1,
                ///  TE
                TE: u1,
                ///  PRELEN
                PRELEN: u2,
                ///  DC
                DC: u1,
                ///  BL
                BL: u2,
                reserved8: u1,
                ///  DR
                DR: u1,
                ///  DCRS
                DCRS: u1,
                ///  DO
                DO: u1,
                ///  ECRSFD
                ECRSFD: u1,
                ///  LM
                LM: u1,
                ///  DM
                DM: u1,
                ///  FES
                FES: u1,
                ///  PS
                PS: u1,
                ///  JE
                JE: u1,
                ///  JD
                JD: u1,
                ///  BE
                BE: u1,
                ///  WD
                WD: u1,
                ///  ACS
                ACS: u1,
                ///  CST
                CST: u1,
                ///  S2KP
                S2KP: u1,
                ///  GPSLCE
                GPSLCE: u1,
                ///  IPG
                IPG: u3,
                ///  IPC
                IPC: u1,
                ///  SARC
                SARC: u3,
                ///  ARPEN
                ARPEN: u1,
            }),
            ///  The MAC Extended Configuration Register establishes the operating mode of the MAC.
            ETH_MACECR: mmio.Mmio(packed struct(u32) {
                ///  GPSL
                GPSL: u14,
                reserved16: u2,
                ///  DCRCC
                DCRCC: u1,
                ///  SPEN
                SPEN: u1,
                ///  USP
                USP: u1,
                reserved24: u5,
                ///  EIPGEN
                EIPGEN: u1,
                ///  EIPG
                EIPG: u5,
                padding: u2,
            }),
            ///  The MAC Packet Filter register contains the filter controls for receiving packets. Some of the controls from this register go to the address check block of the MAC which performs the first level of address filtering. The second level of filtering is performed on the incoming packet based on other controls such as Pass Bad Packets and Pass Control Packets.
            ETH_MACPFR: mmio.Mmio(packed struct(u32) {
                ///  PR
                PR: u1,
                ///  HUC
                HUC: u1,
                ///  HMC
                HMC: u1,
                ///  DAIF
                DAIF: u1,
                ///  PM
                PM: u1,
                ///  DBF
                DBF: u1,
                ///  PCF
                PCF: u2,
                ///  SAIF
                SAIF: u1,
                ///  SAF
                SAF: u1,
                ///  HPF
                HPF: u1,
                reserved16: u5,
                ///  VTFE
                VTFE: u1,
                reserved20: u3,
                ///  IPFE
                IPFE: u1,
                ///  DNTU
                DNTU: u1,
                reserved31: u9,
                ///  RA
                RA: u1,
            }),
            ///  The Watchdog Timeout register controls the watchdog timeout for received packets.
            ETH_MACWTR: mmio.Mmio(packed struct(u32) {
                ///  WTO
                WTO: u4,
                reserved8: u4,
                ///  PWE
                PWE: u1,
                padding: u23,
            }),
            ///  The Hash Table Register 0 contains the first 32 bits of the Hash table (64 bits). For Hash filtering, the content of the destination address in the incoming packet is passed through the CRC logic and the upper six bits of the CRC register are used to index the content of the Hash table. The most significant bits determines the register to be used (Hash Table Register 0 or 1). The Hash value of the destination address is calculated in the following way: Calculate the 32-bit CRC for the DA (See IEEE 802.3, Section 3.2.8 for the steps to calculate CRC32). Perform bitwise reversal for the value obtained in Step 1. Take the upper 7 or 8 bits from the value obtained in Step 2. If the corresponding bit value of the register is 1, the packet is accepted. Otherwise, it is rejected. If the PM bit is set in ETH_MACPFR, all multicast packets are accepted regardless of the multicast Hash values. If the Hash Table register is configured to be double-synchronized to the GMII clock domain, the synchronization is triggered only when Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the Hash Table Register X registers are written.
            ETH_MACHT0R: mmio.Mmio(packed struct(u32) {
                ///  HT31T0
                HT31T0: u32,
            }),
            ///  The Hash Table Register 1contains the last 32 bits of the Hash table (64 bits). For Hash filtering, the content of the destination address in the incoming packet is passed through the CRC logic and the upper six bits of the CRC register are used to index the content of the Hash table. The most significant bits determines the register to be used (Hash Table Register 0 or 1). The Hash value of the destination address is calculated in the following way: Calculate the 32-bit CRC for the DA (See IEEE 802.3, Section 3.2.8 for the steps to calculate CRC32). Perform bitwise reversal for the value obtained in Step 1. Take the upper 7 or 8 bits from the value obtained in Step 2. If the corresponding bit value of the register is 1, the packet is accepted. Otherwise, it is rejected. If the PM bit is set in ETH_MACPFR, all multicast packets are accepted regardless of the multicast Hash values. If the Hash Table register is configured to be double-synchronized to the GMII clock domain, the synchronization is triggered only when Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the Hash Table Register X registers are written.
            ETH_MACHT1R: mmio.Mmio(packed struct(u32) {
                ///  HT63T32
                HT63T32: u32,
            }),
            reserved80: [56]u8,
            ///  The VLAN Tag register identifies the IEEE 802.1Q VLAN type packets.
            ETH_MACVTR: mmio.Mmio(packed struct(u32) {
                ///  VL
                VL: u16,
                ///  ETV
                ETV: u1,
                ///  VTIM
                VTIM: u1,
                ///  ESVL
                ESVL: u1,
                ///  ERSVLM
                ERSVLM: u1,
                ///  DOVLTC
                DOVLTC: u1,
                ///  EVLS
                EVLS: u2,
                reserved24: u1,
                ///  EVLRXS
                EVLRXS: u1,
                ///  VTHM
                VTHM: u1,
                ///  EDVLP
                EDVLP: u1,
                ///  ERIVLT
                ERIVLT: u1,
                ///  EIVLS
                EIVLS: u2,
                reserved31: u1,
                ///  EIVLRXS
                EIVLRXS: u1,
            }),
            reserved88: [4]u8,
            ///  When the ERSVLM bit of ETH_MACHT1R register is set, the 16-bit VLAN Hash Table register is used for group address filtering based on the VLAN tag. For Hash filtering, the content of the 16-bit VLAN tag or 12-bit VLAN ID (based on the ETV bit of ETH_MACVTR register) in the incoming packet is passed through the CRC logic. The upper four bits of the calculated CRC are used to index the contents of the VLAN Hash table. For example, a Hash value of 1000 selects Bit 8 of the VLAN Hash table. The Hash value of the destination address is calculated in the following way: Calculate the 32-bit CRC for the VLAN tag or ID (For steps to calculate CRC32, see Section 3.2.8 of IEEE 802.3). Perform bitwise reversal for the value obtained in step 1. Take the upper four bits from the value obtained in step 2. If the VLAN Hash Table register is configured to be double-synchronized to the GMII clock domain, the synchronization is triggered only when Bits[15:8] (in little-endian mode) or Bits[7:0] (in big-endian mode) of this register are written.
            ETH_MACVHTR: mmio.Mmio(packed struct(u32) {
                ///  VLHT
                VLHT: u16,
                padding: u16,
            }),
            reserved96: [4]u8,
            ///  The VLAN Tag Inclusion or Replacement register contains the VLAN tag for insertion or replacement in the Transmit packets. It also contains the VLAN tag insertion controls.
            ETH_MACVIR: mmio.Mmio(packed struct(u32) {
                ///  VLT
                VLT: u16,
                ///  VLC
                VLC: u2,
                ///  VLP
                VLP: u1,
                ///  CSVL
                CSVL: u1,
                ///  VLTI
                VLTI: u1,
                padding: u11,
            }),
            ///  The Inner VLAN Tag Inclusion or Replacement register contains the inner VLAN tag to be inserted or replaced in the Transmit packet. It also contains the inner VLAN tag insertion controls.
            ETH_MACIVIR: mmio.Mmio(packed struct(u32) {
                ///  VLT
                VLT: u16,
                ///  VLC
                VLC: u2,
                ///  VLP
                VLP: u1,
                ///  CSVL
                CSVL: u1,
                ///  VLTI
                VLTI: u1,
                padding: u11,
            }),
            reserved112: [8]u8,
            ///  The Flow Control register controls the generation and reception of the Control (Pause Command) packets by the Flow control module of the MAC. A Write to a register with the Busy bit set to 1 triggers the Flow Control block to generate a Pause packet. The fields of the control packet are selected as specified in the 802.3x specification, and the Pause Time value from this register is used in the Pause Time field of the control packet. The Busy bit remains set until the control packet is transferred onto the cable. The application must make sure that the Busy bit is cleared before writing to the register.
            ETH_MACQ0TxFCR: mmio.Mmio(packed struct(u32) {
                ///  FCB_BPA
                FCB_BPA: u1,
                ///  TFE
                TFE: u1,
                reserved4: u2,
                ///  PLT
                PLT: u3,
                ///  DZPQ
                DZPQ: u1,
                reserved16: u8,
                ///  PT
                PT: u16,
            }),
            reserved144: [28]u8,
            ///  The Receive Flow Control register controls the pausing of MAC Transmit based on the received Pause packet.
            ETH_MACRxFCR: mmio.Mmio(packed struct(u32) {
                ///  RFE
                RFE: u1,
                ///  UP
                UP: u1,
                padding: u30,
            }),
            reserved152: [4]u8,
            ///  The transmit queue priority mapping 0 register contains the priority values assigned to Tx queue 0 and tx queue 1.
            ETH_MACTxQPMR: mmio.Mmio(packed struct(u32) {
                ///  PSTQ0
                PSTQ0: u8,
                ///  PSTQ1
                PSTQ1: u8,
                padding: u16,
            }),
            reserved160: [4]u8,
            ///  The Receive Queue Control 0 register controls the queue management in the MAC Receiver.
            ETH_MACRxQC0R: mmio.Mmio(packed struct(u32) {
                ///  RXQ0EN
                RXQ0EN: u2,
                ///  RXQ1EN
                RXQ1EN: u2,
                padding: u28,
            }),
            ///  The Receive Queue Control 1 register controls queue 1 management in the MAC receiver.
            ETH_MACRxQC1R: mmio.Mmio(packed struct(u32) {
                ///  AVCPQ
                AVCPQ: u3,
                reserved4: u1,
                ///  AVPTPQ
                AVPTPQ: u3,
                reserved12: u5,
                ///  UPQ
                UPQ: u3,
                reserved16: u1,
                ///  MCBCQ
                MCBCQ: u3,
                reserved20: u1,
                ///  MCBCQEN
                MCBCQEN: u1,
                ///  TACPQE
                TACPQE: u1,
                padding: u10,
            }),
            ///  This register controls the routing of tagged packets based on the USP (user priority) field of the received packets to the Rx queue 0 and 1.
            ETH_MACRxQC2R: mmio.Mmio(packed struct(u32) {
                ///  PSRQ0
                PSRQ0: u8,
                ///  PSRQ1
                PSRQ1: u8,
                padding: u16,
            }),
            reserved176: [4]u8,
            ///  The Interrupt Status register contains the status of interrupts.
            ETH_MACISR: mmio.Mmio(packed struct(u32) {
                ///  RGSMIIIS
                RGSMIIIS: u1,
                reserved3: u2,
                ///  PHYIS
                PHYIS: u1,
                ///  PMTIS
                PMTIS: u1,
                ///  LPIIS
                LPIIS: u1,
                reserved8: u2,
                ///  MMCIS
                MMCIS: u1,
                ///  MMCRXIS
                MMCRXIS: u1,
                ///  MMCTXIS
                MMCTXIS: u1,
                reserved12: u1,
                ///  TSIS
                TSIS: u1,
                ///  TXSTSIS
                TXSTSIS: u1,
                ///  RXSTSIS
                RXSTSIS: u1,
                padding: u17,
            }),
            ///  The Interrupt Enable register contains the masks for generating the interrupts.
            ETH_MACIER: mmio.Mmio(packed struct(u32) {
                ///  RGSMIIIE
                RGSMIIIE: u1,
                reserved3: u2,
                ///  PHYIE
                PHYIE: u1,
                ///  PMTIE
                PMTIE: u1,
                ///  LPIIE
                LPIIE: u1,
                reserved12: u6,
                ///  TSIE
                TSIE: u1,
                ///  TXSTSIE
                TXSTSIE: u1,
                ///  RXSTSIE
                RXSTSIE: u1,
                padding: u17,
            }),
            ///  The Receive Transmit Status register contains the Receive and Transmit Error status.
            ETH_MACRxTxSR: mmio.Mmio(packed struct(u32) {
                ///  TJT
                TJT: u1,
                ///  NCARR
                NCARR: u1,
                ///  LCARR
                LCARR: u1,
                ///  EXDEF
                EXDEF: u1,
                ///  LCOL
                LCOL: u1,
                ///  EXCOL
                EXCOL: u1,
                reserved8: u2,
                ///  RWT
                RWT: u1,
                padding: u23,
            }),
            reserved192: [4]u8,
            ///  The PMT Control and Status Register is present only when you select the PMT module in coreConsultant.
            ETH_MACPCSR: mmio.Mmio(packed struct(u32) {
                ///  PWRDWN
                PWRDWN: u1,
                ///  MGKPKTEN
                MGKPKTEN: u1,
                ///  RWKPKTEN
                RWKPKTEN: u1,
                reserved5: u2,
                ///  MGKPRCVD
                MGKPRCVD: u1,
                ///  RWKPRCVD
                RWKPRCVD: u1,
                reserved9: u2,
                ///  GLBLUCAST
                GLBLUCAST: u1,
                ///  RWKPFE
                RWKPFE: u1,
                reserved24: u13,
                ///  RWKPTR
                RWKPTR: u5,
                reserved31: u2,
                ///  RWKFILTRST
                RWKFILTRST: u1,
            }),
            ///  The LPI Control and Status Register controls the LPI functions and provides the LPI interrupt status. The status bits are cleared when this register is read.
            ETH_MACRWKPFR: mmio.Mmio(packed struct(u32) {
                ///  TLPIEN
                TLPIEN: u1,
                ///  TLPIEX
                TLPIEX: u1,
                ///  RLPIEN
                RLPIEN: u1,
                ///  RLPIEX
                RLPIEX: u1,
                reserved8: u4,
                ///  TLPIST
                TLPIST: u1,
                ///  RLPIST
                RLPIST: u1,
                reserved16: u6,
                ///  LPIEN
                LPIEN: u1,
                ///  PLS
                PLS: u1,
                ///  PLSEN
                PLSEN: u1,
                ///  LPITXA
                LPITXA: u1,
                ///  LPITE
                LPITE: u1,
                padding: u11,
            }),
            reserved208: [8]u8,
            ///  The LPI Control and Status Register controls the LPI functions and provides the LPI interrupt status. The status bits are cleared when this register is read.
            ETH_MACLCSR: mmio.Mmio(packed struct(u32) {
                ///  TLPIEN
                TLPIEN: u1,
                ///  TLPIEX
                TLPIEX: u1,
                ///  RLPIEN
                RLPIEN: u1,
                ///  RLPIEX
                RLPIEX: u1,
                reserved8: u4,
                ///  TLPIST
                TLPIST: u1,
                ///  RLPIST
                RLPIST: u1,
                reserved16: u6,
                ///  LPIEN
                LPIEN: u1,
                ///  PLS
                PLS: u1,
                ///  PLSEN
                PLSEN: u1,
                ///  LPITXA
                LPITXA: u1,
                ///  LPITE
                LPITE: u1,
                padding: u11,
            }),
            ///  The LPI Timers Control register controls the timeout values in the LPI states. It specifies the time for which the MAC transmits the LPI pattern and also the time for which the MAC waits before resuming the normal transmission.
            ETH_MACLTCR: mmio.Mmio(packed struct(u32) {
                ///  TWT
                TWT: u16,
                ///  LST
                LST: u10,
                padding: u6,
            }),
            ///  The LPI Entry Timer Register is used to store the LPI Idle Timer Value in Micro-Seconds.
            ETH_MACLETR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  LPIET
                LPIET: u17,
                padding: u12,
            }),
            ///  This register controls the generation of the Reference time (1-microsecond tick) for all the LPI timers. This timer has to be programmed by the software initially.
            ETH_MAC1USTCR: mmio.Mmio(packed struct(u32) {
                ///  TIC_1US_CNTR
                TIC_1US_CNTR: u12,
                padding: u20,
            }),
            reserved248: [24]u8,
            ///  The PHY Interface Control and Status register indicates the status signals received by the, RGMII interface from the PHY.
            ETH_MACPHYCSR: mmio.Mmio(packed struct(u32) {
                ///  TC
                TC: u1,
                ///  LUD
                LUD: u1,
                reserved16: u14,
                ///  LNKMOD
                LNKMOD: u1,
                ///  LNKSPEED
                LNKSPEED: u2,
                ///  LNKSTS
                LNKSTS: u1,
                ///  JABTO
                JABTO: u1,
                ///  FALSCARDET
                FALSCARDET: u1,
                padding: u10,
            }),
            reserved272: [20]u8,
            ///  The version register identifies the version of the Ethernet peripheral.
            ETH_MACVR: mmio.Mmio(packed struct(u32) {
                ///  SNPSVER
                SNPSVER: u8,
                ///  USERVER
                USERVER: u8,
                padding: u16,
            }),
            ///  The Debug register provides the debug status of various MAC blocks.
            ETH_MACDR: mmio.Mmio(packed struct(u32) {
                ///  RPESTS
                RPESTS: u1,
                ///  RFCFCSTS
                RFCFCSTS: u2,
                reserved16: u13,
                ///  TPESTS
                TPESTS: u1,
                ///  TFCSTS
                TFCSTS: u2,
                padding: u13,
            }),
            reserved288: [8]u8,
            ///  This register indicates the presence of second set of the optional features or functions of the Ethernet peripheral. The software driver can use this register to dynamically enable or disable the programs related to the optional blocks.
            ETH_MACHWF1R: mmio.Mmio(packed struct(u32) {
                ///  RXFIFOSIZE
                RXFIFOSIZE: u5,
                reserved6: u1,
                ///  TXFIFOSIZE
                TXFIFOSIZE: u5,
                ///  OSTEN
                OSTEN: u1,
                ///  PTOEN
                PTOEN: u1,
                ///  ADVTHWORD
                ADVTHWORD: u1,
                ///  ADDR64
                ADDR64: u2,
                ///  DCBEN
                DCBEN: u1,
                ///  SPHEN
                SPHEN: u1,
                ///  TSOEN
                TSOEN: u1,
                ///  DBGMEMA
                DBGMEMA: u1,
                ///  AVSEL
                AVSEL: u1,
                reserved24: u3,
                ///  HASHTBLSZ
                HASHTBLSZ: u2,
                reserved27: u1,
                ///  L3L4FNUM
                L3L4FNUM: u4,
                padding: u1,
            }),
            ///  This register indicates the presence of third set of the optional features or functions of the Ethernet peripheral. The software driver can use this register to dynamically enable or disable the programs related to the optional blocks.
            ETH_MACHWF2R: mmio.Mmio(packed struct(u32) {
                ///  RXQCNT
                RXQCNT: u4,
                reserved6: u2,
                ///  TXQCNT
                TXQCNT: u4,
                reserved12: u2,
                ///  RXCHCNT
                RXCHCNT: u4,
                reserved18: u2,
                ///  TXCHCNT
                TXCHCNT: u4,
                reserved24: u2,
                ///  PPSOUTNUM
                PPSOUTNUM: u3,
                reserved28: u1,
                ///  AUXSNAPNUM
                AUXSNAPNUM: u3,
                padding: u1,
            }),
            reserved512: [216]u8,
            ///  The MDIO Address register controls the management cycles to external PHY through a management interface.
            ETH_MACMDIOAR: mmio.Mmio(packed struct(u32) {
                ///  GB
                GB: u1,
                ///  C45E
                C45E: u1,
                ///  GOC
                GOC: u2,
                ///  SKAP
                SKAP: u1,
                reserved8: u3,
                ///  CR
                CR: u4,
                ///  NTC
                NTC: u3,
                reserved16: u1,
                ///  RDA
                RDA: u5,
                ///  PA
                PA: u5,
                ///  BTB
                BTB: u1,
                ///  PSE
                PSE: u1,
                padding: u4,
            }),
            ///  The MDIO Data register stores the Write data to be written to the PHY register located at the address specified in ETH_MACMDIOAR. This register also stores the Read data from the PHY register located at the address specified by MDIO Address register.
            ETH_MACMDIODR: mmio.Mmio(packed struct(u32) {
                ///  GD
                GD: u16,
                ///  RA
                RA: u16,
            }),
            reserved768: [248]u8,
            ///  The MAC Address0 High register holds the upper 16 bits of the first 6-byte MAC address of the station. The first DA byte that is received on the GMII interface corresponds to the LS byte (Bits [7:0]) of the MAC Address Low register. For example, if 0x112233445566 is received (0x11 in lane 0 of the first column) on the GMII as the destination address, then the MacAddress0 Register [47:0] is compared with 0x665544332211. If the MAC address registers are configured to be double-synchronized to the GMII clock domains, then the synchronization is triggered only when Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the MAC Address0 Low Register are written. For proper synchronization updates, the consecutive writes to this Address Low Register should be performed after at least four clock cycles in the destination clock domain.
            ETH_MACA0HR: mmio.Mmio(packed struct(u32) {
                ///  ADDRHI
                ADDRHI: u16,
                reserved31: u15,
                ///  AE
                AE: u1,
            }),
            ///  The MAC Address x Low register holds the lower 32 bits of the 6-byte first MAC address of the station.
            ETH_MACA0LR: mmio.Mmio(packed struct(u32) {
                ///  ADDRLO
                ADDRLO: u32,
            }),
            ///  The MAC Address x High register holds the upper 16 bits of the second 6-byte MAC address of the station.
            ETH_MACA1HR: mmio.Mmio(packed struct(u32) {
                ///  ADDRHI
                ADDRHI: u16,
                reserved24: u8,
                ///  MBC
                MBC: u6,
                ///  SA
                SA: u1,
                ///  AE
                AE: u1,
            }),
            ///  The MAC Address x Low register holds the lower 32 bits of the 6-byte first MAC address of the station.
            ETH_MACA1LR: mmio.Mmio(packed struct(u32) {
                ///  ADDRLO
                ADDRLO: u32,
            }),
            ///  The MAC Address x High register holds the upper 16 bits of the second 6-byte MAC address of the station.
            ETH_MACA2HR: mmio.Mmio(packed struct(u32) {
                ///  ADDRHI
                ADDRHI: u16,
                reserved24: u8,
                ///  MBC
                MBC: u6,
                ///  SA
                SA: u1,
                ///  AE
                AE: u1,
            }),
            ///  The MAC Address x Low register holds the lower 32 bits of the 6-byte first MAC address of the station.
            ETH_MACA2LR: mmio.Mmio(packed struct(u32) {
                ///  ADDRLO
                ADDRLO: u32,
            }),
            ///  The MAC Address x High register holds the upper 16 bits of the second 6-byte MAC address of the station.
            ETH_MACA3HR: mmio.Mmio(packed struct(u32) {
                ///  ADDRHI
                ADDRHI: u16,
                reserved24: u8,
                ///  MBC
                MBC: u6,
                ///  SA
                SA: u1,
                ///  AE
                AE: u1,
            }),
            ///  The MAC Address x Low register holds the lower 32 bits of the 6-byte first MAC address of the station.
            ETH_MACA3LR: mmio.Mmio(packed struct(u32) {
                ///  ADDRLO
                ADDRLO: u32,
            }),
            reserved1792: [992]u8,
            ///  This register configures the MMC operating mode.
            MMC_CONTROL: mmio.Mmio(packed struct(u32) {
                ///  CNTRST
                CNTRST: u1,
                ///  CNTSTOPRO
                CNTSTOPRO: u1,
                ///  RSTONRD
                RSTONRD: u1,
                ///  CNTFREEZ
                CNTFREEZ: u1,
                ///  CNTPRST
                CNTPRST: u1,
                ///  CNTPRSTLVL
                CNTPRSTLVL: u1,
                reserved8: u2,
                ///  UCDBC
                UCDBC: u1,
                padding: u23,
            }),
            ///  This register maintains the interrupts generated from all Receive statistics counters. The MMC Receive Interrupt register maintains the interrupts that are generated when the following occur: Receive statistic counters reach half of their maximum values (0x8000_0000 for 32 bit counter and 0x8000 for 16 bit counter). Receive statistic counters cross their maximum values (0xFFFF_FFFF for 32 bit counter and 0xFFFF for 16 bit counter). When the Counter Stop Rollover is set, interrupts are set but the counter remains at all-ones. The MMC Receive Interrupt register is a 32 bit register. An interrupt bit is cleared when the respective MMC counter that caused the interrupt is read. The least significant byte lane (Bits[7:0]) of the respective counter must be read to clear the interrupt bit.
            MMC_RX_INTERRUPT: mmio.Mmio(packed struct(u32) {
                reserved5: u5,
                ///  RXCRCERPIS
                RXCRCERPIS: u1,
                ///  RXALGNERPIS
                RXALGNERPIS: u1,
                reserved17: u10,
                ///  RXUCGPIS
                RXUCGPIS: u1,
                reserved26: u8,
                ///  RXLPIUSCIS
                RXLPIUSCIS: u1,
                ///  RXLPITRCIS
                RXLPITRCIS: u1,
                padding: u4,
            }),
            ///  This register maintains the interrupts generated from all Transmit statistics counters. The MMC Transmit Interrupt register maintains the interrupts generated when transmit statistic counters reach half their maximum values (0x8000_0000 for 32 bit counter and 0x8000 for 16 bit counter), and when they cross their maximum values (0xFFFF_FFFF for 32-bit counter and 0xFFFF for 16-bit counter). When Counter Stop Rollover is set, the interrupts are set but the counter remains at all-ones. The MMC Transmit Interrupt register is a 32 bit register. An interrupt bit is cleared when the respective MMC counter that caused the interrupt is read. The least significant byte lane (Bits[7:0]) of the respective counter must be read to clear the interrupt bit.
            MMC_TX_INTERRUPT: mmio.Mmio(packed struct(u32) {
                reserved14: u14,
                ///  TXSCOLGPIS
                TXSCOLGPIS: u1,
                ///  TXMCOLGPIS
                TXMCOLGPIS: u1,
                reserved21: u5,
                ///  TXGPKTIS
                TXGPKTIS: u1,
                reserved26: u4,
                ///  TXLPIUSCIS
                TXLPIUSCIS: u1,
                ///  TXLPITRCIS
                TXLPITRCIS: u1,
                padding: u4,
            }),
            ///  The MMC Receive Interrupt Mask register maintains the masks for the interrupts generated when receive statistic counters reach half of their maximum value or the maximum values.
            MMC_RX_INTERRUPT_MASK: mmio.Mmio(packed struct(u32) {
                reserved5: u5,
                ///  RXCRCERPIM
                RXCRCERPIM: u1,
                ///  RXALGNERPIM
                RXALGNERPIM: u1,
                reserved17: u10,
                ///  RXUCGPIM
                RXUCGPIM: u1,
                reserved26: u8,
                ///  RXLPIUSCIM
                RXLPIUSCIM: u1,
                ///  RXLPITRCIM
                RXLPITRCIM: u1,
                padding: u4,
            }),
            ///  This register maintains the masks for interrupts generated from all Transmit statistics counters. The MMC Transmit Interrupt Mask register maintains the masks for the interrupts generated when the transmit statistic counters reach half of their maximum value or the maximum values. This register is 32 bit wide. This register is present only when any one of the MMC Transmit Counters is selected during core configuration.
            MMC_TX_INTERRUPT_MASK: mmio.Mmio(packed struct(u32) {
                reserved14: u14,
                ///  TXSCOLGPIM
                TXSCOLGPIM: u1,
                ///  TXMCOLGPIM
                TXMCOLGPIM: u1,
                reserved21: u5,
                ///  TXGPKTIM
                TXGPKTIM: u1,
                reserved26: u4,
                ///  TXLPIUSCIM
                TXLPIUSCIM: u1,
                ///  TXLPITRCIM
                TXLPITRCIM: u1,
                padding: u4,
            }),
            reserved1868: [56]u8,
            ///  This register provides the number of successfully transmitted packets by Ethernet peripheral after a single collision in the half-duplex mode.
            TX_SINGLE_COLLISION_GOOD_PACKETS: mmio.Mmio(packed struct(u32) {
                ///  TXSNGLCOLG
                TXSNGLCOLG: u32,
            }),
            ///  This register provides the number of successfully transmitted packets by Ethernet peripheral after multiple collisions in the half-duplex mode.
            TX_MULTIPLE_COLLISION_GOOD_PACKETS: mmio.Mmio(packed struct(u32) {
                ///  TXMULTCOLG
                TXMULTCOLG: u32,
            }),
            reserved1896: [20]u8,
            ///  This register provides the number of good packets transmitted by Ethernet peripheral.
            TX_PACKET_COUNT_GOOD: mmio.Mmio(packed struct(u32) {
                ///  TXPKTG
                TXPKTG: u32,
            }),
            reserved1940: [40]u8,
            ///  This register provides the number of packets received by Ethernet peripheral with CRC error.
            RX_CRC_ERROR_PACKETS: mmio.Mmio(packed struct(u32) {
                ///  RXCRCERR
                RXCRCERR: u32,
            }),
            ///  This register provides the number of packets received by Ethernet peripheral with alignment (dribble) error. It is valid only in 10/100 mode.
            RX_ALIGNMENT_ERROR_PACKETS: mmio.Mmio(packed struct(u32) {
                ///  RXALGNERR
                RXALGNERR: u32,
            }),
            reserved1988: [40]u8,
            ///  This register provides the number of good unicast packets received by Ethernet peripheral.
            RX_UNICAST_PACKETS_GOOD: mmio.Mmio(packed struct(u32) {
                ///  RXUCASTG
                RXUCASTG: u32,
            }),
            reserved2028: [36]u8,
            ///  This register provides the number of microseconds Tx LPI is asserted by Ethernet peripheral.
            TX_LPI_USEC_CNTR: mmio.Mmio(packed struct(u32) {
                ///  TXLPIUSC
                TXLPIUSC: u32,
            }),
            ///  This register provides the number of times Ethernet peripheral has entered Tx LPI.
            TX_LPI_TRAN_CNTR: mmio.Mmio(packed struct(u32) {
                ///  TXLPITRC
                TXLPITRC: u32,
            }),
            ///  This register provides the number of microseconds Rx LPI is sampled by Ethernet peripheral.
            RX_LPI_USEC_CNTR: mmio.Mmio(packed struct(u32) {
                ///  RXLPIUSC
                RXLPIUSC: u32,
            }),
            ///  This register provides the number of times Ethernet peripheral has entered Rx LPI.
            RX_LPI_TRAN_CNTR: mmio.Mmio(packed struct(u32) {
                ///  RXLPITRC
                RXLPITRC: u32,
            }),
            reserved2304: [260]u8,
            ///  The Layer 3 and Layer 4 Control register controls the operations of filter 0 of Layer 3 and Layer 4. This register is reserved if the Layer 3 and Layer 4 Filtering feature is not selected during core configuration.
            ETH_MACL3L4C0R: mmio.Mmio(packed struct(u32) {
                ///  L3PEN0
                L3PEN0: u1,
                reserved2: u1,
                ///  L3SAM0
                L3SAM0: u1,
                ///  L3SAIM0
                L3SAIM0: u1,
                ///  L3DAM0
                L3DAM0: u1,
                ///  L3DAIM0
                L3DAIM0: u1,
                ///  L3HSBM0
                L3HSBM0: u5,
                ///  L3HDBM0
                L3HDBM0: u5,
                ///  L4PEN0
                L4PEN0: u1,
                reserved18: u1,
                ///  L4SPM0
                L4SPM0: u1,
                ///  L4SPIM0
                L4SPIM0: u1,
                ///  L4DPM0
                L4DPM0: u1,
                ///  L4DPIM0
                L4DPIM0: u1,
                padding: u10,
            }),
            ///  Layer4 address filter 0 register
            ETH_MACL4A0R: mmio.Mmio(packed struct(u32) {
                ///  L4SP0
                L4SP0: u16,
                ///  L4DP0
                L4DP0: u16,
            }),
            reserved2320: [8]u8,
            ///  For IPv4 packets, the Layer 3 Address 0 Register 0 register contains the 32-bit IP Source Address field. For IPv6 packets, it contains Bits[31:0] of the 128-bit IP Source Address or Destination Address field.
            ETH_MACL3A00R: mmio.Mmio(packed struct(u32) {
                ///  L3A00
                L3A00: u32,
            }),
            ///  For IPv4 packets, the Layer 3 Address 1 Register 0 register contains the 32-bit IP Destination Address field. For IPv6 packets, it contains Bits[63:32] of the 128-bit IP Source Address or Destination Address field.
            ETH_MACL3A10R: mmio.Mmio(packed struct(u32) {
                ///  L3A10
                L3A10: u32,
            }),
            ///  The Layer 3 Address 2 Register 0 register is reserved for IPv4 packets. For IPv6 packets, it contains Bits[95:64] of 128-bit IP Source Address or Destination Address field.
            ETH_MACL3A20: mmio.Mmio(packed struct(u32) {
                ///  L3A20
                L3A20: u32,
            }),
            ///  The Layer 3 Address 3 Register 0 register is reserved for IPv4 packets. For IPv6 packets, it contains Bits[127:96] of 128-bit IP Source Address or Destination Address field.
            ETH_MACL3A30: mmio.Mmio(packed struct(u32) {
                ///  L3A30
                L3A30: u32,
            }),
            reserved2352: [16]u8,
            ///  The Layer 3 and Layer 4 Control register controls the operations of filter 0 of Layer 3 and Layer 4.
            ETH_MACL3L4C1R: mmio.Mmio(packed struct(u32) {
                ///  L3PEN1
                L3PEN1: u1,
                reserved2: u1,
                ///  L3SAM1
                L3SAM1: u1,
                ///  L3SAIM1
                L3SAIM1: u1,
                ///  L3DAM1
                L3DAM1: u1,
                ///  L3DAIM1
                L3DAIM1: u1,
                ///  L3HSBM1
                L3HSBM1: u5,
                ///  L3HDBM1
                L3HDBM1: u5,
                ///  L4PEN1
                L4PEN1: u1,
                reserved18: u1,
                ///  L4SPM1
                L4SPM1: u1,
                ///  L4SPIM1
                L4SPIM1: u1,
                ///  L4DPM1
                L4DPM1: u1,
                ///  L4DPIM1
                L4DPIM1: u1,
                padding: u10,
            }),
            ///  The Layer 4 Address 0 register and registers 580 through 667 are reserved (RO with default value) if Enable Layer 3 and Layer 4 Packet Filter option is not selected while configuring the core. You can configure the Layer 3 and Layer 4 Address Registers to be double-synchronized by selecting the Synchronize Layer 3 and Layer 4 Address Registers to Rx Clock Domain option while configuring the core. When you select this option, the synchronization is triggered only when Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the Layer 3 and Layer 4 Address Registers are written. For proper synchronization updates, you should perform consecutive writes to same Layer 3 and Layer 4 Address Registers after at least four clock cycles delay of the destination clock.
            ETH_MACL4A1R: mmio.Mmio(packed struct(u32) {
                ///  L4SP1
                L4SP1: u16,
                ///  L4DP1
                L4DP1: u16,
            }),
            reserved2368: [8]u8,
            ///  For IPv4 packets, the Layer 3 Address 0 Register 0 register contains the 32-bit IP Source Address field. For IPv6 packets, it contains Bits[31:0] of the 128-bit IP Source Address or Destination Address field.
            ETH_MACL3A01R: mmio.Mmio(packed struct(u32) {
                ///  L3A01
                L3A01: u32,
            }),
            ///  For IPv4 packets, the Layer 3 Address 1 Register 0 register contains the 32-bit IP Destination Address field. For IPv6 packets, it contains Bits[63:32] of the 128-bit IP Source Address or Destination Address field.
            ETH_MACL3A11R: mmio.Mmio(packed struct(u32) {
                ///  L3A11
                L3A11: u32,
            }),
            ///  The Layer 3 Address 2 Register 0 register is reserved for IPv4 packets. For IPv6 packets, it contains Bits[95:64] of 128-bit IP Source Address or Destination Address field.
            ETH_MACL3A21R: mmio.Mmio(packed struct(u32) {
                ///  L3A21
                L3A21: u32,
            }),
            ///  The Layer 3 Address 3 Register 0 register is reserved for IPv4 packets. For IPv6 packets, it contains Bits[127:96] of 128-bit IP Source Address or Destination Address field.
            ETH_MACL3A31R: mmio.Mmio(packed struct(u32) {
                ///  L3A31
                L3A31: u32,
            }),
            reserved2784: [400]u8,
            ///  The ARP Address register contains the IPv4 Destination Address of the MAC.
            ETH_MACARPAR: mmio.Mmio(packed struct(u32) {
                ///  ARPPA
                ARPPA: u32,
            }),
            reserved2816: [28]u8,
            ///  This register controls the operation of the System Time generator and processing of PTP packets for timestamping in the Receiver.
            ETH_MACTSCR: mmio.Mmio(packed struct(u32) {
                ///  TSENA
                TSENA: u1,
                ///  TSCFUPDT
                TSCFUPDT: u1,
                ///  TSINIT
                TSINIT: u1,
                ///  TSUPDT
                TSUPDT: u1,
                reserved5: u1,
                ///  TSADDREG
                TSADDREG: u1,
                reserved8: u2,
                ///  TSENALL
                TSENALL: u1,
                ///  TSCTRLSSR
                TSCTRLSSR: u1,
                ///  TSVER2ENA
                TSVER2ENA: u1,
                ///  TSIPENA
                TSIPENA: u1,
                ///  TSIPV6ENA
                TSIPV6ENA: u1,
                ///  TSIPV4ENA
                TSIPV4ENA: u1,
                ///  TSEVNTENA
                TSEVNTENA: u1,
                ///  TSMSTRENA
                TSMSTRENA: u1,
                ///  SNAPTYPSEL
                SNAPTYPSEL: u2,
                ///  TSENMACADDR
                TSENMACADDR: u1,
                ///  CSC
                CSC: u1,
                reserved24: u4,
                ///  TXTSSTSM
                TXTSSTSM: u1,
                reserved28: u3,
                ///  AV8021ASMEN
                AV8021ASMEN: u1,
                padding: u3,
            }),
            ///  The Sub-second Increment register is present only when the IEEE 1588 timestamp feature is selected without an external timestamp input. In Coarse Update mode [Bit 1 in ETH_MACTSCR register, the value in this register is added to the system time every clock cycle of HCLK. In Fine Update mode, the value in this register is added to the system time whenever the Accumulator gets an overflow.
            ETH_MACSSIR: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                ///  SNSINC
                SNSINC: u8,
                ///  SSINC
                SSINC: u8,
                padding: u8,
            }),
            ///  The System Time Seconds register, along with System Time Nanoseconds register, indicates the current value of the system time maintained by the MAC. Though it is updated on a continuous basis, there is some delay from the actual time because of clock domain transfer latencies (from HCLK to CSR clock). This register is present only when the IEEE 1588 Timestamp feature is selected without external timestamp input.
            ETH_MACSTSR: mmio.Mmio(packed struct(u32) {
                ///  TSS
                TSS: u32,
            }),
            ///  The System Time Nanoseconds register, along with System Time Seconds register, indicates the current value of the system time maintained by the MAC. This register is present only when the IEEE 1588 Timestamp feature is selected without external timestamp input.
            ETH_MACSTNR: mmio.Mmio(packed struct(u32) {
                ///  TSSS
                TSSS: u31,
                padding: u1,
            }),
            ///  The System Time Seconds Update register, along with the System Time Nanoseconds Update register, initializes or updates the system time maintained by the MAC. You must write both registers before setting the TSINIT or TSUPDT bits in ETH_MACTSCR register. This register is present only when the IEEE 1588 Timestamp feature is selected without external timestamp input.
            ETH_MACSTSUR: mmio.Mmio(packed struct(u32) {
                ///  TSS
                TSS: u32,
            }),
            ///  This register is present only when the IEEE 1588 timestamp feature is selected without external timestamp input.
            ETH_MACSTNUR: mmio.Mmio(packed struct(u32) {
                ///  TSSS
                TSSS: u31,
                ///  ADDSUB
                ADDSUB: u1,
            }),
            ///  The Timestamp Addend register is present only when the IEEE 1588 Timestamp feature is selected without external timestamp input. This register value is used only when the system time is configured for Fine Update mode (TSCFUPDT bit in the ETH_MACTSCR register). The content of this register is added to a 32-bit accumulator in every clock cycle (of HCLK) and the system time is updated whenever the accumulator overflows.
            ETH_MACTSAR: mmio.Mmio(packed struct(u32) {
                ///  TSAR
                TSAR: u32,
            }),
            reserved2848: [4]u8,
            ///  The Timestamp Status register is present only when the IEEE 1588 Timestamp feature is selected. All bits except Bits[27:25] gets cleared when the application reads this register.
            ETH_MACTSSR: mmio.Mmio(packed struct(u32) {
                ///  TSSOVF
                TSSOVF: u1,
                ///  TSTARGT0
                TSTARGT0: u1,
                ///  AUXTSTRIG
                AUXTSTRIG: u1,
                ///  TSTRGTERR0
                TSTRGTERR0: u1,
                reserved15: u11,
                ///  TXTSSIS
                TXTSSIS: u1,
                ///  ATSSTN
                ATSSTN: u4,
                reserved24: u4,
                ///  ATSSTM
                ATSSTM: u1,
                ///  ATSNS
                ATSNS: u5,
                padding: u2,
            }),
            reserved2864: [12]u8,
            ///  This register contains the nanosecond part of timestamp captured for Transmit packets when Tx status is disabled.
            ETH_MACTxTSSNR: mmio.Mmio(packed struct(u32) {
                ///  TXTSSLO
                TXTSSLO: u31,
                ///  TXTSSMIS
                TXTSSMIS: u1,
            }),
            ///  The register contains the higher 32 bits of the timestamp (in seconds) captured when a PTP packet is transmitted.
            ETH_MACTxTSSSR: mmio.Mmio(packed struct(u32) {
                ///  TXTSSHI
                TXTSSHI: u32,
            }),
            reserved2880: [8]u8,
            ///  The Auxiliary Timestamp Control register controls the Auxiliary Timestamp snapshot.
            ETH_MACACR: mmio.Mmio(packed struct(u32) {
                ///  ATSFC
                ATSFC: u1,
                reserved4: u3,
                ///  ATSEN0
                ATSEN0: u1,
                ///  ATSEN1
                ATSEN1: u1,
                ///  ATSEN2
                ATSEN2: u1,
                ///  ATSEN3
                ATSEN3: u1,
                padding: u24,
            }),
            reserved2888: [4]u8,
            ///  The Auxiliary Timestamp Nanoseconds register, along with ETH_MACATSSR, gives the 64-bit timestamp stored as auxiliary snapshot. These two registers form the read port of a 64-bit wide FIFO with a depth of 4 words. You can store multiple snapshots in this FIFO. Bits[29:25] in ETH_MACTSSR indicate the fill-level of the FIFO. The top of the FIFO is removed only when the last byte of MAC Register 91 (Auxiliary Timestamp - Seconds Register) is read. In the little-endian mode, this means when Bits[31:24] are read and in big-endian mode, Bits[7:0] are read.
            ETH_MACATSNR: mmio.Mmio(packed struct(u32) {
                ///  AUXTSLO
                AUXTSLO: u31,
                padding: u1,
            }),
            ///  The Auxiliary Timestamp - Seconds register contains the lower 32 bits of the Seconds field of the auxiliary timestamp register.
            ETH_MACATSSR: mmio.Mmio(packed struct(u32) {
                ///  AUXTSHI
                AUXTSHI: u32,
            }),
            ///  The MAC Timestamp Ingress Asymmetry Correction register contains the Ingress Asymmetry Correction value to be used while updating correction field in PDelay_Resp PTP messages.
            ETH_MACTSIACR: mmio.Mmio(packed struct(u32) {
                ///  OSTIAC
                OSTIAC: u32,
            }),
            ///  The MAC Timestamp Egress Asymmetry Correction register contains the Egress Asymmetry Correction value to be used while updating the correction field in PDelay_Req PTP messages.
            ETH_MACTSEACR: mmio.Mmio(packed struct(u32) {
                ///  OSTEAC
                OSTEAC: u32,
            }),
            ///  This register contains the correction value in nanoseconds to be used with the captured timestamp value in the ingress path.
            ETH_MACTSICNR: mmio.Mmio(packed struct(u32) {
                ///  TSIC
                TSIC: u32,
            }),
            ///  This register contains the correction value in nanoseconds to be used with the captured timestamp value in the egress path.
            ETH_MACTSECNR: mmio.Mmio(packed struct(u32) {
                ///  TSEC
                TSEC: u32,
            }),
            reserved2928: [16]u8,
            ///  The PPS Control register is present only when the Timestamp feature is selected and External Timestamp is not enabled. Bits[30:24] of this register are valid only when four Flexible PPS outputs are selected. Bits[22:16] are valid only when three or more Flexible PPS outputs are selected. Bits[14:8] are valid only when two or more Flexible PPS outputs are selected. Bits[6:4] are valid only when Flexible PPS feature is selected.
            ETH_MACPPSCR: mmio.Mmio(packed struct(u32) {
                ///  PPSCTRL
                PPSCTRL: u4,
                ///  PPSEN0
                PPSEN0: u1,
                ///  TRGTMODSEL0
                TRGTMODSEL0: u2,
                padding: u25,
            }),
            reserved2944: [12]u8,
            ///  The PPS Target Time Seconds register, along with PPS Target Time Nanoseconds register, is used to schedule an interrupt event [Bit 1 of ETH_MACTSSR] when the system time exceeds the value programmed in these registers.
            ETH_MACPPSTTSR: mmio.Mmio(packed struct(u32) {
                ///  TSTRH0
                TSTRH0: u32,
            }),
            ///  The PPS Target Time Nanoseconds register is present only when more than one Flexible PPS output is selected.
            ETH_MACPPSTTNR: mmio.Mmio(packed struct(u32) {
                ///  TTSL0
                TTSL0: u31,
                ///  TRGTBUSY0
                TRGTBUSY0: u1,
            }),
            ///  The PPS Interval register contains the number of units of sub-second increment value between the rising edges of PPS signal output (ptp_pps_o[0]).
            ETH_MACPPSIR: mmio.Mmio(packed struct(u32) {
                ///  PPSINT0
                PPSINT0: u32,
            }),
            ///  The PPS Width register contains the number of units of sub-second increment value between the rising and corresponding falling edges of PPS signal output (ptp_pps_o).
            ETH_MACPPSWR: mmio.Mmio(packed struct(u32) {
                ///  PPSWIDTH0
                PPSWIDTH0: u32,
            }),
            reserved3008: [48]u8,
            ///  This register controls the PTP Offload Engine operation. This register is available only when the Enable PTP Timestamp Offload feature is selected.
            ETH_MACPOCR: mmio.Mmio(packed struct(u32) {
                ///  PTOEN
                PTOEN: u1,
                ///  ASYNCEN
                ASYNCEN: u1,
                ///  APDREQEN
                APDREQEN: u1,
                reserved4: u1,
                ///  ASYNCTRIG
                ASYNCTRIG: u1,
                ///  APDREQTRIG
                APDREQTRIG: u1,
                ///  DRRDIS
                DRRDIS: u1,
                reserved8: u1,
                ///  DN
                DN: u8,
                padding: u16,
            }),
            ///  This register contains Bits[31:0] of the 80-bit Source Port Identity of the PTP node. This register is available only when the Enable PTP Timestamp Offload feature is selected.
            ETH_MACSPI0R: mmio.Mmio(packed struct(u32) {
                ///  SPI0
                SPI0: u32,
            }),
            ///  This register contains Bits[63:32] of the 80-bit Source Port Identity of the PTP node. This register is available only when the Enable PTP Timestamp Offload feature is selected.
            ETH_MACSPI1R: mmio.Mmio(packed struct(u32) {
                ///  SPI1
                SPI1: u32,
            }),
            ///  This register contains Bits[79:64] of the 80-bit Source Port Identity of the PTP node.
            ETH_MACSPI2R: mmio.Mmio(packed struct(u32) {
                ///  SPI2
                SPI2: u16,
                padding: u16,
            }),
            ///  This register contains the periodic intervals for automatic PTP packet generation.
            ETH_MACLMIR: mmio.Mmio(packed struct(u32) {
                ///  LSI
                LSI: u8,
                ///  DRSYNCR
                DRSYNCR: u3,
                reserved24: u13,
                ///  LMPDRI
                LMPDRI: u8,
            }),
        };

        ///  ETH_MTL
        pub const ETH_MTL = extern struct {
            ///  The Operating Mode register establishes the Transmit and Receive operating modes and commands.
            ETH_MTLOMR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  DTXSTS
                DTXSTS: u1,
                ///  RAA
                RAA: u1,
                reserved5: u2,
                ///  SCHALG
                SCHALG: u2,
                reserved8: u1,
                ///  CNTPRST
                CNTPRST: u1,
                ///  CNTCLR
                CNTCLR: u1,
                padding: u22,
            }),
            reserved32: [28]u8,
            ///  The software driver (application) reads this register during interrupt service routine or polling to determine the interrupt status of MTL queues and the MAC.
            ETH_MTLISR: mmio.Mmio(packed struct(u32) {
                ///  Q0IS
                Q0IS: u1,
                ///  Q1IS
                Q1IS: u1,
                padding: u30,
            }),
            reserved256: [220]u8,
            ///  Tx queue 0 operating mode Register
            ETH_MTLTxQ0OMR: mmio.Mmio(packed struct(u32) {
                ///  FTQ
                FTQ: u1,
                ///  TSF
                TSF: u1,
                ///  TXQEN
                TXQEN: u2,
                ///  TTC
                TTC: u2,
                reserved16: u10,
                ///  TQS
                TQS: u9,
                padding: u7,
            }),
            ///  Tx queue 0 underflow register
            ETH_MTLTxQ0UR: mmio.Mmio(packed struct(u32) {
                ///  UFFRMCNT
                UFFRMCNT: u11,
                ///  UFCNTOVF
                UFCNTOVF: u1,
                padding: u20,
            }),
            ///  Tx queue 0 underflow register
            ETH_MTLTxQ0DR: mmio.Mmio(packed struct(u32) {
                ///  TXQPAUSED
                TXQPAUSED: u1,
                ///  TRCSTS
                TRCSTS: u2,
                ///  TWCSTS
                TWCSTS: u1,
                ///  TXQSTS
                TXQSTS: u1,
                ///  TXSTSFSTS
                TXSTSFSTS: u1,
                reserved16: u10,
                ///  PTXQ
                PTXQ: u3,
                reserved20: u1,
                ///  STXSTSF
                STXSTSF: u3,
                padding: u9,
            }),
            reserved276: [8]u8,
            ///  Tx queue x ETS status Register
            ETH_MTLTxQ0ESR: mmio.Mmio(packed struct(u32) {
                ///  ABS
                ABS: u24,
                padding: u8,
            }),
            reserved300: [20]u8,
            ///  Queue 0 interrupt control status Register
            ETH_MTLQ0ICSR: mmio.Mmio(packed struct(u32) {
                ///  TXUNFIS
                TXUNFIS: u1,
                ///  ABPSIS
                ABPSIS: u1,
                reserved8: u6,
                ///  TXUIE
                TXUIE: u1,
                ///  ABPSIE
                ABPSIE: u1,
                reserved16: u6,
                ///  RXOVFIS
                RXOVFIS: u1,
                reserved24: u7,
                ///  RXOIE
                RXOIE: u1,
                padding: u7,
            }),
            ///  Rx queue 0 operating mode register
            ETH_MTLRxQ0OMR: mmio.Mmio(packed struct(u32) {
                ///  RTC
                RTC: u2,
                reserved3: u1,
                ///  FUP
                FUP: u1,
                ///  FEP
                FEP: u1,
                ///  RSF
                RSF: u1,
                ///  DIS_TCP_EF
                DIS_TCP_EF: u1,
                ///  EHFC
                EHFC: u1,
                ///  RFA
                RFA: u3,
                reserved14: u3,
                ///  RFD
                RFD: u3,
                reserved20: u3,
                ///  RQS
                RQS: u4,
                padding: u8,
            }),
            ///  Rx queue 0 missed packet and overflow counter register
            ETH_MTLRxQ0MPOCR: mmio.Mmio(packed struct(u32) {
                ///  OVFPKTCNT
                OVFPKTCNT: u11,
                ///  OVFCNTOVF
                OVFCNTOVF: u1,
                reserved16: u4,
                ///  MISPKTCNT
                MISPKTCNT: u11,
                ///  MISCNTOVF
                MISCNTOVF: u1,
                padding: u4,
            }),
            ///  Rx queue i debug register
            ETH_MTLRxQ0DR: mmio.Mmio(packed struct(u32) {
                ///  RWCSTS
                RWCSTS: u1,
                ///  RRCSTS
                RRCSTS: u2,
                reserved4: u1,
                ///  RXQSTS
                RXQSTS: u2,
                reserved16: u10,
                ///  PRXQ
                PRXQ: u14,
                padding: u2,
            }),
            ///  Rx queue 0 control register
            ETH_MTLRxQ0CR: mmio.Mmio(packed struct(u32) {
                ///  RXQ_WEGT
                RXQ_WEGT: u3,
                ///  RXQ_FRM_ARBIT
                RXQ_FRM_ARBIT: u1,
                padding: u28,
            }),
            ///  Tx queue 1 operating mode Register
            ETH_MTLTxQ1OMR: mmio.Mmio(packed struct(u32) {
                ///  FTQ
                FTQ: u1,
                ///  TSF
                TSF: u1,
                ///  TXQEN
                TXQEN: u2,
                ///  TTC
                TTC: u2,
                reserved16: u10,
                ///  TQS
                TQS: u9,
                padding: u7,
            }),
            ///  Tx queue 1 underflow register
            ETH_MTLTxQ1UR: mmio.Mmio(packed struct(u32) {
                ///  UFFRMCNT
                UFFRMCNT: u11,
                ///  UFCNTOVF
                UFCNTOVF: u1,
                padding: u20,
            }),
            ///  Tx queue 1 underflow register
            ETH_MTLTxQ1DR: mmio.Mmio(packed struct(u32) {
                ///  TXQPAUSED
                TXQPAUSED: u1,
                ///  TRCSTS
                TRCSTS: u2,
                ///  TWCSTS
                TWCSTS: u1,
                ///  TXQSTS
                TXQSTS: u1,
                ///  TXSTSFSTS
                TXSTSFSTS: u1,
                reserved16: u10,
                ///  PTXQ
                PTXQ: u3,
                reserved20: u1,
                ///  STXSTSF
                STXSTSF: u3,
                padding: u9,
            }),
            reserved336: [4]u8,
            ///  The Queue ETS Control register controls the enhanced transmission selection operation.
            ETH_MTLTxQ1ECR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  AVALG
                AVALG: u1,
                ///  CC
                CC: u1,
                ///  SLC
                SLC: u3,
                padding: u25,
            }),
            ///  Tx queue x ETS status Register
            ETH_MTLTxQ1ESR: mmio.Mmio(packed struct(u32) {
                ///  ABS
                ABS: u24,
                padding: u8,
            }),
            ///  This register provides the average traffic transmitted on queue 1.
            ETH_MTLTxQ1QWR: mmio.Mmio(packed struct(u32) {
                ///  ISCQW
                ISCQW: u21,
                padding: u11,
            }),
            ///  The sendSlopeCredit register contains the sendSlope credit value required for the credit-based shaper algorithm for the Queue.
            ETH_MTLTxQ1SSCR: mmio.Mmio(packed struct(u32) {
                ///  SSC
                SSC: u14,
                padding: u18,
            }),
            ///  The hiCredit register contains the hiCredit value required for the credit-based shaper algorithm for the Queue.
            ETH_MTLTxQ1HCR: mmio.Mmio(packed struct(u32) {
                ///  HC
                HC: u29,
                padding: u3,
            }),
            ///  The loCredit register contains the loCredit value required for the credit-based shaper algorithm for the Queue.
            ETH_MTLTxQ1LCR: mmio.Mmio(packed struct(u32) {
                ///  LC
                LC: u29,
                padding: u3,
            }),
            reserved364: [4]u8,
            ///  Queue 1 interrupt control status Register
            ETH_MTLQ1ICSR: mmio.Mmio(packed struct(u32) {
                ///  TXUNFIS
                TXUNFIS: u1,
                ///  ABPSIS
                ABPSIS: u1,
                reserved8: u6,
                ///  TXUIE
                TXUIE: u1,
                ///  ABPSIE
                ABPSIE: u1,
                reserved16: u6,
                ///  RXOVFIS
                RXOVFIS: u1,
                reserved24: u7,
                ///  RXOIE
                RXOIE: u1,
                padding: u7,
            }),
            ///  Rx queue 1 operating mode register
            ETH_MTLRxQ1OMR: mmio.Mmio(packed struct(u32) {
                ///  RTC
                RTC: u2,
                reserved3: u1,
                ///  FUP
                FUP: u1,
                ///  FEP
                FEP: u1,
                ///  RSF
                RSF: u1,
                ///  DIS_TCP_EF
                DIS_TCP_EF: u1,
                ///  EHFC
                EHFC: u1,
                ///  RFA
                RFA: u3,
                reserved14: u3,
                ///  RFD
                RFD: u3,
                reserved20: u3,
                ///  RQS
                RQS: u4,
                padding: u8,
            }),
            ///  Rx queue 1 missed packet and overflow counter register
            ETH_MTLRxQ1MPOCR: mmio.Mmio(packed struct(u32) {
                ///  OVFPKTCNT
                OVFPKTCNT: u11,
                ///  OVFCNTOVF
                OVFCNTOVF: u1,
                reserved16: u4,
                ///  MISPKTCNT
                MISPKTCNT: u11,
                ///  MISCNTOVF
                MISCNTOVF: u1,
                padding: u4,
            }),
            ///  Rx queue i debug register
            ETH_MTLRxQ1DR: mmio.Mmio(packed struct(u32) {
                ///  RWCSTS
                RWCSTS: u1,
                ///  RRCSTS
                RRCSTS: u2,
                reserved4: u1,
                ///  RXQSTS
                RXQSTS: u2,
                reserved16: u10,
                ///  PRXQ
                PRXQ: u14,
                padding: u2,
            }),
            ///  Rx queue 1 control register
            ETH_MTLRxQ1CR: mmio.Mmio(packed struct(u32) {
                ///  RXQ_WEGT
                RXQ_WEGT: u3,
                ///  RXQ_FRM_ARBIT
                RXQ_FRM_ARBIT: u1,
                padding: u28,
            }),
        };

        ///  ETH_DMA
        pub const ETH_DMA = extern struct {
            ///  DMA mode register
            ETH_DMAMR: mmio.Mmio(packed struct(u32) {
                ///  Software Reset
                SWR: u1,
                reserved2: u1,
                ///  TAA
                TAA: u3,
                reserved11: u6,
                ///  Transmit priority
                TXPR: u1,
                ///  Priority ratio
                PR: u3,
                reserved16: u1,
                ///  Interrupt Mode
                INTM: u2,
                padding: u14,
            }),
            ///  System bus mode register
            ETH_DMASBMR: mmio.Mmio(packed struct(u32) {
                ///  Fixed Burst Length
                FB: u1,
                ///  BLEN4
                BLEN4: u1,
                ///  BLEN8
                BLEN8: u1,
                ///  BLEN16
                BLEN16: u1,
                ///  BLEN32
                BLEN32: u1,
                ///  BLEN64
                BLEN64: u1,
                ///  BLEN128
                BLEN128: u1,
                ///  BLEN256
                BLEN256: u1,
                reserved12: u4,
                ///  Address-Aligned Beats
                AAL: u1,
                ///  ONEKBBE
                ONEKBBE: u1,
                reserved16: u2,
                ///  RD_OSR_LMT
                RD_OSR_LMT: u2,
                reserved24: u6,
                ///  WR_OSR_LMT
                WR_OSR_LMT: u2,
                reserved30: u4,
                ///  LPI_XIT_PKT
                LPI_XIT_PKT: u1,
                ///  EN_LPI
                EN_LPI: u1,
            }),
            ///  Interrupt status register
            ETH_DMAISR: mmio.Mmio(packed struct(u32) {
                ///  DMA Channel Interrupt Status
                DC0IS: u1,
                ///  DC1IS
                DC1IS: u1,
                reserved16: u14,
                ///  MTL Interrupt Status
                MTLIS: u1,
                ///  MAC Interrupt Status
                MACIS: u1,
                padding: u14,
            }),
            ///  Debug status register
            ETH_DMADSR: mmio.Mmio(packed struct(u32) {
                ///  AHB Master Write Channel
                AXWHSTS: u1,
                ///  AXRHSTS
                AXRHSTS: u1,
                reserved8: u6,
                ///  RPS0
                RPS0: u4,
                ///  TPS0
                TPS0: u4,
                ///  RPS1
                RPS1: u4,
                ///  TPS1
                TPS1: u4,
                padding: u8,
            }),
            reserved32: [16]u8,
            ///  AXI4 transmit channel ACE control register
            ETH_DMAA4TxACR: mmio.Mmio(packed struct(u32) {
                ///  TDRC
                TDRC: u4,
                reserved8: u4,
                ///  TEC
                TEC: u4,
                reserved16: u4,
                ///  THC
                THC: u4,
                padding: u12,
            }),
            ///  AXI4 receive channel ACE control register
            ETH_DMAA4RxACR: mmio.Mmio(packed struct(u32) {
                ///  RDWC
                RDWC: u4,
                reserved8: u4,
                ///  RPC
                RPC: u4,
                reserved16: u4,
                ///  RHC
                RHC: u4,
                reserved24: u4,
                ///  RDC
                RDC: u2,
                padding: u6,
            }),
            ///  AXI4 descriptor ACE control register
            ETH_DMAA4DACR: mmio.Mmio(packed struct(u32) {
                ///  TDWC
                TDWC: u4,
                ///  TDWD
                TDWD: u2,
                reserved8: u2,
                ///  RDRC
                RDRC: u4,
                reserved16: u4,
                ///  RDP
                RDP: u3,
                reserved20: u1,
                ///  WRP
                WRP: u3,
                padding: u9,
            }),
            reserved256: [212]u8,
            ///  Channel 0 control register
            ETH_DMAC0CR: mmio.Mmio(packed struct(u32) {
                ///  MSS
                MSS: u14,
                reserved16: u2,
                ///  PBLX8
                PBLX8: u1,
                reserved18: u1,
                ///  DSL
                DSL: u3,
                padding: u11,
            }),
            ///  Channel 0 transmit control register
            ETH_DMAC0TxCR: mmio.Mmio(packed struct(u32) {
                ///  ST
                ST: u1,
                ///  TCW
                TCW: u3,
                ///  OSF
                OSF: u1,
                reserved12: u7,
                ///  TSE
                TSE: u1,
                reserved16: u3,
                ///  TXPBL
                TXPBL: u6,
                reserved24: u2,
                ///  TQOS
                TQOS: u4,
                padding: u4,
            }),
            ///  Channel receive control register
            ETH_DMAC0RxCR: mmio.Mmio(packed struct(u32) {
                ///  Start or Stop Receive Command
                SR: u1,
                ///  Receive Buffer size
                RBSZ: u14,
                reserved16: u1,
                ///  RXPBL
                RXPBL: u6,
                reserved24: u2,
                ///  RQOS
                RQOS: u4,
                reserved31: u3,
                ///  DMA Rx Channel Packet Flush
                RPF: u1,
            }),
            reserved276: [8]u8,
            ///  Channel i Tx descriptor list address register
            ETH_DMAC0TxDLAR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Start of Transmit List
                TDESLA: u29,
            }),
            reserved284: [4]u8,
            ///  Channel Rx descriptor list address register
            ETH_DMAC0RxDLAR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Start of Receive List
                RDESLA: u29,
            }),
            ///  Channel Tx descriptor tail pointer register
            ETH_DMAC0TxDTPR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Transmit Descriptor Tail Pointer
                TDT: u29,
            }),
            reserved296: [4]u8,
            ///  Channel Rx descriptor tail pointer register
            ETH_DMAC0RxDTPR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Receive Descriptor Tail Pointer
                RDT: u29,
            }),
            ///  Channel Tx descriptor ring length register
            ETH_DMAC0TxRLR: mmio.Mmio(packed struct(u32) {
                ///  Transmit Descriptor Ring Length
                TDRL: u10,
                padding: u22,
            }),
            ///  Channel Rx descriptor ring length register
            ETH_DMAC0RxRLR: mmio.Mmio(packed struct(u32) {
                ///  Receive Descriptor Ring Length
                RDRL: u10,
                padding: u22,
            }),
            ///  Channel interrupt enable register
            ETH_DMAC0IER: mmio.Mmio(packed struct(u32) {
                ///  Transmit Interrupt Enable
                TIE: u1,
                ///  Transmit Stopped Enable
                TXSE: u1,
                ///  Transmit Buffer Unavailable Enable
                TBUE: u1,
                reserved6: u3,
                ///  Receive Interrupt Enable
                RIE: u1,
                ///  Receive Buffer Unavailable Enable
                RBUE: u1,
                ///  Receive Stopped Enable
                RSE: u1,
                ///  Receive Watchdog Timeout Enable
                RWTE: u1,
                ///  Early Transmit Interrupt Enable
                ETIE: u1,
                ///  Early Receive Interrupt Enable
                ERIE: u1,
                ///  Fatal Bus Error Enable
                FBEE: u1,
                ///  Context Descriptor Error Enable
                CDEE: u1,
                ///  Abnormal Interrupt Summary Enable
                AIE: u1,
                ///  Normal Interrupt Summary Enable
                NIE: u1,
                padding: u16,
            }),
            ///  Channel Rx interrupt watchdog timer register
            ETH_DMAC0RxIWTR: mmio.Mmio(packed struct(u32) {
                ///  Receive Interrupt Watchdog Timer Count
                RWT: u8,
                padding: u24,
            }),
            ///  Channel i slot function control status register
            ETH_DMAC0SFCSR: mmio.Mmio(packed struct(u32) {
                ///  ESC
                ESC: u1,
                ///  ASC
                ASC: u1,
                reserved16: u14,
                ///  RSN
                RSN: u4,
                padding: u12,
            }),
            reserved324: [4]u8,
            ///  Channel current application transmit descriptor register
            ETH_DMAC0CATxDR: mmio.Mmio(packed struct(u32) {
                ///  Application Transmit Descriptor Address Pointer
                CURTDESAPTR: u32,
            }),
            reserved332: [4]u8,
            ///  Channel 0 current application receive descriptor register
            ETH_DMAC0CARxDR: mmio.Mmio(packed struct(u32) {
                ///  Application Transmit Descriptor Address Pointer
                CURRDESAPTR: u32,
            }),
            reserved340: [4]u8,
            ///  Channel 0 current application transmit buffer register
            ETH_DMAC0CATxBR: mmio.Mmio(packed struct(u32) {
                ///  Application Transmit Buffer Address Pointer
                CURTBUFAPTR: u32,
            }),
            reserved348: [4]u8,
            ///  Channel current application receive buffer register
            ETH_DMAC0CARxBR: mmio.Mmio(packed struct(u32) {
                ///  Application Receive Buffer Address Pointer
                CURRBUFAPTR: u32,
            }),
            ///  Channel status register
            ETH_DMAC0SR: mmio.Mmio(packed struct(u32) {
                ///  Transmit Interrupt
                TI: u1,
                ///  Transmit Process Stopped
                TPS: u1,
                ///  Transmit Buffer Unavailable
                TBU: u1,
                reserved6: u3,
                ///  Receive Interrupt
                RI: u1,
                ///  Receive Buffer Unavailable
                RBU: u1,
                ///  Receive Process Stopped
                RPS: u1,
                ///  Receive Watchdog Timeout
                RWT: u1,
                ///  Early Transmit Interrupt
                ETI: u1,
                ///  Early Receive Interrupt
                ERI: u1,
                ///  Fatal Bus Error
                FBE: u1,
                ///  Context Descriptor Error
                CDE: u1,
                ///  Abnormal Interrupt Summary
                AIS: u1,
                ///  Normal Interrupt Summary
                NIS: u1,
                ///  Tx DMA Error Bits
                TEB: u3,
                ///  Rx DMA Error Bits
                REB: u3,
                padding: u10,
            }),
            reserved364: [8]u8,
            ///  Channel missed frame count register
            ETH_DMAC0MFCR: mmio.Mmio(packed struct(u32) {
                ///  Dropped Packet Counters
                MFC: u11,
                reserved15: u4,
                ///  Overflow status of the MFC Counter
                MFCO: u1,
                padding: u16,
            }),
            reserved384: [16]u8,
            ///  Channel 1 control register
            ETH_DMAC1CR: mmio.Mmio(packed struct(u32) {
                ///  MSS
                MSS: u14,
                reserved16: u2,
                ///  PBLX8
                PBLX8: u1,
                reserved18: u1,
                ///  DSL
                DSL: u3,
                padding: u11,
            }),
            ///  Channel 1 transmit control register
            ETH_DMAC1TxCR: mmio.Mmio(packed struct(u32) {
                ///  ST
                ST: u1,
                ///  TCW
                TCW: u3,
                ///  OSF
                OSF: u1,
                reserved12: u7,
                ///  TSE
                TSE: u1,
                reserved16: u3,
                ///  TXPBL
                TXPBL: u6,
                reserved24: u2,
                ///  TQOS
                TQOS: u4,
                padding: u4,
            }),
            reserved404: [12]u8,
            ///  Channel i Tx descriptor list address register
            ETH_DMAC1TxDLAR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Start of Transmit List
                TDESLA: u29,
            }),
            reserved416: [8]u8,
            ///  Channel Tx descriptor tail pointer register
            ETH_DMAC1TxDTPR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Transmit Descriptor Tail Pointer
                TDT: u29,
            }),
            reserved428: [8]u8,
            ///  Channel Tx descriptor ring length register
            ETH_DMAC1TxRLR: mmio.Mmio(packed struct(u32) {
                ///  Transmit Descriptor Ring Length
                TDRL: u10,
                padding: u22,
            }),
            reserved436: [4]u8,
            ///  Channel interrupt enable register
            ETH_DMAC1IER: mmio.Mmio(packed struct(u32) {
                ///  Transmit Interrupt Enable
                TIE: u1,
                ///  Transmit Stopped Enable
                TXSE: u1,
                ///  Transmit Buffer Unavailable Enable
                TBUE: u1,
                reserved6: u3,
                ///  Receive Interrupt Enable
                RIE: u1,
                ///  Receive Buffer Unavailable Enable
                RBUE: u1,
                ///  Receive Stopped Enable
                RSE: u1,
                ///  Receive Watchdog Timeout Enable
                RWTE: u1,
                ///  Early Transmit Interrupt Enable
                ETIE: u1,
                ///  Early Receive Interrupt Enable
                ERIE: u1,
                ///  Fatal Bus Error Enable
                FBEE: u1,
                ///  Context Descriptor Error Enable
                CDEE: u1,
                ///  Abnormal Interrupt Summary Enable
                AIE: u1,
                ///  Normal Interrupt Summary Enable
                NIE: u1,
                padding: u16,
            }),
            reserved444: [4]u8,
            ///  Channel i slot function control status register
            ETH_DMAC1SFCSR: mmio.Mmio(packed struct(u32) {
                ///  ESC
                ESC: u1,
                ///  ASC
                ASC: u1,
                reserved16: u14,
                ///  RSN
                RSN: u4,
                padding: u12,
            }),
            reserved452: [4]u8,
            ///  Channel current application transmit descriptor register
            ETH_DMAC1CATxDR: mmio.Mmio(packed struct(u32) {
                ///  Application Transmit Descriptor Address Pointer
                CURTDESAPTR: u32,
            }),
            reserved468: [12]u8,
            ///  Channel 0 current application transmit buffer register
            ETH_DMAC1CATxBR: mmio.Mmio(packed struct(u32) {
                ///  Application Transmit Buffer Address Pointer
                CURTBUFAPTR: u32,
            }),
            reserved480: [8]u8,
            ///  Channel status register
            ETH_DMAC1SR: mmio.Mmio(packed struct(u32) {
                ///  Transmit Interrupt
                TI: u1,
                ///  Transmit Process Stopped
                TPS: u1,
                ///  Transmit Buffer Unavailable
                TBU: u1,
                reserved6: u3,
                ///  Receive Interrupt
                RI: u1,
                ///  Receive Buffer Unavailable
                RBU: u1,
                ///  Receive Process Stopped
                RPS: u1,
                ///  Receive Watchdog Timeout
                RWT: u1,
                ///  Early Transmit Interrupt
                ETI: u1,
                ///  Early Receive Interrupt
                ERI: u1,
                ///  Fatal Bus Error
                FBE: u1,
                ///  Context Descriptor Error
                CDE: u1,
                ///  Abnormal Interrupt Summary
                AIS: u1,
                ///  Normal Interrupt Summary
                NIS: u1,
                ///  Tx DMA Error Bits
                TEB: u3,
                ///  Rx DMA Error Bits
                REB: u3,
                padding: u10,
            }),
            reserved492: [8]u8,
            ///  Channel missed frame count register
            ETH_DMAC1MFCR: mmio.Mmio(packed struct(u32) {
                ///  Dropped Packet Counters
                MFC: u11,
                reserved15: u4,
                ///  Overflow status of the MFC Counter
                MFCO: u1,
                padding: u16,
            }),
        };

        ///  ETZPC
        pub const ETZPC = extern struct {
            ///  ETZPC ROM secure size definition
            ETZPC_TZMA0_SIZE: mmio.Mmio(packed struct(u32) {
                ///  R0SIZE
                R0SIZE: u10,
                reserved31: u21,
                ///  LOCK
                LOCK: u1,
            }),
            ///  ETZPC RAM secure size definition
            ETZPC_TZMA1_SIZE: mmio.Mmio(packed struct(u32) {
                ///  R0SIZE
                R0SIZE: u10,
                reserved31: u21,
                ///  LOCK
                LOCK: u1,
            }),
            reserved16: [8]u8,
            ///  Register reset values
            ETZPC_DECPROT0: mmio.Mmio(packed struct(u32) {
                ///  DECPROT0
                DECPROT0: u2,
                ///  DECPROT1
                DECPROT1: u2,
                ///  DECPROT2
                DECPROT2: u2,
                ///  DECPROT3
                DECPROT3: u2,
                ///  DECPROT4
                DECPROT4: u2,
                ///  DECPROT5
                DECPROT5: u2,
                ///  DECPROT6
                DECPROT6: u2,
                ///  DECPROT7
                DECPROT7: u2,
                ///  DECPROT8
                DECPROT8: u2,
                ///  DECPROT9
                DECPROT9: u2,
                ///  DECPROT10
                DECPROT10: u2,
                ///  DECPROT11
                DECPROT11: u2,
                ///  DECPROT12
                DECPROT12: u2,
                ///  DECPROT13
                DECPROT13: u2,
                ///  DECPROT14
                DECPROT14: u2,
                ///  DECPROT15
                DECPROT15: u2,
            }),
            ///  Register reset values
            ETZPC_DECPROT1: mmio.Mmio(packed struct(u32) {
                ///  DECPROT0
                DECPROT0: u2,
                ///  DECPROT1
                DECPROT1: u2,
                ///  DECPROT2
                DECPROT2: u2,
                ///  DECPROT3
                DECPROT3: u2,
                ///  DECPROT4
                DECPROT4: u2,
                ///  DECPROT5
                DECPROT5: u2,
                ///  DECPROT6
                DECPROT6: u2,
                ///  DECPROT7
                DECPROT7: u2,
                ///  DECPROT8
                DECPROT8: u2,
                ///  DECPROT9
                DECPROT9: u2,
                ///  DECPROT10
                DECPROT10: u2,
                ///  DECPROT11
                DECPROT11: u2,
                ///  DECPROT12
                DECPROT12: u2,
                ///  DECPROT13
                DECPROT13: u2,
                ///  DECPROT14
                DECPROT14: u2,
                ///  DECPROT15
                DECPROT15: u2,
            }),
            ///  Register reset values
            ETZPC_DECPROT2: mmio.Mmio(packed struct(u32) {
                ///  DECPROT0
                DECPROT0: u2,
                ///  DECPROT1
                DECPROT1: u2,
                ///  DECPROT2
                DECPROT2: u2,
                ///  DECPROT3
                DECPROT3: u2,
                ///  DECPROT4
                DECPROT4: u2,
                ///  DECPROT5
                DECPROT5: u2,
                ///  DECPROT6
                DECPROT6: u2,
                ///  DECPROT7
                DECPROT7: u2,
                ///  DECPROT8
                DECPROT8: u2,
                ///  DECPROT9
                DECPROT9: u2,
                ///  DECPROT10
                DECPROT10: u2,
                ///  DECPROT11
                DECPROT11: u2,
                ///  DECPROT12
                DECPROT12: u2,
                ///  DECPROT13
                DECPROT13: u2,
                ///  DECPROT14
                DECPROT14: u2,
                ///  DECPROT15
                DECPROT15: u2,
            }),
            ///  Register reset values
            ETZPC_DECPROT3: mmio.Mmio(packed struct(u32) {
                ///  DECPROT0
                DECPROT0: u2,
                ///  DECPROT1
                DECPROT1: u2,
                ///  DECPROT2
                DECPROT2: u2,
                ///  DECPROT3
                DECPROT3: u2,
                ///  DECPROT4
                DECPROT4: u2,
                ///  DECPROT5
                DECPROT5: u2,
                ///  DECPROT6
                DECPROT6: u2,
                ///  DECPROT7
                DECPROT7: u2,
                ///  DECPROT8
                DECPROT8: u2,
                ///  DECPROT9
                DECPROT9: u2,
                ///  DECPROT10
                DECPROT10: u2,
                ///  DECPROT11
                DECPROT11: u2,
                ///  DECPROT12
                DECPROT12: u2,
                ///  DECPROT13
                DECPROT13: u2,
                ///  DECPROT14
                DECPROT14: u2,
                ///  DECPROT15
                DECPROT15: u2,
            }),
            ///  Register reset values
            ETZPC_DECPROT4: mmio.Mmio(packed struct(u32) {
                ///  DECPROT0
                DECPROT0: u2,
                ///  DECPROT1
                DECPROT1: u2,
                ///  DECPROT2
                DECPROT2: u2,
                ///  DECPROT3
                DECPROT3: u2,
                ///  DECPROT4
                DECPROT4: u2,
                ///  DECPROT5
                DECPROT5: u2,
                ///  DECPROT6
                DECPROT6: u2,
                ///  DECPROT7
                DECPROT7: u2,
                ///  DECPROT8
                DECPROT8: u2,
                ///  DECPROT9
                DECPROT9: u2,
                ///  DECPROT10
                DECPROT10: u2,
                ///  DECPROT11
                DECPROT11: u2,
                ///  DECPROT12
                DECPROT12: u2,
                ///  DECPROT13
                DECPROT13: u2,
                ///  DECPROT14
                DECPROT14: u2,
                ///  DECPROT15
                DECPROT15: u2,
            }),
            ///  Register reset values
            ETZPC_DECPROT5: mmio.Mmio(packed struct(u32) {
                ///  DECPROT0
                DECPROT0: u2,
                ///  DECPROT1
                DECPROT1: u2,
                ///  DECPROT2
                DECPROT2: u2,
                ///  DECPROT3
                DECPROT3: u2,
                ///  DECPROT4
                DECPROT4: u2,
                ///  DECPROT5
                DECPROT5: u2,
                ///  DECPROT6
                DECPROT6: u2,
                ///  DECPROT7
                DECPROT7: u2,
                ///  DECPROT8
                DECPROT8: u2,
                ///  DECPROT9
                DECPROT9: u2,
                ///  DECPROT10
                DECPROT10: u2,
                ///  DECPROT11
                DECPROT11: u2,
                ///  DECPROT12
                DECPROT12: u2,
                ///  DECPROT13
                DECPROT13: u2,
                ///  DECPROT14
                DECPROT14: u2,
                ///  DECPROT15
                DECPROT15: u2,
            }),
            reserved48: [8]u8,
            ///  ETZPC decprot lock 0 register
            ETZPC_DECPROT_LOCK0: mmio.Mmio(packed struct(u32) {
                ///  LOCK0
                LOCK0: u1,
                ///  LOCK1
                LOCK1: u1,
                ///  LOCK2
                LOCK2: u1,
                ///  LOCK3
                LOCK3: u1,
                ///  LOCK4
                LOCK4: u1,
                ///  LOCK5
                LOCK5: u1,
                ///  LOCK6
                LOCK6: u1,
                ///  LOCK7
                LOCK7: u1,
                ///  LOCK8
                LOCK8: u1,
                ///  LOCK9
                LOCK9: u1,
                ///  LOCK10
                LOCK10: u1,
                ///  LOCK11
                LOCK11: u1,
                ///  LOCK12
                LOCK12: u1,
                ///  LOCK13
                LOCK13: u1,
                ///  LOCK14
                LOCK14: u1,
                ///  LOCK15
                LOCK15: u1,
                ///  LOCK16
                LOCK16: u1,
                ///  LOCK17
                LOCK17: u1,
                ///  LOCK18
                LOCK18: u1,
                ///  LOCK19
                LOCK19: u1,
                ///  LOCK20
                LOCK20: u1,
                ///  LOCK21
                LOCK21: u1,
                ///  LOCK22
                LOCK22: u1,
                ///  LOCK23
                LOCK23: u1,
                ///  LOCK24
                LOCK24: u1,
                ///  LOCK25
                LOCK25: u1,
                ///  LOCK26
                LOCK26: u1,
                ///  LOCK27
                LOCK27: u1,
                ///  LOCK28
                LOCK28: u1,
                ///  LOCK29
                LOCK29: u1,
                ///  LOCK30
                LOCK30: u1,
                ///  LOCK31
                LOCK31: u1,
            }),
            ///  ETZPC decprot lock 1 register
            ETZPC_DECPROT_LOCK1: mmio.Mmio(packed struct(u32) {
                ///  LOCK0
                LOCK0: u1,
                ///  LOCK1
                LOCK1: u1,
                ///  LOCK2
                LOCK2: u1,
                ///  LOCK3
                LOCK3: u1,
                ///  LOCK4
                LOCK4: u1,
                ///  LOCK5
                LOCK5: u1,
                ///  LOCK6
                LOCK6: u1,
                ///  LOCK7
                LOCK7: u1,
                ///  LOCK8
                LOCK8: u1,
                ///  LOCK9
                LOCK9: u1,
                ///  LOCK10
                LOCK10: u1,
                ///  LOCK11
                LOCK11: u1,
                ///  LOCK12
                LOCK12: u1,
                ///  LOCK13
                LOCK13: u1,
                ///  LOCK14
                LOCK14: u1,
                ///  LOCK15
                LOCK15: u1,
                ///  LOCK16
                LOCK16: u1,
                ///  LOCK17
                LOCK17: u1,
                ///  LOCK18
                LOCK18: u1,
                ///  LOCK19
                LOCK19: u1,
                ///  LOCK20
                LOCK20: u1,
                ///  LOCK21
                LOCK21: u1,
                ///  LOCK22
                LOCK22: u1,
                ///  LOCK23
                LOCK23: u1,
                ///  LOCK24
                LOCK24: u1,
                ///  LOCK25
                LOCK25: u1,
                ///  LOCK26
                LOCK26: u1,
                ///  LOCK27
                LOCK27: u1,
                ///  LOCK28
                LOCK28: u1,
                ///  LOCK29
                LOCK29: u1,
                ///  LOCK30
                LOCK30: u1,
                ///  LOCK31
                LOCK31: u1,
            }),
            ///  ETZPC decprot lock 2 register
            ETZPC_DECPROT_LOCK2: mmio.Mmio(packed struct(u32) {
                ///  LOCK0
                LOCK0: u1,
                ///  LOCK1
                LOCK1: u1,
                ///  LOCK2
                LOCK2: u1,
                ///  LOCK3
                LOCK3: u1,
                ///  LOCK4
                LOCK4: u1,
                ///  LOCK5
                LOCK5: u1,
                ///  LOCK6
                LOCK6: u1,
                ///  LOCK7
                LOCK7: u1,
                ///  LOCK8
                LOCK8: u1,
                ///  LOCK9
                LOCK9: u1,
                ///  LOCK10
                LOCK10: u1,
                ///  LOCK11
                LOCK11: u1,
                ///  LOCK12
                LOCK12: u1,
                ///  LOCK13
                LOCK13: u1,
                ///  LOCK14
                LOCK14: u1,
                ///  LOCK15
                LOCK15: u1,
                ///  LOCK16
                LOCK16: u1,
                ///  LOCK17
                LOCK17: u1,
                ///  LOCK18
                LOCK18: u1,
                ///  LOCK19
                LOCK19: u1,
                ///  LOCK20
                LOCK20: u1,
                ///  LOCK21
                LOCK21: u1,
                ///  LOCK22
                LOCK22: u1,
                ///  LOCK23
                LOCK23: u1,
                ///  LOCK24
                LOCK24: u1,
                ///  LOCK25
                LOCK25: u1,
                ///  LOCK26
                LOCK26: u1,
                ///  LOCK27
                LOCK27: u1,
                ///  LOCK28
                LOCK28: u1,
                ///  LOCK29
                LOCK29: u1,
                ///  LOCK30
                LOCK30: u1,
                ///  LOCK31
                LOCK31: u1,
            }),
            reserved1008: [948]u8,
            ///  ETZPC IP HW configuration register
            ETZPC_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  NUM_TZMA
                NUM_TZMA: u8,
                ///  NUM_PER_SEC
                NUM_PER_SEC: u8,
                ///  NUM_AHB_SEC
                NUM_AHB_SEC: u8,
                ///  CHUNKS1N4
                CHUNKS1N4: u8,
            }),
            ///  ETZPC IP version register
            ETZPC_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  ETZPC IP version register
            ETZPC_IDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  ETZPC IP version register
            ETZPC_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  EXTI
        pub const EXTI = extern struct {
            ///  Contains only register bits for configurable events.
            EXTI_RTSR1: mmio.Mmio(packed struct(u32) {
                ///  RT0
                RT0: u1,
                ///  RT1
                RT1: u1,
                ///  RT2
                RT2: u1,
                ///  RT3
                RT3: u1,
                ///  RT4
                RT4: u1,
                ///  RT5
                RT5: u1,
                ///  RT6
                RT6: u1,
                ///  RT7
                RT7: u1,
                ///  RT8
                RT8: u1,
                ///  RT9
                RT9: u1,
                ///  RT10
                RT10: u1,
                ///  RT11
                RT11: u1,
                ///  RT12
                RT12: u1,
                ///  RT13
                RT13: u1,
                ///  RT14
                RT14: u1,
                ///  RT15
                RT15: u1,
                ///  RT16
                RT16: u1,
                padding: u15,
            }),
            ///  Contains only register bits for configurable events.
            EXTI_FTSR1: mmio.Mmio(packed struct(u32) {
                ///  FT0
                FT0: u1,
                ///  FT1
                FT1: u1,
                ///  FT2
                FT2: u1,
                ///  FT3
                FT3: u1,
                ///  FT4
                FT4: u1,
                ///  FT5
                FT5: u1,
                ///  FT6
                FT6: u1,
                ///  FT7
                FT7: u1,
                ///  FT8
                FT8: u1,
                ///  FT9
                FT9: u1,
                ///  FT10
                FT10: u1,
                ///  FT11
                FT11: u1,
                ///  FT12
                FT12: u1,
                ///  FT13
                FT13: u1,
                ///  FT14
                FT14: u1,
                ///  FT15
                FT15: u1,
                ///  FT16
                FT16: u1,
                padding: u15,
            }),
            ///  Contains only register bits for configurable events.
            EXTI_SWIER1: mmio.Mmio(packed struct(u32) {
                ///  SWI0
                SWI0: u1,
                ///  SWI1
                SWI1: u1,
                ///  SWI2
                SWI2: u1,
                ///  SWI3
                SWI3: u1,
                ///  SWI4
                SWI4: u1,
                ///  SWI5
                SWI5: u1,
                ///  SWI6
                SWI6: u1,
                ///  SWI7
                SWI7: u1,
                ///  SWI8
                SWI8: u1,
                ///  SWI9
                SWI9: u1,
                ///  SWI10
                SWI10: u1,
                ///  SWI11
                SWI11: u1,
                ///  SWI12
                SWI12: u1,
                ///  SWI13
                SWI13: u1,
                ///  SWI14
                SWI14: u1,
                ///  SWI15
                SWI15: u1,
                ///  SWI16
                SWI16: u1,
                padding: u15,
            }),
            ///  Contains only register bits for configurable events.
            EXTI_RPR1: mmio.Mmio(packed struct(u32) {
                ///  RPIF0
                RPIF0: u1,
                ///  RPIF1
                RPIF1: u1,
                ///  RPIF2
                RPIF2: u1,
                ///  RPIF3
                RPIF3: u1,
                ///  RPIF4
                RPIF4: u1,
                ///  RPIF5
                RPIF5: u1,
                ///  RPIF6
                RPIF6: u1,
                ///  RPIF7
                RPIF7: u1,
                ///  RPIF8
                RPIF8: u1,
                ///  RPIF9
                RPIF9: u1,
                ///  RPIF10
                RPIF10: u1,
                ///  RPIF11
                RPIF11: u1,
                ///  RPIF12
                RPIF12: u1,
                ///  RPIF13
                RPIF13: u1,
                ///  RPIF14
                RPIF14: u1,
                ///  RPIF15
                RPIF15: u1,
                ///  RPIF16
                RPIF16: u1,
                padding: u15,
            }),
            ///  Contains only register bits for configurable events.
            EXTI_FPR1: mmio.Mmio(packed struct(u32) {
                ///  FPIF0
                FPIF0: u1,
                ///  FPIF1
                FPIF1: u1,
                ///  FPIF2
                FPIF2: u1,
                ///  FPIF3
                FPIF3: u1,
                ///  FPIF4
                FPIF4: u1,
                ///  FPIF5
                FPIF5: u1,
                ///  FPIF6
                FPIF6: u1,
                ///  FPIF7
                FPIF7: u1,
                ///  FPIF8
                FPIF8: u1,
                ///  FPIF9
                FPIF9: u1,
                ///  FPIF10
                FPIF10: u1,
                ///  FPIF11
                FPIF11: u1,
                ///  FPIF12
                FPIF12: u1,
                ///  FPIF13
                FPIF13: u1,
                ///  FPIF14
                FPIF14: u1,
                ///  FPIF15
                FPIF15: u1,
                ///  FPIF16
                FPIF16: u1,
                padding: u15,
            }),
            ///  This register provides TrustZone Write access security, a non-secure write access will generate a bus error. A non-secure read will return the register data. Contains only register bits for TrustZone capable Input events.
            EXTI_TZENR1: mmio.Mmio(packed struct(u32) {
                ///  TZEN0
                TZEN0: u1,
                ///  TZEN1
                TZEN1: u1,
                ///  TZEN2
                TZEN2: u1,
                ///  TZEN3
                TZEN3: u1,
                ///  TZEN4
                TZEN4: u1,
                ///  TZEN5
                TZEN5: u1,
                ///  TZEN6
                TZEN6: u1,
                ///  TZEN7
                TZEN7: u1,
                ///  TZEN8
                TZEN8: u1,
                ///  TZEN9
                TZEN9: u1,
                ///  TZEN10
                TZEN10: u1,
                ///  TZEN11
                TZEN11: u1,
                ///  TZEN12
                TZEN12: u1,
                ///  TZEN13
                TZEN13: u1,
                ///  TZEN14
                TZEN14: u1,
                ///  TZEN15
                TZEN15: u1,
                reserved17: u1,
                ///  TZEN17
                TZEN17: u1,
                ///  TZEN18
                TZEN18: u1,
                ///  TZEN19
                TZEN19: u1,
                reserved24: u4,
                ///  TZEN24
                TZEN24: u1,
                reserved26: u1,
                ///  TZEN26
                TZEN26: u1,
                padding: u5,
            }),
            reserved32: [8]u8,
            ///  Contains only register bits for configurable events.
            EXTI_RTSR2: u32,
            ///  Contains only register bits for configurable events.
            EXTI_FTSR2: u32,
            ///  Contains only register bits for configurable events.
            EXTI_SWIER2: u32,
            ///  Contains only register bits for configurable events.
            EXTI_RPR2: u32,
            ///  Contains only register bits for configurable events.
            EXTI_FPR2: u32,
            ///  This register provides TrustZone Write access security, a non-secure write access will generate a bus error. A non-secure read will return the register data. Contains only register bits for TrustZone capable Input events.
            EXTI_TZENR2: mmio.Mmio(packed struct(u32) {
                reserved9: u9,
                ///  TZEN41
                TZEN41: u1,
                reserved22: u12,
                ///  TZEN54
                TZEN54: u1,
                ///  TZEN55
                TZEN55: u1,
                ///  TZEN56
                TZEN56: u1,
                ///  TZEN57
                TZEN57: u1,
                ///  TZEN58
                TZEN58: u1,
                ///  TZEN59
                TZEN59: u1,
                ///  TZEN60
                TZEN60: u1,
                padding: u3,
            }),
            reserved64: [8]u8,
            ///  Contains only register bits for configurable events.
            EXTI_RTSR3: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  RT65
                RT65: u1,
                ///  RT66
                RT66: u1,
                reserved4: u1,
                ///  RT68
                RT68: u1,
                reserved9: u4,
                ///  RT73
                RT73: u1,
                ///  RT74
                RT74: u1,
                padding: u21,
            }),
            ///  Contains only register bits for configurable events.
            EXTI_FTSR3: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  FT65
                FT65: u1,
                ///  FT66
                FT66: u1,
                reserved4: u1,
                ///  FT68
                FT68: u1,
                reserved9: u4,
                ///  FT73
                FT73: u1,
                ///  FT74
                FT74: u1,
                padding: u21,
            }),
            ///  Contains only register bits for configurable events.
            EXTI_SWIER3: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  SWI65
                SWI65: u1,
                ///  SWI66
                SWI66: u1,
                reserved4: u1,
                ///  SWI68
                SWI68: u1,
                reserved9: u4,
                ///  SWI73
                SWI73: u1,
                ///  SWI74
                SWI74: u1,
                padding: u21,
            }),
            ///  Contains only register bits for configurable events.
            EXTI_RPR3: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  RPIF65
                RPIF65: u1,
                ///  RPIF66
                RPIF66: u1,
                reserved4: u1,
                ///  RPIF68
                RPIF68: u1,
                reserved9: u4,
                ///  RPIF73
                RPIF73: u1,
                ///  RPIF74
                RPIF74: u1,
                padding: u21,
            }),
            ///  Contains only register bits for configurable events.
            EXTI_FPR3: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  FPIF65
                FPIF65: u1,
                ///  FPIF66
                FPIF66: u1,
                reserved4: u1,
                ///  FPIF68
                FPIF68: u1,
                reserved9: u4,
                ///  FPIF73
                FPIF73: u1,
                ///  FPIF74
                FPIF74: u1,
                padding: u21,
            }),
            ///  This register provides TrustZone Write access security, a non-secure write access will generate a bus error. A non-secure read will return the register data. Contains only register bits for TrustZone capable Input events.
            EXTI_TZENR3: u32,
            reserved96: [8]u8,
            ///  EXTIm fields contain only the number of bits in line with the nb_ioport configuration.
            EXTI_EXTICR1: mmio.Mmio(packed struct(u32) {
                ///  EXTI0
                EXTI0: u8,
                ///  EXTI1
                EXTI1: u8,
                ///  EXTI2
                EXTI2: u8,
                ///  EXTI3
                EXTI3: u8,
            }),
            ///  EXTIm fields contain only the number of bits in line with the nb_ioport configuration.
            EXTI_EXTICR2: mmio.Mmio(packed struct(u32) {
                ///  EXTI4
                EXTI4: u8,
                ///  EXTI5
                EXTI5: u8,
                ///  EXTI6
                EXTI6: u8,
                ///  EXTI7
                EXTI7: u8,
            }),
            ///  EXTIm fields contain only the number of bits in line with the nb_ioport configuration.
            EXTI_EXTICR3: mmio.Mmio(packed struct(u32) {
                ///  EXTI8
                EXTI8: u8,
                ///  EXTI9
                EXTI9: u8,
                ///  EXTI10
                EXTI10: u8,
                ///  EXTI11
                EXTI11: u8,
            }),
            ///  EXTIm fields contain only the number of bits in line with the nb_ioport configuration.
            EXTI_EXTICR4: mmio.Mmio(packed struct(u32) {
                ///  EXTI12
                EXTI12: u8,
                ///  EXTI13
                EXTI13: u8,
                ///  EXTI14
                EXTI14: u8,
                ///  EXTI15
                EXTI15: u8,
            }),
            reserved128: [16]u8,
            ///  Contains register bits for configurable events and Direct events.
            EXTI_IMR1: mmio.Mmio(packed struct(u32) {
                ///  IM0
                IM0: u1,
                ///  IM1
                IM1: u1,
                ///  IM2
                IM2: u1,
                ///  IM3
                IM3: u1,
                ///  IM4
                IM4: u1,
                ///  IM5
                IM5: u1,
                ///  IM6
                IM6: u1,
                ///  IM7
                IM7: u1,
                ///  IM8
                IM8: u1,
                ///  IM9
                IM9: u1,
                ///  IM10
                IM10: u1,
                ///  IM11
                IM11: u1,
                ///  IM12
                IM12: u1,
                ///  IM13
                IM13: u1,
                ///  IM14
                IM14: u1,
                ///  IM15
                IM15: u1,
                ///  IM16
                IM16: u1,
                ///  IM17
                IM17: u1,
                ///  IM18
                IM18: u1,
                ///  IM19
                IM19: u1,
                ///  IM20
                IM20: u1,
                ///  IM21
                IM21: u1,
                ///  IM22
                IM22: u1,
                ///  IM23
                IM23: u1,
                ///  IM24
                IM24: u1,
                ///  IM25
                IM25: u1,
                ///  IM26
                IM26: u1,
                ///  IM27
                IM27: u1,
                ///  IM28
                IM28: u1,
                ///  IM29
                IM29: u1,
                ///  IM30
                IM30: u1,
                ///  IM31
                IM31: u1,
            }),
            ///  EXTI CPU wakeup with event mask register
            EXTI_EMR1: mmio.Mmio(packed struct(u32) {
                ///  EM0
                EM0: u1,
                ///  EM1
                EM1: u1,
                ///  EM2
                EM2: u1,
                ///  EM3
                EM3: u1,
                ///  EM4
                EM4: u1,
                ///  EM5
                EM5: u1,
                ///  EM6
                EM6: u1,
                ///  EM7
                EM7: u1,
                ///  EM8
                EM8: u1,
                ///  EM9
                EM9: u1,
                ///  EM10
                EM10: u1,
                ///  EM11
                EM11: u1,
                ///  EM12
                EM12: u1,
                ///  EM13
                EM13: u1,
                ///  EM14
                EM14: u1,
                ///  EM15
                EM15: u1,
                reserved17: u1,
                ///  EM17
                EM17: u1,
                ///  EM18
                EM18: u1,
                ///  EM19
                EM19: u1,
                padding: u12,
            }),
            reserved144: [8]u8,
            ///  Contains register bits for configurable events and direct events.
            EXTI_IMR2: mmio.Mmio(packed struct(u32) {
                ///  IM32
                IM32: u1,
                ///  IM33
                IM33: u1,
                ///  IM34
                IM34: u1,
                ///  IM35
                IM35: u1,
                ///  IM36
                IM36: u1,
                ///  IM37
                IM37: u1,
                ///  IM38
                IM38: u1,
                ///  IM39
                IM39: u1,
                ///  IM40
                IM40: u1,
                ///  IM41
                IM41: u1,
                ///  IM42
                IM42: u1,
                ///  IM43
                IM43: u1,
                ///  IM44
                IM44: u1,
                ///  IM45
                IM45: u1,
                ///  IM46
                IM46: u1,
                ///  IM47
                IM47: u1,
                ///  IM48
                IM48: u1,
                ///  IM49
                IM49: u1,
                ///  IM50
                IM50: u1,
                ///  IM51
                IM51: u1,
                ///  IM52
                IM52: u1,
                ///  IM53
                IM53: u1,
                ///  IM54
                IM54: u1,
                ///  IM55
                IM55: u1,
                ///  IM56
                IM56: u1,
                ///  IM57
                IM57: u1,
                ///  IM58
                IM58: u1,
                ///  IM59
                IM59: u1,
                ///  IM60
                IM60: u1,
                ///  IM61
                IM61: u1,
                ///  IM62
                IM62: u1,
                ///  IM63
                IM63: u1,
            }),
            ///  EXTI CPU wakeup with event mask register
            EXTI_EMR2: u32,
            reserved160: [8]u8,
            ///  Contains register bits for configurable events and direct events.
            EXTI_IMR3: mmio.Mmio(packed struct(u32) {
                ///  IM64
                IM64: u1,
                ///  IM65
                IM65: u1,
                ///  IM66
                IM66: u1,
                ///  IM67
                IM67: u1,
                ///  IM68
                IM68: u1,
                ///  IM69
                IM69: u1,
                ///  IM70
                IM70: u1,
                ///  IM71
                IM71: u1,
                ///  IM72
                IM72: u1,
                ///  IM73
                IM73: u1,
                ///  IM74
                IM74: u1,
                ///  IM75
                IM75: u1,
                padding: u20,
            }),
            ///  EXTI CPU wakeup with event mask register
            EXTI_EMR3: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  EM66
                EM66: u1,
                padding: u29,
            }),
            reserved192: [24]u8,
            ///  Contains register bits for configurable events and Direct events.
            EXTI_C2IMR1: mmio.Mmio(packed struct(u32) {
                ///  IM0
                IM0: u1,
                ///  IM1
                IM1: u1,
                ///  IM2
                IM2: u1,
                ///  IM3
                IM3: u1,
                ///  IM4
                IM4: u1,
                ///  IM5
                IM5: u1,
                ///  IM6
                IM6: u1,
                ///  IM7
                IM7: u1,
                ///  IM8
                IM8: u1,
                ///  IM9
                IM9: u1,
                ///  IM10
                IM10: u1,
                ///  IM11
                IM11: u1,
                ///  IM12
                IM12: u1,
                ///  IM13
                IM13: u1,
                ///  IM14
                IM14: u1,
                ///  IM15
                IM15: u1,
                ///  IM16
                IM16: u1,
                ///  IM17
                IM17: u1,
                ///  IM18
                IM18: u1,
                ///  IM19
                IM19: u1,
                ///  IM20
                IM20: u1,
                ///  IM21
                IM21: u1,
                ///  IM22
                IM22: u1,
                ///  IM23
                IM23: u1,
                ///  IM24
                IM24: u1,
                ///  IM25
                IM25: u1,
                ///  IM26
                IM26: u1,
                ///  IM27
                IM27: u1,
                ///  IM28
                IM28: u1,
                ///  IM29
                IM29: u1,
                ///  IM30
                IM30: u1,
                ///  IM31
                IM31: u1,
            }),
            ///  EXTI CPU2 wakeup with event mask register
            EXTI_C2EMR1: mmio.Mmio(packed struct(u32) {
                ///  EM0
                EM0: u1,
                ///  EM1
                EM1: u1,
                ///  EM2
                EM2: u1,
                ///  EM3
                EM3: u1,
                ///  EM4
                EM4: u1,
                ///  EM5
                EM5: u1,
                ///  EM6
                EM6: u1,
                ///  EM7
                EM7: u1,
                ///  EM8
                EM8: u1,
                ///  EM9
                EM9: u1,
                ///  EM10
                EM10: u1,
                ///  EM11
                EM11: u1,
                ///  EM12
                EM12: u1,
                ///  EM13
                EM13: u1,
                ///  EM14
                EM14: u1,
                ///  EM15
                EM15: u1,
                reserved17: u1,
                ///  EM17
                EM17: u1,
                ///  EM18
                EM18: u1,
                ///  EM19
                EM19: u1,
                padding: u12,
            }),
            reserved208: [8]u8,
            ///  Contains register bits for configurable events and direct events.
            EXTI_C2IMR2: mmio.Mmio(packed struct(u32) {
                ///  IM32
                IM32: u1,
                ///  IM33
                IM33: u1,
                ///  IM34
                IM34: u1,
                ///  IM35
                IM35: u1,
                ///  IM36
                IM36: u1,
                ///  IM37
                IM37: u1,
                ///  IM38
                IM38: u1,
                ///  IM39
                IM39: u1,
                ///  IM40
                IM40: u1,
                ///  IM41
                IM41: u1,
                ///  IM42
                IM42: u1,
                ///  IM43
                IM43: u1,
                ///  IM44
                IM44: u1,
                ///  IM45
                IM45: u1,
                ///  IM46
                IM46: u1,
                ///  IM47
                IM47: u1,
                ///  IM48
                IM48: u1,
                ///  IM49
                IM49: u1,
                ///  IM50
                IM50: u1,
                ///  IM51
                IM51: u1,
                ///  IM52
                IM52: u1,
                ///  IM53
                IM53: u1,
                ///  IM54
                IM54: u1,
                ///  IM55
                IM55: u1,
                ///  IM56
                IM56: u1,
                ///  IM57
                IM57: u1,
                ///  IM58
                IM58: u1,
                ///  IM59
                IM59: u1,
                ///  IM60
                IM60: u1,
                ///  IM61
                IM61: u1,
                ///  IM62
                IM62: u1,
                ///  IM63
                IM63: u1,
            }),
            ///  EXTI CPU2 wakeup with event mask register
            EXTI_C2EMR2: u32,
            reserved224: [8]u8,
            ///  Contains register bits for configurable events and direct events.
            EXTI_C2IMR3: mmio.Mmio(packed struct(u32) {
                ///  IM64
                IM64: u1,
                ///  IM65
                IM65: u1,
                ///  IM66
                IM66: u1,
                ///  IM67
                IM67: u1,
                ///  IM68
                IM68: u1,
                ///  IM69
                IM69: u1,
                ///  IM70
                IM70: u1,
                ///  IM71
                IM71: u1,
                ///  IM72
                IM72: u1,
                ///  IM73
                IM73: u1,
                ///  IM74
                IM74: u1,
                ///  IM75
                IM75: u1,
                padding: u20,
            }),
            ///  EXTI CPU2 wakeup with event mask register
            EXTI_C2EMR3: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  EM66
                EM66: u1,
                padding: u29,
            }),
            reserved960: [728]u8,
            ///  EXTI hardware configuration register 13
            EXTI_HWCFGR13: mmio.Mmio(packed struct(u32) {
                ///  TZ
                TZ: u32,
            }),
            ///  EXTI hardware configuration register 12
            EXTI_HWCFGR12: mmio.Mmio(packed struct(u32) {
                ///  TZ
                TZ: u32,
            }),
            ///  EXTI hardware configuration register 11
            EXTI_HWCFGR11: mmio.Mmio(packed struct(u32) {
                ///  TZ
                TZ: u32,
            }),
            ///  EXTI hardware configuration register 10
            EXTI_HWCFGR10: u32,
            ///  EXTI hardware configuration register 9
            EXTI_HWCFGR9: u32,
            ///  EXTI hardware configuration register 8
            EXTI_HWCFGR8: u32,
            ///  EXTI hardware configuration register 7
            EXTI_HWCFGR7: mmio.Mmio(packed struct(u32) {
                ///  CPUEVENT
                CPUEVENT: u32,
            }),
            ///  EXTI hardware configuration register 6
            EXTI_HWCFGR6: mmio.Mmio(packed struct(u32) {
                ///  CPUEVENT
                CPUEVENT: u32,
            }),
            ///  EXTI hardware configuration register 5
            EXTI_HWCFGR5: mmio.Mmio(packed struct(u32) {
                ///  CPUEVENT
                CPUEVENT: u32,
            }),
            ///  EXTI hardware configuration register 4
            EXTI_HWCFGR4: mmio.Mmio(packed struct(u32) {
                ///  EVENT_TRG
                EVENT_TRG: u32,
            }),
            ///  EXTI hardware configuration register 3
            EXTI_HWCFGR3: mmio.Mmio(packed struct(u32) {
                ///  EVENT_TRG
                EVENT_TRG: u32,
            }),
            ///  EXTI hardware configuration register 2
            EXTI_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  EVENT_TRG
                EVENT_TRG: u32,
            }),
            ///  EXTI hardware configuration register 1
            EXTI_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  NBEVENTS
                NBEVENTS: u8,
                ///  NBCPUS
                NBCPUS: u4,
                ///  CPUEVTEN
                CPUEVTEN: u4,
                ///  NBIOPORT
                NBIOPORT: u8,
                padding: u8,
            }),
            ///  EXTI IP version register
            EXTI_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  EXTI identification register
            EXTI_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  IPID
                IPID: u32,
            }),
            ///  EXTI size ID register
            EXTI_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  FDCAN1
        pub const FDCAN1 = extern struct {
            ///  FDCAN core release register
            FDCAN_CREL: mmio.Mmio(packed struct(u32) {
                ///  DAY
                DAY: u8,
                ///  MON
                MON: u8,
                ///  YEAR
                YEAR: u4,
                ///  SUBSTEP
                SUBSTEP: u4,
                ///  STEP
                STEP: u4,
                ///  REL
                REL: u4,
            }),
            ///  FDCAN Endian register
            FDCAN_ENDN: mmio.Mmio(packed struct(u32) {
                ///  ETV
                ETV: u32,
            }),
            reserved12: [4]u8,
            ///  This register is dedicated to data bit timing phase and only writable if bits FDCAN_CCCR.CCE and FDCAN_CCCR.INIT are set. The CAN time quantum may be programmed in the range from 1 to 32 FDCAN clock periods. tq = (DBRP + 1) FDCAN clock periods. DTSEG1 is the sum of Prop_Seg and Phase_Seg1. DTSEG2 is Phase_Seg2. Therefore the length of the bit time is (DTSEG1 + DTSEG2 + 3) tq for programmed values, or (Sync_Seg+Prop_Seg+Phase_Seg1+Phase_Seg2) tq for functional values. The information processing time (IPT) is zero, meaning the data for the next bit is available at the first clock edge after the sample point.
            FDCAN_DBTP: mmio.Mmio(packed struct(u32) {
                ///  DSJW
                DSJW: u4,
                ///  DTSEG2
                DTSEG2: u4,
                ///  DTSEG1
                DTSEG1: u5,
                reserved16: u3,
                ///  DBRP
                DBRP: u5,
                reserved23: u2,
                ///  TDC
                TDC: u1,
                padding: u8,
            }),
            ///  Write access to this register has to be enabled by setting bit FDCAN_CCCR.TEST to 1. All register functions are set to their reset values when bit FDCAN_CCCR.TEST is reset. Loop back mode and software control of Tx pin FDCANx_TX are hardware test modes. Programming TX differently from 00 may disturb the message transfer on the CAN bus.
            FDCAN_TEST: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  LBCK
                LBCK: u1,
                ///  TX
                TX: u2,
                ///  RX
                RX: u1,
                padding: u24,
            }),
            ///  The RAM watchdog monitors the READY output of the message RAM. A message RAM access starts the message RAM watchdog counter with the value configured by the FDCAN_RWD.WDC bits. The counter is reloaded with FDCAN_RWD.WDC bits when the message RAM signals successful completion by activating its READY output. In case there is no response from the message RAM until the counter has counted down to 0, the counter stops and interrupt flag FDCAN_IR.WDI bit is set. The RAM watchdog counter is clocked by the fdcan_pclk clock.
            FDCAN_RWD: mmio.Mmio(packed struct(u32) {
                ///  WDC
                WDC: u8,
                ///  WDV
                WDV: u8,
                padding: u16,
            }),
            ///  For details about setting and resetting of single bits see Software initialization.
            FDCAN_CCCR: mmio.Mmio(packed struct(u32) {
                ///  INIT
                INIT: u1,
                ///  CCE
                CCE: u1,
                ///  ASM
                ASM: u1,
                ///  CSA
                CSA: u1,
                ///  CSR
                CSR: u1,
                ///  MON
                MON: u1,
                ///  DAR
                DAR: u1,
                ///  TEST
                TEST: u1,
                ///  FDOE
                FDOE: u1,
                ///  BRSE
                BRSE: u1,
                reserved12: u2,
                ///  PXHD
                PXHD: u1,
                ///  EFBI
                EFBI: u1,
                ///  TXP
                TXP: u1,
                ///  NISO
                NISO: u1,
                padding: u16,
            }),
            ///  This register is dedicated to the nominal bit timing used during the arbitration phase.
            FDCAN_NBTP: mmio.Mmio(packed struct(u32) {
                ///  NTSEG2
                NTSEG2: u7,
                reserved8: u1,
                ///  NTSEG1
                NTSEG1: u8,
                ///  NBRP
                NBRP: u9,
                ///  NSJW
                NSJW: u7,
            }),
            ///  FDCAN timestamp counter configuration register
            FDCAN_TSCC: mmio.Mmio(packed struct(u32) {
                ///  TSS
                TSS: u2,
                reserved16: u14,
                ///  TCP
                TCP: u4,
                padding: u12,
            }),
            ///  FDCAN timestamp counter value register
            FDCAN_TSCV: mmio.Mmio(packed struct(u32) {
                ///  TSC
                TSC: u16,
                padding: u16,
            }),
            ///  FDCAN timeout counter configuration register
            FDCAN_TOCC: mmio.Mmio(packed struct(u32) {
                ///  ETOC
                ETOC: u1,
                ///  TOS
                TOS: u2,
                reserved16: u13,
                ///  TOP
                TOP: u16,
            }),
            ///  FDCAN timeout counter value register
            FDCAN_TOCV: mmio.Mmio(packed struct(u32) {
                ///  TOC
                TOC: u16,
                padding: u16,
            }),
            reserved64: [16]u8,
            ///  FDCAN error counter register
            FDCAN_ECR: mmio.Mmio(packed struct(u32) {
                ///  TEC
                TEC: u8,
                ///  TREC
                TREC: u7,
                ///  RP
                RP: u1,
                ///  CEL
                CEL: u8,
                padding: u8,
            }),
            ///  FDCAN protocol status register
            FDCAN_PSR: mmio.Mmio(packed struct(u32) {
                ///  LEC
                LEC: u3,
                ///  ACT
                ACT: u2,
                ///  EP
                EP: u1,
                ///  EW
                EW: u1,
                ///  BO
                BO: u1,
                ///  DLEC
                DLEC: u3,
                ///  RESI
                RESI: u1,
                ///  RBRS
                RBRS: u1,
                ///  REDL
                REDL: u1,
                ///  PXE
                PXE: u1,
                reserved16: u1,
                ///  TDCV
                TDCV: u7,
                padding: u9,
            }),
            ///  FDCAN transmitter delay compensation register
            FDCAN_TDCR: mmio.Mmio(packed struct(u32) {
                ///  TDCF
                TDCF: u7,
                reserved8: u1,
                ///  TDCO
                TDCO: u7,
                padding: u17,
            }),
            reserved80: [4]u8,
            ///  The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the register. The configuration of IE controls whether an interrupt is generated. The configuration of ILS controls on which interrupt line an interrupt is signaled.
            FDCAN_IR: mmio.Mmio(packed struct(u32) {
                ///  RF0N
                RF0N: u1,
                ///  RF0W
                RF0W: u1,
                ///  RF0F
                RF0F: u1,
                ///  RF0L
                RF0L: u1,
                ///  RF1N
                RF1N: u1,
                ///  RF1W
                RF1W: u1,
                ///  RF1F
                RF1F: u1,
                ///  RF1L
                RF1L: u1,
                ///  HPM
                HPM: u1,
                ///  TC
                TC: u1,
                ///  TCF
                TCF: u1,
                ///  TFE
                TFE: u1,
                ///  TEFN
                TEFN: u1,
                ///  TEFW
                TEFW: u1,
                ///  TEFF
                TEFF: u1,
                ///  TEFL
                TEFL: u1,
                ///  TSW
                TSW: u1,
                ///  MRAF
                MRAF: u1,
                ///  TOO
                TOO: u1,
                ///  DRX
                DRX: u1,
                reserved22: u2,
                ///  ELO
                ELO: u1,
                ///  EP
                EP: u1,
                ///  EW
                EW: u1,
                ///  BO
                BO: u1,
                ///  WDI
                WDI: u1,
                ///  PEA
                PEA: u1,
                ///  PED
                PED: u1,
                ///  ARA
                ARA: u1,
                padding: u2,
            }),
            ///  The settings in the interrupt enable register determine which status changes in the interrupt register will be signaled on an interrupt line.
            FDCAN_IE: mmio.Mmio(packed struct(u32) {
                ///  RF0NE
                RF0NE: u1,
                ///  RF0WE
                RF0WE: u1,
                ///  RF0FE
                RF0FE: u1,
                ///  RF0LE
                RF0LE: u1,
                ///  RF1NE
                RF1NE: u1,
                ///  RF1WE
                RF1WE: u1,
                ///  RF1FE
                RF1FE: u1,
                ///  RF1LE
                RF1LE: u1,
                ///  HPME
                HPME: u1,
                ///  TCE
                TCE: u1,
                ///  TCFE
                TCFE: u1,
                ///  TFEE
                TFEE: u1,
                ///  TEFNE
                TEFNE: u1,
                ///  TEFWE
                TEFWE: u1,
                ///  TEFFE
                TEFFE: u1,
                ///  TEFLE
                TEFLE: u1,
                ///  TSWE
                TSWE: u1,
                ///  MRAFE
                MRAFE: u1,
                ///  TOOE
                TOOE: u1,
                ///  DRXE
                DRXE: u1,
                ///  BECE
                BECE: u1,
                ///  BEUE
                BEUE: u1,
                ///  ELOE
                ELOE: u1,
                ///  EPE
                EPE: u1,
                ///  EWE
                EWE: u1,
                ///  BOE
                BOE: u1,
                ///  WDIE
                WDIE: u1,
                ///  PEAE
                PEAE: u1,
                ///  PEDE
                PEDE: u1,
                ///  ARAE
                ARAE: u1,
                padding: u2,
            }),
            ///  This register assigns an interrupt generated by a specific interrupt flag from the interrupt register to one of the two module interrupt lines. For interrupt generation the respective interrupt line has to be enabled via FDCAN_ILE.EINT0 and FDCAN_ILE.EINT1.
            FDCAN_ILS: mmio.Mmio(packed struct(u32) {
                ///  RF0NL
                RF0NL: u1,
                ///  RF0WL
                RF0WL: u1,
                ///  RF0FL
                RF0FL: u1,
                ///  RF0LL
                RF0LL: u1,
                ///  RF1NL
                RF1NL: u1,
                ///  RF1WL
                RF1WL: u1,
                ///  RF1FL
                RF1FL: u1,
                ///  RF1LL
                RF1LL: u1,
                ///  HPML
                HPML: u1,
                ///  TCL
                TCL: u1,
                ///  TCFL
                TCFL: u1,
                ///  TFEL
                TFEL: u1,
                ///  TEFNL
                TEFNL: u1,
                ///  TEFWL
                TEFWL: u1,
                ///  TEFFL
                TEFFL: u1,
                ///  TEFLL
                TEFLL: u1,
                ///  TSWL
                TSWL: u1,
                ///  MRAFL
                MRAFL: u1,
                ///  TOOL
                TOOL: u1,
                ///  DRXL
                DRXL: u1,
                ///  BECL
                BECL: u1,
                ///  BEUL
                BEUL: u1,
                ///  ELOL
                ELOL: u1,
                ///  EPL
                EPL: u1,
                ///  EWL
                EWL: u1,
                ///  BOL
                BOL: u1,
                ///  WDIL
                WDIL: u1,
                ///  PEAL
                PEAL: u1,
                ///  PEDL
                PEDL: u1,
                ///  ARAL
                ARAL: u1,
                padding: u2,
            }),
            ///  Each of the two interrupt lines to the CPU can be enabled/disabled separately by programming bits EINT0 and EINT1.
            FDCAN_ILE: mmio.Mmio(packed struct(u32) {
                ///  EINT0
                EINT0: u1,
                ///  EINT1
                EINT1: u1,
                padding: u30,
            }),
            reserved128: [32]u8,
            ///  Global settings for message ID filtering. The global filter configuration register controls the filter path for standard and extended messages as described in Figure708: Standard message ID filter path and Figure709: Extended message ID filter path.
            FDCAN_GFC: mmio.Mmio(packed struct(u32) {
                ///  RRFE
                RRFE: u1,
                ///  RRFS
                RRFS: u1,
                ///  ANFE
                ANFE: u2,
                ///  ANFS
                ANFS: u2,
                padding: u26,
            }),
            ///  Settings for 11-bit standard message ID filtering.The standard ID filter configuration register controls the filter path for standard messages as described in Figure708.
            FDCAN_SIDFC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  FLSSA
                FLSSA: u14,
                ///  LSS
                LSS: u8,
                padding: u8,
            }),
            ///  Settings for 29-bit extended message ID filtering. The FDCAN extended ID filter configuration register controls the filter path for standard messages as described in Figure709: Extended message ID filter path.
            FDCAN_XIDFC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  FLESA
                FLESA: u14,
                ///  LSE
                LSE: u8,
                padding: u8,
            }),
            reserved144: [4]u8,
            ///  FDCAN extended ID and mask register
            FDCAN_XIDAM: mmio.Mmio(packed struct(u32) {
                ///  EIDM
                EIDM: u29,
                padding: u3,
            }),
            ///  This register is updated every time a message ID filter element configured to generate a priority event match. This can be used to monitor the status of incoming high priority messages and to enable fast access to these messages.
            FDCAN_HPMS: mmio.Mmio(packed struct(u32) {
                ///  BIDX
                BIDX: u6,
                ///  MSI
                MSI: u2,
                ///  FIDX
                FIDX: u7,
                ///  FLST
                FLST: u1,
                padding: u16,
            }),
            ///  FDCAN new data 1 register
            FDCAN_NDAT1: mmio.Mmio(packed struct(u32) {
                ///  ND0
                ND0: u1,
                ///  ND1
                ND1: u1,
                ///  ND2
                ND2: u1,
                ///  ND3
                ND3: u1,
                ///  ND4
                ND4: u1,
                ///  ND5
                ND5: u1,
                ///  ND6
                ND6: u1,
                ///  ND7
                ND7: u1,
                ///  ND8
                ND8: u1,
                ///  ND9
                ND9: u1,
                ///  ND10
                ND10: u1,
                ///  ND11
                ND11: u1,
                ///  ND12
                ND12: u1,
                ///  ND13
                ND13: u1,
                ///  ND14
                ND14: u1,
                ///  ND15
                ND15: u1,
                ///  ND16
                ND16: u1,
                ///  ND17
                ND17: u1,
                ///  ND18
                ND18: u1,
                ///  ND19
                ND19: u1,
                ///  ND20
                ND20: u1,
                ///  ND21
                ND21: u1,
                ///  ND22
                ND22: u1,
                ///  ND23
                ND23: u1,
                ///  ND24
                ND24: u1,
                ///  ND25
                ND25: u1,
                ///  ND26
                ND26: u1,
                ///  ND27
                ND27: u1,
                ///  ND28
                ND28: u1,
                ///  ND29
                ND29: u1,
                ///  ND30
                ND30: u1,
                ///  ND31
                ND31: u1,
            }),
            ///  FDCAN new data 2 register
            FDCAN_NDAT2: mmio.Mmio(packed struct(u32) {
                ///  ND32
                ND32: u1,
                ///  ND33
                ND33: u1,
                ///  ND34
                ND34: u1,
                ///  ND35
                ND35: u1,
                ///  ND36
                ND36: u1,
                ///  ND37
                ND37: u1,
                ///  ND38
                ND38: u1,
                ///  ND39
                ND39: u1,
                ///  ND40
                ND40: u1,
                ///  ND41
                ND41: u1,
                ///  ND42
                ND42: u1,
                ///  ND43
                ND43: u1,
                ///  ND44
                ND44: u1,
                ///  ND45
                ND45: u1,
                ///  ND46
                ND46: u1,
                ///  ND47
                ND47: u1,
                ///  ND48
                ND48: u1,
                ///  ND49
                ND49: u1,
                ///  ND50
                ND50: u1,
                ///  ND51
                ND51: u1,
                ///  ND52
                ND52: u1,
                ///  ND53
                ND53: u1,
                ///  ND54
                ND54: u1,
                ///  ND55
                ND55: u1,
                ///  ND56
                ND56: u1,
                ///  ND57
                ND57: u1,
                ///  ND58
                ND58: u1,
                ///  ND59
                ND59: u1,
                ///  ND60
                ND60: u1,
                ///  ND61
                ND61: u1,
                ///  ND62
                ND62: u1,
                ///  ND63
                ND63: u1,
            }),
            ///  FDCAN Rx FIFO 0 configuration register
            FDCAN_RXF0C: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  F0SA
                F0SA: u14,
                ///  F0S
                F0S: u7,
                reserved24: u1,
                ///  F0WM
                F0WM: u7,
                ///  F0OM
                F0OM: u1,
            }),
            ///  FDCAN Rx FIFO 0 status register
            FDCAN_RXF0S: mmio.Mmio(packed struct(u32) {
                ///  F0FL
                F0FL: u7,
                reserved8: u1,
                ///  F0GI
                F0GI: u6,
                reserved16: u2,
                ///  F0PI
                F0PI: u6,
                reserved24: u2,
                ///  F0F
                F0F: u1,
                ///  RF0L
                RF0L: u1,
                padding: u6,
            }),
            ///  FDCAN Rx FIFO 0 acknowledge register
            FDCAN_RXF0A: mmio.Mmio(packed struct(u32) {
                ///  F0AI
                F0AI: u6,
                padding: u26,
            }),
            ///  FDCAN Rx buffer configuration register
            FDCAN_RXBC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  RBSA
                RBSA: u14,
                padding: u16,
            }),
            ///  FDCAN Rx FIFO 1 configuration register
            FDCAN_RXF1C: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  F1SA
                F1SA: u14,
                ///  F1S
                F1S: u7,
                reserved24: u1,
                ///  F1WM
                F1WM: u7,
                ///  F1OM
                F1OM: u1,
            }),
            ///  FDCAN Rx FIFO 1 status register
            FDCAN_RXF1S: mmio.Mmio(packed struct(u32) {
                ///  F1FL
                F1FL: u7,
                reserved8: u1,
                ///  F1GI
                F1GI: u6,
                reserved16: u2,
                ///  F1PI
                F1PI: u6,
                reserved24: u2,
                ///  F1F
                F1F: u1,
                ///  RF1L
                RF1L: u1,
                reserved30: u4,
                ///  DMS
                DMS: u2,
            }),
            ///  FDCAN Rx FIFO 1 acknowledge register
            FDCAN_RXF1A: mmio.Mmio(packed struct(u32) {
                ///  F1AI
                F1AI: u6,
                padding: u26,
            }),
            ///  Configures the number of data bytes belonging to an Rx buffer / Rx FIFO element. Data field sizes higher than 8 bytes are intended for CAN FD operation only.
            FDCAN_RXESC: mmio.Mmio(packed struct(u32) {
                ///  F0DS
                F0DS: u3,
                reserved4: u1,
                ///  F1DS
                F1DS: u3,
                reserved8: u1,
                ///  RBDS
                RBDS: u3,
                padding: u21,
            }),
            ///  FDCAN Tx buffer configuration register
            FDCAN_TXBC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  TBSA
                TBSA: u14,
                ///  NDTB
                NDTB: u6,
                reserved24: u2,
                ///  TFQS
                TFQS: u6,
                ///  TFQM
                TFQM: u1,
                padding: u1,
            }),
            ///  The Tx FIFO/queue status is related to the pending Tx requests listed in register FDCAN_TXBRP. Therefore the effect of add/cancellation requests may be delayed due to a running Tx scan (FDCAN_TXBRP not yet updated).
            FDCAN_TXFQS: mmio.Mmio(packed struct(u32) {
                ///  TFFL
                TFFL: u6,
                reserved8: u2,
                ///  TFGI
                TFGI: u5,
                reserved16: u3,
                ///  TFQPI
                TFQPI: u5,
                ///  TFQF
                TFQF: u1,
                padding: u10,
            }),
            ///  Configures the number of data bytes belonging to a Tx buffer element. Data field sizes &gt;8 bytes are intended for CAN FD operation only.
            FDCAN_TXESC: mmio.Mmio(packed struct(u32) {
                ///  TBDS
                TBDS: u3,
                padding: u29,
            }),
            reserved208: [4]u8,
            ///  FDCAN Tx buffer add request register
            FDCAN_TXBAR: mmio.Mmio(packed struct(u32) {
                ///  AR
                AR: u32,
            }),
            ///  FDCAN Tx buffer cancellation request register
            FDCAN_TXBCR: mmio.Mmio(packed struct(u32) {
                ///  CR
                CR: u32,
            }),
            ///  FDCAN Tx buffer transmission occurred register
            FDCAN_TXBTO: mmio.Mmio(packed struct(u32) {
                ///  TO
                TO: u32,
            }),
            ///  FDCAN Tx buffer cancellation finished register
            FDCAN_TXBCF: mmio.Mmio(packed struct(u32) {
                ///  CF
                CF: u32,
            }),
            ///  FDCAN Tx buffer transmission interrupt enable register
            FDCAN_TXBTIE: mmio.Mmio(packed struct(u32) {
                ///  TIE
                TIE: u32,
            }),
            ///  FDCAN Tx buffer cancellation finished interrupt enable register
            FDCAN_TXBCIE: mmio.Mmio(packed struct(u32) {
                ///  CFIE
                CFIE: u32,
            }),
            reserved240: [8]u8,
            ///  FDCAN Tx event FIFO configuration register
            FDCAN_TXEFC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  EFSA
                EFSA: u14,
                ///  EFS
                EFS: u6,
                reserved24: u2,
                ///  EFWM
                EFWM: u6,
                padding: u2,
            }),
            ///  FDCAN Tx event FIFO status register
            FDCAN_TXEFS: mmio.Mmio(packed struct(u32) {
                ///  EFFL
                EFFL: u6,
                reserved8: u2,
                ///  EFGI
                EFGI: u5,
                reserved16: u3,
                ///  EFPI
                EFPI: u5,
                reserved24: u3,
                ///  EFF
                EFF: u1,
                ///  TEFL
                TEFL: u1,
                padding: u6,
            }),
            ///  FDCAN Tx event FIFO acknowledge register
            FDCAN_TXEFA: mmio.Mmio(packed struct(u32) {
                ///  EFAI
                EFAI: u5,
                padding: u27,
            }),
            reserved256: [4]u8,
            ///  FDCAN TT trigger memory configuration register
            FDCAN_TTTMC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  TMSA
                TMSA: u14,
                ///  TME
                TME: u7,
                padding: u9,
            }),
            ///  FDCAN TT reference message configuration register
            FDCAN_TTRMC: mmio.Mmio(packed struct(u32) {
                ///  RID
                RID: u29,
                reserved30: u1,
                ///  XTD
                XTD: u1,
                ///  RMPS
                RMPS: u1,
            }),
            ///  FDCAN TT operation configuration register
            FDCAN_TTOCF: mmio.Mmio(packed struct(u32) {
                ///  OM
                OM: u2,
                reserved3: u1,
                ///  GEN
                GEN: u1,
                ///  TM
                TM: u1,
                ///  LDSDL
                LDSDL: u3,
                ///  IRTO
                IRTO: u7,
                ///  EECS
                EECS: u1,
                ///  AWL
                AWL: u8,
                ///  EGTF
                EGTF: u1,
                ///  ECC
                ECC: u1,
                ///  EVTP
                EVTP: u1,
                padding: u5,
            }),
            ///  FDCAN TT matrix limits register
            FDCAN_TTMLM: mmio.Mmio(packed struct(u32) {
                ///  CCM
                CCM: u6,
                ///  CSS
                CSS: u2,
                ///  TXEW
                TXEW: u4,
                reserved16: u4,
                ///  ENTT
                ENTT: u12,
                padding: u4,
            }),
            ///  The length of the NTU is given by: NTU = CAN clock period x NC/DC. NC is an 18-bit value. Its high part, NCH[17:16] is hard wired to 0b01. Therefore the range of NC extends from 0x10000 to 0x1FFFF. The value configured by NCL is the initial value for FDCAN_TURNA.NAV[15:0]. DC is set to 0x1000 by hardware reset and it may not be written to 0x0000. Level 1: NC 4 * DC and NTU = CAN bit time Levels 0 and 2: NC 8 * DC The actual value of FDCAN_TUR may be changed by the clock drift compensation function of TTCAN level 0 and level 2 in order to adjust the node local view of the NTU to the time master view of the NTU. DC will not be changed by the automatic drift compensation, FDCAN_TURNA.NAV may be adjusted around NC in the range of the synchronization deviation limit given by FDCAN_TTOCF.LDSDL. NC and DC should be programmed to the largest suitable values in achieve the best computational accuracy for the drift compensation process.
            FDCAN_TURCF: mmio.Mmio(packed struct(u32) {
                ///  NCL
                NCL: u16,
                ///  DC
                DC: u14,
                reserved31: u1,
                ///  ELT
                ELT: u1,
            }),
            ///  FDCAN TT operation control register
            FDCAN_TTOCN: mmio.Mmio(packed struct(u32) {
                ///  SGT
                SGT: u1,
                ///  ECS
                ECS: u1,
                ///  SWP
                SWP: u1,
                ///  SWS
                SWS: u2,
                ///  RTIE
                RTIE: u1,
                ///  TMC
                TMC: u2,
                ///  TTIE
                TTIE: u1,
                ///  GCS
                GCS: u1,
                ///  FGP
                FGP: u1,
                ///  TMG
                TMG: u1,
                ///  NIG
                NIG: u1,
                ///  ESCN
                ESCN: u1,
                reserved15: u1,
                ///  LCKC
                LCKC: u1,
                padding: u16,
            }),
            ///  If TTOST.WGDT is set, the next reference message will be transmitted with the Master_Ref_Mark modified by the preset value and with Disc_Bit = 1, presetting the global time in all nodes simultaneously. TP is reset to 0x0000 each time a reference message with Disc_Bit = 1 becomes valid or if the node is not the current time master. TP is locked while FDCAN_TTOST.WGTD = 1 after setting FDCAN_TTOCN.SGT until the reference message with Disc_Bit = 1 becomes valid or until the node is no longer the current time master.
            FDCAN_TTGTP: mmio.Mmio(packed struct(u32) {
                ///  TP
                TP: u16,
                ///  CTP
                CTP: u16,
            }),
            ///  A time mark interrupt (FDCAN_TTIR.TMI = 1) is generated when the time base indicated by FDCAN_TTOCN.TMC (cycle time, local time, or global time) has the same value as TM.
            FDCAN_TTTMK: mmio.Mmio(packed struct(u32) {
                ///  TM
                TM: u16,
                ///  TICC
                TICC: u7,
                reserved31: u8,
                ///  LCKM
                LCKM: u1,
            }),
            ///  The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the register.
            FDCAN_TTIR: mmio.Mmio(packed struct(u32) {
                ///  SBC
                SBC: u1,
                ///  SMC
                SMC: u1,
                ///  CSM
                CSM: u1,
                ///  SOG
                SOG: u1,
                ///  RTMI
                RTMI: u1,
                ///  TTMI
                TTMI: u1,
                ///  SWE
                SWE: u1,
                ///  GTW
                GTW: u1,
                ///  GTD
                GTD: u1,
                ///  GTE
                GTE: u1,
                ///  TXU
                TXU: u1,
                ///  TXO
                TXO: u1,
                ///  SE1
                SE1: u1,
                ///  SE2
                SE2: u1,
                ///  ELC
                ELC: u1,
                ///  IWTG
                IWTG: u1,
                ///  WT
                WT: u1,
                ///  AW
                AW: u1,
                ///  CER
                CER: u1,
                padding: u13,
            }),
            ///  The settings in the TT interrupt enable register determine which status changes in the TT interrupt register will result in an interrupt.
            FDCAN_TTIE: mmio.Mmio(packed struct(u32) {
                ///  SBCE
                SBCE: u1,
                ///  SMCE
                SMCE: u1,
                ///  CSME
                CSME: u1,
                ///  SOGE
                SOGE: u1,
                ///  RTMIE
                RTMIE: u1,
                ///  TTMIE
                TTMIE: u1,
                ///  SWEE
                SWEE: u1,
                ///  GTWE
                GTWE: u1,
                ///  GTDE
                GTDE: u1,
                ///  GTEE
                GTEE: u1,
                ///  TXUE
                TXUE: u1,
                ///  TXOE
                TXOE: u1,
                ///  SE1E
                SE1E: u1,
                ///  SE2E
                SE2E: u1,
                ///  ELCE
                ELCE: u1,
                ///  IWTE
                IWTE: u1,
                ///  WTE
                WTE: u1,
                ///  AWE
                AWE: u1,
                ///  CERE
                CERE: u1,
                padding: u13,
            }),
            ///  The TT interrupt Line select register assigns an interrupt generated by a specific interrupt flag from the TT interrupt register to one of the two module interrupt lines. For interrupt generation the respective interrupt line has to be enabled via FDCAN_ILE.EINT0 and FDCAN_ILE.EINT1.
            FDCAN_TTILS: mmio.Mmio(packed struct(u32) {
                ///  SBCL
                SBCL: u1,
                ///  SMCL
                SMCL: u1,
                ///  CSML
                CSML: u1,
                ///  SOGL
                SOGL: u1,
                ///  RTMIL
                RTMIL: u1,
                ///  TTMIL
                TTMIL: u1,
                ///  SWEL
                SWEL: u1,
                ///  GTWL
                GTWL: u1,
                ///  GTDL
                GTDL: u1,
                ///  GTEL
                GTEL: u1,
                ///  TXUL
                TXUL: u1,
                ///  TXOL
                TXOL: u1,
                ///  SE1L
                SE1L: u1,
                ///  SE2L
                SE2L: u1,
                ///  ELCL
                ELCL: u1,
                ///  IWTL
                IWTL: u1,
                ///  WTL
                WTL: u1,
                ///  AWL
                AWL: u1,
                ///  CERL
                CERL: u1,
                padding: u13,
            }),
            ///  FDCAN TT operation status register
            FDCAN_TTOST: mmio.Mmio(packed struct(u32) {
                ///  EL
                EL: u2,
                ///  MS
                MS: u2,
                ///  SYS
                SYS: u2,
                ///  QGTP
                QGTP: u1,
                ///  QCS
                QCS: u1,
                ///  RTO
                RTO: u8,
                reserved22: u6,
                ///  WGTD
                WGTD: u1,
                ///  GFI
                GFI: u1,
                ///  TMP
                TMP: u3,
                ///  GSI
                GSI: u1,
                ///  WFE
                WFE: u1,
                ///  AWE
                AWE: u1,
                ///  WECS
                WECS: u1,
                ///  SPL
                SPL: u1,
            }),
            ///  There is no drift compensation in TTCAN level 1.
            FDCAN_TURNA: mmio.Mmio(packed struct(u32) {
                ///  NAV
                NAV: u18,
                padding: u14,
            }),
            ///  FDCAN TT local and global time register
            FDCAN_TTLGT: mmio.Mmio(packed struct(u32) {
                ///  LT
                LT: u16,
                ///  GT
                GT: u16,
            }),
            ///  FDCAN TT cycle time and count register
            FDCAN_TTCTC: mmio.Mmio(packed struct(u32) {
                ///  CT
                CT: u16,
                ///  CC
                CC: u6,
                padding: u10,
            }),
            ///  FDCAN TT capture time register
            FDCAN_TTCPT: mmio.Mmio(packed struct(u32) {
                ///  CCV
                CCV: u6,
                reserved16: u10,
                ///  SWV
                SWV: u16,
            }),
            ///  FDCAN TT cycle sync mark register
            FDCAN_TTCSM: mmio.Mmio(packed struct(u32) {
                ///  CSM
                CSM: u16,
                padding: u16,
            }),
            reserved768: [444]u8,
            ///  The settings in the FDCAN_TTTS register select the input to be used as event trigger and stop watch trigger.
            FDCAN_TTTS: mmio.Mmio(packed struct(u32) {
                ///  SWTDEL
                SWTDEL: u2,
                reserved4: u2,
                ///  EVTSEL
                EVTSEL: u2,
                padding: u26,
            }),
        };

        ///  TIM2
        pub const TIM2 = extern struct {
            ///  TIM2 control register 1
            TIM2_CR1: mmio.Mmio(packed struct(u16) {
                ///  CEN
                CEN: u1,
                ///  UDIS
                UDIS: u1,
                ///  URS
                URS: u1,
                ///  OPM
                OPM: u1,
                ///  DIR
                DIR: u1,
                ///  CMS
                CMS: u2,
                ///  ARPE
                ARPE: u1,
                ///  CKD
                CKD: u2,
                reserved11: u1,
                ///  UIFREMAP
                UIFREMAP: u1,
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM2 control register 2
            TIM2_CR2: mmio.Mmio(packed struct(u32) {
                ///  CCPC
                CCPC: u1,
                reserved2: u1,
                ///  CCUS
                CCUS: u1,
                ///  CCDS
                CCDS: u1,
                ///  MMS
                MMS: u3,
                ///  TI1S
                TI1S: u1,
                ///  OIS1
                OIS1: u1,
                ///  OIS1N
                OIS1N: u1,
                ///  OIS2
                OIS2: u1,
                ///  OIS2N
                OIS2N: u1,
                ///  OIS3
                OIS3: u1,
                ///  OIS3N
                OIS3N: u1,
                ///  OIS4
                OIS4: u1,
                reserved16: u1,
                ///  OIS5
                OIS5: u1,
                reserved18: u1,
                ///  OIS6
                OIS6: u1,
                reserved20: u1,
                ///  MMS2
                MMS2: u4,
                padding: u8,
            }),
            ///  TIM2 slave mode control register
            TIM2_SMCR: mmio.Mmio(packed struct(u32) {
                ///  SMS
                SMS: u3,
                reserved4: u1,
                ///  TS
                TS: u3,
                ///  MSM
                MSM: u1,
                ///  ETF
                ETF: u4,
                ///  ETPS
                ETPS: u2,
                ///  ECE
                ECE: u1,
                ///  ETP
                ETP: u1,
                ///  SMS3
                SMS3: u1,
                reserved20: u3,
                ///  TS3
                TS3: u1,
                ///  TS4
                TS4: u1,
                padding: u10,
            }),
            ///  TIM2 DMA/interrupt enable register
            TIM2_DIER: mmio.Mmio(packed struct(u16) {
                ///  UIE
                UIE: u1,
                ///  CC1IE
                CC1IE: u1,
                ///  CC2IE
                CC2IE: u1,
                ///  CC3IE
                CC3IE: u1,
                ///  CC4IE
                CC4IE: u1,
                ///  COMIE
                COMIE: u1,
                ///  TIE
                TIE: u1,
                ///  BIE
                BIE: u1,
                ///  UDE
                UDE: u1,
                ///  CC1DE
                CC1DE: u1,
                ///  CC2DE
                CC2DE: u1,
                ///  CC3DE
                CC3DE: u1,
                ///  CC4DE
                CC4DE: u1,
                ///  COMDE
                COMDE: u1,
                ///  TDE
                TDE: u1,
                padding: u1,
            }),
            reserved16: [2]u8,
            ///  TIM2 status register
            TIM2_SR: mmio.Mmio(packed struct(u32) {
                ///  UIF
                UIF: u1,
                ///  CC1IF
                CC1IF: u1,
                ///  CC2IF
                CC2IF: u1,
                ///  CC3IF
                CC3IF: u1,
                ///  CC4IF
                CC4IF: u1,
                ///  COMIF
                COMIF: u1,
                ///  TIF
                TIF: u1,
                ///  BIF
                BIF: u1,
                ///  B2IF
                B2IF: u1,
                ///  CC1OF
                CC1OF: u1,
                ///  CC2OF
                CC2OF: u1,
                ///  CC3OF
                CC3OF: u1,
                ///  CC4OF
                CC4OF: u1,
                ///  SBIF
                SBIF: u1,
                reserved16: u2,
                ///  CC5IF
                CC5IF: u1,
                ///  CC6IF
                CC6IF: u1,
                padding: u14,
            }),
            ///  TIM2 event generation register
            TIM2_EGR: mmio.Mmio(packed struct(u16) {
                ///  UG
                UG: u1,
                ///  CC1G
                CC1G: u1,
                ///  CC2G
                CC2G: u1,
                ///  CC3G
                CC3G: u1,
                ///  CC4G
                CC4G: u1,
                ///  COMG
                COMG: u1,
                ///  TG
                TG: u1,
                ///  BG
                BG: u1,
                ///  B2G
                B2G: u1,
                padding: u7,
            }),
            reserved24: [2]u8,
            ///  The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
            TIM2_CCMR1ALTERNATE2: mmio.Mmio(packed struct(u32) {
                ///  CC1S
                CC1S: u2,
                ///  IC1PSC
                IC1PSC: u2,
                ///  IC1F
                IC1F: u4,
                ///  CC2S
                CC2S: u2,
                ///  IC2PSC
                IC2PSC: u2,
                ///  IC2F
                IC2F: u4,
                padding: u16,
            }),
            ///  The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
            TIM2_CCMR2ALTERNATE18: mmio.Mmio(packed struct(u32) {
                ///  CC3S
                CC3S: u2,
                ///  IC3PSC
                IC3PSC: u2,
                ///  IC3F
                IC3F: u4,
                ///  CC4S
                CC4S: u2,
                ///  IC4PSC
                IC4PSC: u2,
                ///  IC4F
                IC4F: u4,
                padding: u16,
            }),
            ///  TIM2 capture/compare enable register
            TIM2_CCER: mmio.Mmio(packed struct(u32) {
                ///  CC1E
                CC1E: u1,
                ///  CC1P
                CC1P: u1,
                ///  CC1NE
                CC1NE: u1,
                ///  CC1NP
                CC1NP: u1,
                ///  CC2E
                CC2E: u1,
                ///  CC2P
                CC2P: u1,
                ///  CC2NE
                CC2NE: u1,
                ///  CC2NP
                CC2NP: u1,
                ///  CC3E
                CC3E: u1,
                ///  CC3P
                CC3P: u1,
                ///  CC3NE
                CC3NE: u1,
                ///  CC3NP
                CC3NP: u1,
                ///  CC4E
                CC4E: u1,
                ///  CC4P
                CC4P: u1,
                reserved15: u1,
                ///  CC4NP
                CC4NP: u1,
                ///  CC5E
                CC5E: u1,
                ///  CC5P
                CC5P: u1,
                reserved20: u2,
                ///  CC6E
                CC6E: u1,
                ///  CC6P
                CC6P: u1,
                padding: u10,
            }),
            ///  TIM2 counter
            TIM2_CNT: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u16,
                reserved31: u15,
                ///  UIFCPY
                UIFCPY: u1,
            }),
            ///  TIM2 prescaler
            TIM2_PSC: mmio.Mmio(packed struct(u16) {
                ///  PSC
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM2 auto-reload register
            TIM2_ARR: mmio.Mmio(packed struct(u16) {
                ///  ARR
                ARR: u16,
            }),
            reserved48: [2]u8,
            ///  TIM2 repetition counter register
            TIM2_RCR: mmio.Mmio(packed struct(u16) {
                ///  REP
                REP: u16,
            }),
            reserved52: [2]u8,
            ///  TIM2 capture/compare register 1
            TIM2_CCR1: mmio.Mmio(packed struct(u16) {
                ///  CCR1
                CCR1: u16,
            }),
            reserved56: [2]u8,
            ///  TIM2 capture/compare register 2
            TIM2_CCR2: mmio.Mmio(packed struct(u16) {
                ///  CCR2
                CCR2: u16,
            }),
            reserved60: [2]u8,
            ///  TIM2 capture/compare register 3
            TIM2_CCR3: mmio.Mmio(packed struct(u16) {
                ///  CCR3
                CCR3: u16,
            }),
            reserved64: [2]u8,
            ///  TIM2 capture/compare register 4
            TIM2_CCR4: mmio.Mmio(packed struct(u16) {
                ///  CCR4
                CCR4: u16,
            }),
            reserved68: [2]u8,
            ///  As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
            TIM2_BDTR: mmio.Mmio(packed struct(u32) {
                ///  DTG
                DTG: u8,
                ///  LOCK
                LOCK: u2,
                ///  OSSI
                OSSI: u1,
                ///  OSSR
                OSSR: u1,
                ///  BKE
                BKE: u1,
                ///  BKP
                BKP: u1,
                ///  AOE
                AOE: u1,
                ///  MOE
                MOE: u1,
                ///  BKF
                BKF: u4,
                ///  BK2F
                BK2F: u4,
                ///  BK2E
                BK2E: u1,
                ///  BK2P
                BK2P: u1,
                ///  BKDSRM
                BKDSRM: u1,
                ///  BK2DSRM
                BK2DSRM: u1,
                ///  BKBID
                BKBID: u1,
                ///  BK2BID
                BK2BID: u1,
                padding: u2,
            }),
            ///  TIM2 DMA control register
            TIM2_DCR: mmio.Mmio(packed struct(u16) {
                ///  DBA
                DBA: u5,
                reserved8: u3,
                ///  DBL
                DBL: u5,
                padding: u3,
            }),
            reserved76: [2]u8,
            ///  TIM2 DMA address for full transfer
            TIM2_DMAR: mmio.Mmio(packed struct(u32) {
                ///  DMAB
                DMAB: u32,
            }),
            reserved84: [4]u8,
            ///  The channels 5 and 6 can only be configured in output. Output compare mode:
            TIM2_CCMR3: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  OC5FE
                OC5FE: u1,
                ///  OC5PE
                OC5PE: u1,
                ///  OC5M
                OC5M: u3,
                ///  OC5CE
                OC5CE: u1,
                reserved10: u2,
                ///  OC6FE
                OC6FE: u1,
                ///  OC6PE
                OC6PE: u1,
                ///  OC6M
                OC6M: u3,
                ///  OC6CE
                OC6CE: u1,
                ///  OC5M3
                OC5M3: u1,
                reserved24: u7,
                ///  OC6M3
                OC6M3: u1,
                padding: u7,
            }),
            ///  TIM2 capture/compare register 5
            TIM2_CCR5: mmio.Mmio(packed struct(u32) {
                ///  CCR5
                CCR5: u16,
                reserved29: u13,
                ///  GC5C1
                GC5C1: u1,
                ///  GC5C2
                GC5C2: u1,
                ///  GC5C3
                GC5C3: u1,
            }),
            ///  TIM2 capture/compare register 6
            TIM2_CCR6: mmio.Mmio(packed struct(u16) {
                ///  CCR6
                CCR6: u16,
            }),
        };

        ///  FMC register block
        pub const FMC = extern struct {
            ///  This register contains the control information of each memory bank, used for SRAMs, PSRAM, FRAM and NOR Flash memories.
            FMC_BCR1: mmio.Mmio(packed struct(u32) {
                ///  MBKEN
                MBKEN: u1,
                ///  MUXEN
                MUXEN: u1,
                ///  MTYP
                MTYP: u2,
                ///  MWID
                MWID: u2,
                ///  FACCEN
                FACCEN: u1,
                reserved8: u1,
                ///  BURSTEN
                BURSTEN: u1,
                ///  WAITPOL
                WAITPOL: u1,
                reserved11: u1,
                ///  WAITCFG
                WAITCFG: u1,
                ///  WREN
                WREN: u1,
                ///  WAITEN
                WAITEN: u1,
                ///  EXTMOD
                EXTMOD: u1,
                ///  ASYNCWAIT
                ASYNCWAIT: u1,
                ///  CPSIZE
                CPSIZE: u3,
                ///  CBURSTRW
                CBURSTRW: u1,
                ///  CCLKEN
                CCLKEN: u1,
                reserved22: u1,
                ///  NBLSET
                NBLSET: u2,
                reserved31: u7,
                ///  FMCEN
                FMCEN: u1,
            }),
            ///  This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, two registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
            FMC_BTR1: mmio.Mmio(packed struct(u32) {
                ///  ADDSET
                ADDSET: u4,
                ///  ADDHLD
                ADDHLD: u4,
                ///  DATAST
                DATAST: u8,
                ///  BUSTURN
                BUSTURN: u4,
                ///  CLKDIV
                CLKDIV: u4,
                ///  DATLAT
                DATLAT: u4,
                ///  ACCMOD
                ACCMOD: u2,
                ///  DATAHLD
                DATAHLD: u2,
            }),
            ///  This register contains the control information of each memory bank, used for SRAMs, PSRAM, FRAM and NOR Flash memories.
            FMC_BCR2: mmio.Mmio(packed struct(u32) {
                ///  MBKEN
                MBKEN: u1,
                ///  MUXEN
                MUXEN: u1,
                ///  MTYP
                MTYP: u2,
                ///  MWID
                MWID: u2,
                ///  FACCEN
                FACCEN: u1,
                reserved8: u1,
                ///  BURSTEN
                BURSTEN: u1,
                ///  WAITPOL
                WAITPOL: u1,
                reserved11: u1,
                ///  WAITCFG
                WAITCFG: u1,
                ///  WREN
                WREN: u1,
                ///  WAITEN
                WAITEN: u1,
                ///  EXTMOD
                EXTMOD: u1,
                ///  ASYNCWAIT
                ASYNCWAIT: u1,
                ///  CPSIZE
                CPSIZE: u3,
                ///  CBURSTRW
                CBURSTRW: u1,
                ///  CCLKEN
                CCLKEN: u1,
                reserved22: u1,
                ///  NBLSET
                NBLSET: u2,
                reserved31: u7,
                ///  FMCEN
                FMCEN: u1,
            }),
            ///  This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, two registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
            FMC_BTR2: mmio.Mmio(packed struct(u32) {
                ///  ADDSET
                ADDSET: u4,
                ///  ADDHLD
                ADDHLD: u4,
                ///  DATAST
                DATAST: u8,
                ///  BUSTURN
                BUSTURN: u4,
                ///  CLKDIV
                CLKDIV: u4,
                ///  DATLAT
                DATLAT: u4,
                ///  ACCMOD
                ACCMOD: u2,
                ///  DATAHLD
                DATAHLD: u2,
            }),
            ///  This register contains the control information of each memory bank, used for SRAMs, PSRAM, FRAM and NOR Flash memories.
            FMC_BCR3: mmio.Mmio(packed struct(u32) {
                ///  MBKEN
                MBKEN: u1,
                ///  MUXEN
                MUXEN: u1,
                ///  MTYP
                MTYP: u2,
                ///  MWID
                MWID: u2,
                ///  FACCEN
                FACCEN: u1,
                reserved8: u1,
                ///  BURSTEN
                BURSTEN: u1,
                ///  WAITPOL
                WAITPOL: u1,
                reserved11: u1,
                ///  WAITCFG
                WAITCFG: u1,
                ///  WREN
                WREN: u1,
                ///  WAITEN
                WAITEN: u1,
                ///  EXTMOD
                EXTMOD: u1,
                ///  ASYNCWAIT
                ASYNCWAIT: u1,
                ///  CPSIZE
                CPSIZE: u3,
                ///  CBURSTRW
                CBURSTRW: u1,
                ///  CCLKEN
                CCLKEN: u1,
                reserved22: u1,
                ///  NBLSET
                NBLSET: u2,
                reserved31: u7,
                ///  FMCEN
                FMCEN: u1,
            }),
            ///  This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, two registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
            FMC_BTR3: mmio.Mmio(packed struct(u32) {
                ///  ADDSET
                ADDSET: u4,
                ///  ADDHLD
                ADDHLD: u4,
                ///  DATAST
                DATAST: u8,
                ///  BUSTURN
                BUSTURN: u4,
                ///  CLKDIV
                CLKDIV: u4,
                ///  DATLAT
                DATLAT: u4,
                ///  ACCMOD
                ACCMOD: u2,
                ///  DATAHLD
                DATAHLD: u2,
            }),
            ///  This register contains the control information of each memory bank, used for SRAMs, PSRAM, FRAM and NOR Flash memories.
            FMC_BCR4: mmio.Mmio(packed struct(u32) {
                ///  MBKEN
                MBKEN: u1,
                ///  MUXEN
                MUXEN: u1,
                ///  MTYP
                MTYP: u2,
                ///  MWID
                MWID: u2,
                ///  FACCEN
                FACCEN: u1,
                reserved8: u1,
                ///  BURSTEN
                BURSTEN: u1,
                ///  WAITPOL
                WAITPOL: u1,
                reserved11: u1,
                ///  WAITCFG
                WAITCFG: u1,
                ///  WREN
                WREN: u1,
                ///  WAITEN
                WAITEN: u1,
                ///  EXTMOD
                EXTMOD: u1,
                ///  ASYNCWAIT
                ASYNCWAIT: u1,
                ///  CPSIZE
                CPSIZE: u3,
                ///  CBURSTRW
                CBURSTRW: u1,
                ///  CCLKEN
                CCLKEN: u1,
                reserved22: u1,
                ///  NBLSET
                NBLSET: u2,
                reserved31: u7,
                ///  FMCEN
                FMCEN: u1,
            }),
            ///  This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, two registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
            FMC_BTR4: mmio.Mmio(packed struct(u32) {
                ///  ADDSET
                ADDSET: u4,
                ///  ADDHLD
                ADDHLD: u4,
                ///  DATAST
                DATAST: u8,
                ///  BUSTURN
                BUSTURN: u4,
                ///  CLKDIV
                CLKDIV: u4,
                ///  DATLAT
                DATLAT: u4,
                ///  ACCMOD
                ACCMOD: u2,
                ///  DATAHLD
                DATAHLD: u2,
            }),
            ///  This register contains the PSRAM chip select counter value for synchronous mode. The chip select counter is common to all banks and can be enabled separately on each bank. During PSRAM read or write accesses, this value is loaded into a timer which is decremented using the fmc_ker_ck while the NE signal is held low. When the timer reaches 0, the PSRAM controller splits the current access, toggles NE to allow PSRAM device refresh and restarts a new access. The programmed counter value guarantees a maximum NE pulse width (tCEM) as specified for PSRAM devices. The counter is reloaded and starts decrementing each time a new access is started by a transition of NE from high to low. h
            FMC_PCSCNTR: mmio.Mmio(packed struct(u32) {
                ///  CSCOUNT
                CSCOUNT: u16,
                ///  CNTB1EN
                CNTB1EN: u1,
                ///  CNTB2EN
                CNTB2EN: u1,
                ///  CNTB3EN
                CNTB3EN: u1,
                ///  CNTB4EN
                CNTB4EN: u1,
                padding: u12,
            }),
            reserved128: [92]u8,
            ///  NAND Flash Programmable control register
            FMC_PCR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  PWAITEN
                PWAITEN: u1,
                ///  PBKEN
                PBKEN: u1,
                reserved4: u1,
                ///  PWID
                PWID: u2,
                ///  ECCEN
                ECCEN: u1,
                reserved8: u1,
                ///  ECCALG
                ECCALG: u1,
                ///  TCLR
                TCLR: u4,
                ///  TAR
                TAR: u4,
                ///  ECCSS
                ECCSS: u3,
                ///  TCEH
                TCEH: u4,
                ///  BCHECC
                BCHECC: u1,
                ///  WEN
                WEN: u1,
                padding: u6,
            }),
            ///  This register contains information about the AXI interface isolation status and the NAND write requests status. The FMC has to be disabled before modifying some registers. As requests might be pending, it is necessary to wait till the AXI interface is stable and the core of the block is totally isolated from its AXI interface before reconfiguring the registers. The PEF and PNWEF bits indicate the status of the pipe. If Hamming algorithm is used, the ECC is calculated while data are written to the memory. To read the correct ECC, the software must consequently wait untill no write request to the NAND controller are pending, by polling PEF and NWRF bits.
            FMC_SR: mmio.Mmio(packed struct(u32) {
                ///  ISOST
                ISOST: u2,
                reserved4: u2,
                ///  PEF
                PEF: u1,
                reserved6: u1,
                ///  NWRF
                NWRF: u1,
                padding: u25,
            }),
            ///  The FMC_PMEM read/write register contains NAND Flash memory bank timing information. This information is used to access the NAND Flash common memory space for command, address write accesses or data read/write accesses.
            FMC_PMEM: mmio.Mmio(packed struct(u32) {
                ///  MEMSET
                MEMSET: u8,
                ///  MEMWAIT
                MEMWAIT: u8,
                ///  MEMHOLD
                MEMHOLD: u8,
                ///  MEMHIZ
                MEMHIZ: u8,
            }),
            ///  The FMC_PATT read/write register contains NAND Flash memory bank timing information. It is used for 8-bit accesses to the NAND Flash attribute memory space during the last address write access when the timing differs from previous accesses (for Ready/Busy management, refer to Section25.8.5: NAND Flash prewait function).
            FMC_PATT: mmio.Mmio(packed struct(u32) {
                ///  ATTSET
                ATTSET: u8,
                ///  ATTWAIT
                ATTWAIT: u8,
                ///  ATTHOLD
                ATTHOLD: u8,
                ///  ATTHIZ
                ATTHIZ: u8,
            }),
            ///  This register is used during read accesses in conjunction with the FMC sequencer. It contains the current error correction code value computed by the FMC NAND controller Hamming module. When the FMC sequencer reads data from a NAND Flash memory page at the correct address, the data read are automatically processed by the Hamming computation module. When X bytes have been read (according to the sector size ECCSS field in the FMC_PCR register), the CPU must read the computed ECC value from the FMC_HECCR register. It then verifies if these computed parity data are the same as the parity value recorded in the spare area and stored in the and the FMC_HPR, to determine whether a page is valid, and to correct it otherwise. The FMC_HPR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1.
            FMC_HPR: mmio.Mmio(packed struct(u32) {
                ///  HPR
                HPR: u32,
            }),
            ///  This register contain the current error correction code value computed by the FMC NAND controller Hamming module.When the CPU reads/writes data from/to a NAND Flash memory page at the correct address (refer to Section25.8.6: NAND ECC controller), the data read/written from/to the NAND Flash memory are automatically processed by the Hamming computation module. When X bytes have been read (according to the sector size ECCSS field in the FMC_PCR register), the CPU must read the computed ECC value from the FMC_HECCR register. It then verifies if these computed parity data are the same as the parity value recorded in the spare area, to determine whether a page is valid, and to correct it otherwise. The FMC_HECCR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1.
            FMC_HECCR: mmio.Mmio(packed struct(u32) {
                ///  HECC
                HECC: u32,
            }),
            reserved260: [108]u8,
            ///  This register contains the control information of each memory bank. It is used for SRAMs, FRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
            FMC_BWTR1: mmio.Mmio(packed struct(u32) {
                ///  ADDSET
                ADDSET: u4,
                ///  ADDHLD
                ADDHLD: u4,
                ///  DATAST
                DATAST: u8,
                ///  BUSTURN
                BUSTURN: u4,
                reserved28: u8,
                ///  ACCMOD
                ACCMOD: u2,
                ///  DATAHLD
                DATAHLD: u2,
            }),
            reserved268: [4]u8,
            ///  This register contains the control information of each memory bank. It is used for SRAMs, FRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
            FMC_BWTR2: mmio.Mmio(packed struct(u32) {
                ///  ADDSET
                ADDSET: u4,
                ///  ADDHLD
                ADDHLD: u4,
                ///  DATAST
                DATAST: u8,
                ///  BUSTURN
                BUSTURN: u4,
                reserved28: u8,
                ///  ACCMOD
                ACCMOD: u2,
                ///  DATAHLD
                DATAHLD: u2,
            }),
            reserved276: [4]u8,
            ///  This register contains the control information of each memory bank. It is used for SRAMs, FRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
            FMC_BWTR3: mmio.Mmio(packed struct(u32) {
                ///  ADDSET
                ADDSET: u4,
                ///  ADDHLD
                ADDHLD: u4,
                ///  DATAST
                DATAST: u8,
                ///  BUSTURN
                BUSTURN: u4,
                reserved28: u8,
                ///  ACCMOD
                ACCMOD: u2,
                ///  DATAHLD
                DATAHLD: u2,
            }),
            reserved284: [4]u8,
            ///  This register contains the control information of each memory bank. It is used for SRAMs, FRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
            FMC_BWTR4: mmio.Mmio(packed struct(u32) {
                ///  ADDSET
                ADDSET: u4,
                ///  ADDHLD
                ADDHLD: u4,
                ///  DATAST
                DATAST: u8,
                ///  BUSTURN
                BUSTURN: u4,
                reserved28: u8,
                ///  ACCMOD
                ACCMOD: u2,
                ///  DATAHLD
                DATAHLD: u2,
            }),
            reserved512: [224]u8,
            ///  FMC NAND Command Sequencer Control Register
            FMC_CSQCR: mmio.Mmio(packed struct(u32) {
                ///  CSQSTART
                CSQSTART: u1,
                padding: u31,
            }),
            ///  FMC NAND Command Sequencer Configuration Register 1
            FMC_CSQCFGR1: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  CMD2EN
                CMD2EN: u1,
                ///  DMADEN
                DMADEN: u1,
                reserved4: u1,
                ///  ACYNBR
                ACYNBR: u3,
                reserved8: u1,
                ///  CMD1
                CMD1: u8,
                ///  CMD2
                CMD2: u8,
                ///  CMD1T
                CMD1T: u1,
                ///  CMD2T
                CMD2T: u1,
                padding: u6,
            }),
            ///  This register is used to configure the command sequencer to issue random read/ write commands to read/ write data by sector and automatically read/write data from NAND Flash memory at a programmable address offset. This is useful when performing a sector read/write operation followed by an ECC read/write operation in the NAND Flash spare area.The command sequencer generates the random commands untill all the sectors are read/written. .
            FMC_CSQCFGR2: mmio.Mmio(packed struct(u32) {
                ///  SQSDTEN
                SQSDTEN: u1,
                ///  RCMD2EN
                RCMD2EN: u1,
                ///  DMASEN
                DMASEN: u1,
                reserved8: u5,
                ///  RCMD1
                RCMD1: u8,
                ///  RCMD2
                RCMD2: u8,
                ///  RCMD1T
                RCMD1T: u1,
                ///  RCMD2T
                RCMD2T: u1,
                padding: u6,
            }),
            ///  FMC NAND sequencer configuration register 3
            FMC_CSQCFGR3: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                ///  SNBR
                SNBR: u6,
                reserved16: u2,
                ///  AC1T
                AC1T: u1,
                ///  AC2T
                AC2T: u1,
                ///  AC3T
                AC3T: u1,
                ///  AC4T
                AC4T: u1,
                ///  AC5T
                AC5T: u1,
                ///  SDT
                SDT: u1,
                ///  RAC1T
                RAC1T: u1,
                ///  RAC2T
                RAC2T: u1,
                padding: u8,
            }),
            ///  This register is used to define the value of address cycles 1 to 4 to be issued by the command sequencer.
            FMC_CSQAR1: mmio.Mmio(packed struct(u32) {
                ///  ADDC1
                ADDC1: u8,
                ///  ADDC2
                ADDC2: u8,
                ///  ADDC3
                ADDC3: u8,
                ///  ADDC4
                ADDC4: u8,
            }),
            ///  This register is used to program the fifth address cycle and the address offset in spare area. It also selects the chip enable.
            FMC_CSQAR2: mmio.Mmio(packed struct(u32) {
                ///  ADDC5
                ADDC5: u8,
                reserved10: u2,
                ///  NANDCEN0
                NANDCEN0: u1,
                ///  NANDCEN1
                NANDCEN1: u1,
                reserved16: u4,
                ///  SAO
                SAO: u16,
            }),
            reserved544: [8]u8,
            ///  FMC NAND Command Sequencer Interrupt Enable Register
            FMC_CSQIER: mmio.Mmio(packed struct(u32) {
                ///  TCIE
                TCIE: u1,
                ///  SCIE
                SCIE: u1,
                ///  SEIE
                SEIE: u1,
                ///  SUEIE
                SUEIE: u1,
                ///  CMDTCIE
                CMDTCIE: u1,
                padding: u27,
            }),
            ///  FMC NAND Command Sequencer Interrupt Status Register
            FMC_CSQISR: mmio.Mmio(packed struct(u32) {
                ///  TCF
                TCF: u1,
                ///  SCF
                SCF: u1,
                ///  SEF
                SEF: u1,
                ///  SUEF
                SUEF: u1,
                ///  CMDTCF
                CMDTCF: u1,
                padding: u27,
            }),
            ///  FMC NAND Command Sequencer Interrupt Clear Register
            FMC_CSQICR: mmio.Mmio(packed struct(u32) {
                ///  CTCF
                CTCF: u1,
                ///  CSCF
                CSCF: u1,
                ///  CSEF
                CSEF: u1,
                ///  CSUEF
                CSUEF: u1,
                ///  CCMDTCF
                CCMDTCF: u1,
                padding: u27,
            }),
            reserved560: [4]u8,
            ///  This register holds a sector error mapping status when the whole transfer is complete.
            FMC_CSQEMSR: mmio.Mmio(packed struct(u32) {
                ///  SEM
                SEM: u16,
                padding: u16,
            }),
            reserved592: [28]u8,
            ///  FMC BCH Interrupt enable register
            FMC_BCHIER: mmio.Mmio(packed struct(u32) {
                ///  DUEIE
                DUEIE: u1,
                ///  DERIE
                DERIE: u1,
                ///  DEFIE
                DEFIE: u1,
                ///  DSRIE
                DSRIE: u1,
                ///  EPBRIE
                EPBRIE: u1,
                padding: u27,
            }),
            ///  This register holds the status of BCH encoder/decoder after processing each sector. When the sequencer is used, this register is automatically cleared.
            FMC_BCHISR: mmio.Mmio(packed struct(u32) {
                ///  DUEF
                DUEF: u1,
                ///  DERF
                DERF: u1,
                ///  DEFF
                DEFF: u1,
                ///  DSRF
                DSRF: u1,
                ///  EPBRF
                EPBRF: u1,
                padding: u27,
            }),
            ///  FMC BCH Interrupt Clear Register
            FMC_BCHICR: mmio.Mmio(packed struct(u32) {
                ///  CDUEF
                CDUEF: u1,
                ///  CDERF
                CDERF: u1,
                ///  CDEFF
                CDEFF: u1,
                ///  CDSRF
                CDSRF: u1,
                ///  CEPBRF
                CEPBRF: u1,
                padding: u27,
            }),
            reserved608: [4]u8,
            ///  These registers contain the BCH parity bits (BCHPB). For the BCH 4-bit, only BCHPB[51:0] are significant and for the BCH 8-bit BCHPB[103:0] are significant.
            FMC_BCHPBR1: mmio.Mmio(packed struct(u32) {
                ///  BCHPB
                BCHPB: u32,
            }),
            ///  FMC BCH Parity Bits Register 2
            FMC_BCHPBR2: mmio.Mmio(packed struct(u32) {
                ///  BCHPB
                BCHPB: u32,
            }),
            ///  FMC BCH Parity Bits Register 3
            FMC_BCHPBR3: mmio.Mmio(packed struct(u32) {
                ///  BCHPB
                BCHPB: u32,
            }),
            ///  FMC BCH Parity Bits Register 4
            FMC_BCHPBR4: mmio.Mmio(packed struct(u32) {
                ///  BCHPB
                BCHPB: u8,
                padding: u24,
            }),
            reserved636: [12]u8,
            ///  This register contains some fields already available in other registers but that require to be saved when error correction is performed on several sectors at a time (for example a whole NAND Flash page). This allows a DMA channel to transfer the content of FMC_BCHDSR0..4 to a decoding status buffer. .
            FMC_BCHDSR0: mmio.Mmio(packed struct(u32) {
                ///  DUE
                DUE: u1,
                ///  DEF
                DEF: u1,
                reserved4: u2,
                ///  DEN
                DEN: u4,
                padding: u24,
            }),
            ///  The maximum error correction capability of the BCH block embedded in the FMC is 8 errors
            FMC_BCHDSR1: mmio.Mmio(packed struct(u32) {
                ///  EBP1
                EBP1: u13,
                reserved16: u3,
                ///  EBP2
                EBP2: u13,
                padding: u3,
            }),
            ///  The maximum error correction capability of the BCH block embedded in the FMC is 8 errors. This register contains the positions of the 3rd and 4th error bits in EBP3 and EPB4 fields, respectively.
            FMC_BCHDSR2: mmio.Mmio(packed struct(u32) {
                ///  EBP3
                EBP3: u13,
                reserved16: u3,
                ///  EBP4
                EBP4: u13,
                padding: u3,
            }),
            ///  The maximum error correction capability of the BCH block embedded in the FMC is 8 errors.
            FMC_BCHDSR3: mmio.Mmio(packed struct(u32) {
                ///  EBP5
                EBP5: u13,
                reserved16: u3,
                ///  EBP6
                EBP6: u13,
                padding: u3,
            }),
            ///  The maximum error correction capability of the BCH block embedded in the FMC is 8 errors. This register contains the positions of the 7th and 8th error bits in EBP7 and EPB8 fields, respectively. .
            FMC_BCHDSR4: mmio.Mmio(packed struct(u32) {
                ///  EBP7
                EBP7: u13,
                reserved16: u3,
                ///  EBP8
                EBP8: u13,
                padding: u3,
            }),
            reserved1004: [348]u8,
            ///  FMC Hardware configuration register 2
            FMC_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  RD_LN2DPTH
                RD_LN2DPTH: u4,
                ///  NOR_BASE
                NOR_BASE: u4,
                ///  SDRAM_RBASE
                SDRAM_RBASE: u4,
                ///  NAND_BASE
                NAND_BASE: u4,
                ///  SDRAM1_BASE
                SDRAM1_BASE: u4,
                ///  SDRAM2_BASE
                SDRAM2_BASE: u4,
                padding: u8,
            }),
            ///  FMC Hardware configuration register 1
            FMC_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  NAND_SEL
                NAND_SEL: u1,
                reserved4: u3,
                ///  NAND_ECC
                NAND_ECC: u1,
                reserved8: u3,
                ///  SDRAM_SEL
                SDRAM_SEL: u1,
                reserved12: u3,
                ///  ID_SIZE
                ID_SIZE: u4,
                ///  WA_LN2DPTH
                WA_LN2DPTH: u4,
                ///  WD_LN2DPTH
                WD_LN2DPTH: u4,
                ///  WR_LN2DPTH
                WR_LN2DPTH: u4,
                ///  RA_LN2DPTH
                RA_LN2DPTH: u4,
            }),
            ///  FMC Version register
            FMC_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  FMC Identification register
            FMC_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  FMC Size Identification register
            FMC_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  GICC
        pub const GICC = extern struct {
            ///  GICC control register
            GICC_CTLR: mmio.Mmio(packed struct(u32) {
                ///  ENABLEGRP0
                ENABLEGRP0: u1,
                ///  ENABLEGRP1
                ENABLEGRP1: u1,
                ///  ACKCTL
                ACKCTL: u1,
                ///  FIQEN
                FIQEN: u1,
                ///  CBPR
                CBPR: u1,
                ///  FIQBYPDISGRP0
                FIQBYPDISGRP0: u1,
                ///  IRQBYPDISGRP0
                IRQBYPDISGRP0: u1,
                ///  FIQBYPDISGRP1
                FIQBYPDISGRP1: u1,
                ///  IRQBYPDISGRP1
                IRQBYPDISGRP1: u1,
                ///  EOIMODES
                EOIMODES: u1,
                ///  EOIMODENS
                EOIMODENS: u1,
                padding: u21,
            }),
            ///  GICC input priority mask register
            GICC_PMR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY
                PRIORITY: u5,
                padding: u24,
            }),
            ///  GICC binary point register
            GICC_BPR: mmio.Mmio(packed struct(u32) {
                ///  BINARY_POINT
                BINARY_POINT: u3,
                padding: u29,
            }),
            ///  GICC interrupt acknowledge register
            GICC_IAR: mmio.Mmio(packed struct(u32) {
                ///  INTERRUPT_ID
                INTERRUPT_ID: u10,
                ///  CPUID
                CPUID: u1,
                padding: u21,
            }),
            ///  GICC end of interrupt register
            GICC_EOIR: mmio.Mmio(packed struct(u32) {
                ///  EOIINTID
                EOIINTID: u10,
                ///  CPUID
                CPUID: u1,
                padding: u21,
            }),
            ///  GICC running priority register
            GICC_RPR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY
                PRIORITY: u5,
                padding: u24,
            }),
            ///  GICC highest priority pending interrupt register
            GICC_HPPIR: mmio.Mmio(packed struct(u32) {
                ///  PENDINTID
                PENDINTID: u10,
                ///  CPUID
                CPUID: u1,
                padding: u21,
            }),
            ///  GICC_ABPR is an alias of the non-secure GICC_BPR. When GICC_CTLR.CBPR is set to 0, a secure access to this register is equivalent to a non-secure access to GICC_BPR.
            GICC_ABPR: mmio.Mmio(packed struct(u32) {
                ///  BINARY_POINT
                BINARY_POINT: u3,
                padding: u29,
            }),
            ///  GICC_AIAR is an alias of the non-secure view of GICC_IAR. A secure access to this register is identical to a non-secure access to GICC_IAR.
            GICC_AIAR: mmio.Mmio(packed struct(u32) {
                ///  INTERRUPT_ID
                INTERRUPT_ID: u10,
                ///  CPUID
                CPUID: u1,
                padding: u21,
            }),
            ///  GICC_AEOIR is an alias of the Non-secure GICC_EOIR. A secure access to this register is similar to a non-secure access to GICC_EOIR, except that the GICC_CTLR.EOImodeS bit is used.
            GICC_AEOIR: mmio.Mmio(packed struct(u32) {
                ///  EOIINTID
                EOIINTID: u10,
                ///  CPUID
                CPUID: u1,
                padding: u21,
            }),
            ///  ICC_AHPPIR is an alias of the non-secure GICC_HPPIR. A secure access to this register is equivalent to a non-secure access to GICC_HPPIR.
            GICC_AHPPIR: mmio.Mmio(packed struct(u32) {
                ///  PENDINTID
                PENDINTID: u10,
                ///  CPUID
                CPUID: u1,
                padding: u21,
            }),
            reserved208: [164]u8,
            ///  GICC active priority register
            GICC_APR0: mmio.Mmio(packed struct(u32) {
                ///  APR0
                APR0: u32,
            }),
            reserved224: [12]u8,
            ///  GICC non-secure active priority register
            GICC_NSAPR0: mmio.Mmio(packed struct(u32) {
                ///  NSAPR0
                NSAPR0: u32,
            }),
            reserved252: [24]u8,
            ///  GICC interface identification register
            GICC_IIDR: mmio.Mmio(packed struct(u32) {
                ///  IMPLEMENTER
                IMPLEMENTER: u12,
                ///  REVISION
                REVISION: u4,
                ///  ARCH
                ARCH: u4,
                ///  PRODUCTID
                PRODUCTID: u12,
            }),
            reserved4096: [3840]u8,
            ///  GICC deactivate interrupt register
            GICC_DIR: mmio.Mmio(packed struct(u32) {
                ///  INTERRUPT_ID
                INTERRUPT_ID: u10,
                ///  CPUID
                CPUID: u1,
                padding: u21,
            }),
        };

        ///  GICD
        pub const GICD = extern struct {
            ///  GICD control register
            GICD_CTLR: mmio.Mmio(packed struct(u32) {
                ///  ENABLEGRP0
                ENABLEGRP0: u1,
                ///  ENABLEGRP1
                ENABLEGRP1: u1,
                padding: u30,
            }),
            ///  GICD interrupt controller type register
            GICD_TYPER: mmio.Mmio(packed struct(u32) {
                ///  ITLINESNUMBER
                ITLINESNUMBER: u5,
                ///  CPUNUMBER
                CPUNUMBER: u3,
                reserved10: u2,
                ///  SECURITYEXTN
                SECURITYEXTN: u1,
                ///  LSPI
                LSPI: u5,
                padding: u16,
            }),
            ///  GICD implementer identification register
            GICD_IIDR: mmio.Mmio(packed struct(u32) {
                ///  IMPLEMENTER
                IMPLEMENTER: u12,
                ///  VARIANT
                VARIANT: u4,
                ///  REVISION
                REVISION: u4,
                reserved24: u4,
                ///  PRODUCTID
                PRODUCTID: u8,
            }),
            reserved128: [116]u8,
            ///  For interrupts ID
            GICD_IGROUPR0: mmio.Mmio(packed struct(u32) {
                ///  IGROUPR0
                IGROUPR0: u32,
            }),
            ///  For interrupts ID
            GICD_IGROUPR1: mmio.Mmio(packed struct(u32) {
                ///  IGROUPR1
                IGROUPR1: u32,
            }),
            ///  For interrupts ID
            GICD_IGROUPR2: mmio.Mmio(packed struct(u32) {
                ///  IGROUPR2
                IGROUPR2: u32,
            }),
            ///  For interrupts ID = x*32 to ID = x*32+31
            GICD_IGROUPR3: mmio.Mmio(packed struct(u32) {
                ///  IGROUPR3
                IGROUPR3: u32,
            }),
            ///  For interrupts ID = x*32 to ID = x*32+31
            GICD_IGROUPR4: mmio.Mmio(packed struct(u32) {
                ///  IGROUPR4
                IGROUPR4: u32,
            }),
            ///  For interrupts ID
            GICD_IGROUPR5: mmio.Mmio(packed struct(u32) {
                ///  IGROUPR5
                IGROUPR5: u32,
            }),
            ///  For interrupts ID
            GICD_IGROUPR6: mmio.Mmio(packed struct(u32) {
                ///  IGROUPR6
                IGROUPR6: u32,
            }),
            ///  For interrupts ID
            GICD_IGROUPR7: mmio.Mmio(packed struct(u32) {
                ///  IGROUPR7
                IGROUPR7: u32,
            }),
            ///  For interrupts ID
            GICD_IGROUPR8: mmio.Mmio(packed struct(u32) {
                ///  IGROUPR8
                IGROUPR8: u32,
            }),
            reserved256: [92]u8,
            ///  For interrupts ID = 0 to ID = 31
            GICD_ISENABLER0: mmio.Mmio(packed struct(u32) {
                ///  ISENABLER0
                ISENABLER0: u32,
            }),
            ///  For interrupts ID
            GICD_ISENABLER1: mmio.Mmio(packed struct(u32) {
                ///  ISENABLER1
                ISENABLER1: u32,
            }),
            ///  For interrupts ID
            GICD_ISENABLER2: mmio.Mmio(packed struct(u32) {
                ///  ISENABLER2
                ISENABLER2: u32,
            }),
            ///  For interrupts ID
            GICD_ISENABLER3: mmio.Mmio(packed struct(u32) {
                ///  ISENABLER3
                ISENABLER3: u32,
            }),
            ///  For interrupts ID
            GICD_ISENABLER4: mmio.Mmio(packed struct(u32) {
                ///  ISENABLER4
                ISENABLER4: u32,
            }),
            ///  For interrupts ID
            GICD_ISENABLER5: mmio.Mmio(packed struct(u32) {
                ///  ISENABLER5
                ISENABLER5: u32,
            }),
            ///  For interrupts ID
            GICD_ISENABLER6: mmio.Mmio(packed struct(u32) {
                ///  ISENABLER6
                ISENABLER6: u32,
            }),
            ///  For interrupts ID
            GICD_ISENABLER7: mmio.Mmio(packed struct(u32) {
                ///  ISENABLER7
                ISENABLER7: u32,
            }),
            ///  For interrupts ID
            GICD_ISENABLER8: mmio.Mmio(packed struct(u32) {
                ///  ISENABLER8
                ISENABLER8: u32,
            }),
            reserved384: [92]u8,
            ///  For interrupts ID = 0 to ID = 31
            GICD_ICENABLER0: mmio.Mmio(packed struct(u32) {
                ///  ICENABLER0
                ICENABLER0: u32,
            }),
            ///  For interrupts ID
            GICD_ICENABLER1: mmio.Mmio(packed struct(u32) {
                ///  ICENABLER1
                ICENABLER1: u32,
            }),
            ///  For interrupts ID
            GICD_ICENABLER2: mmio.Mmio(packed struct(u32) {
                ///  ICENABLER2
                ICENABLER2: u32,
            }),
            ///  For interrupts ID
            GICD_ICENABLER3: mmio.Mmio(packed struct(u32) {
                ///  ICENABLER3
                ICENABLER3: u32,
            }),
            ///  For interrupts ID
            GICD_ICENABLER4: mmio.Mmio(packed struct(u32) {
                ///  ICENABLER4
                ICENABLER4: u32,
            }),
            ///  For interrupts ID
            GICD_ICENABLER5: mmio.Mmio(packed struct(u32) {
                ///  ICENABLER5
                ICENABLER5: u32,
            }),
            ///  For interrupts ID
            GICD_ICENABLER6: mmio.Mmio(packed struct(u32) {
                ///  ICENABLER6
                ICENABLER6: u32,
            }),
            ///  For interrupts ID
            GICD_ICENABLER7: mmio.Mmio(packed struct(u32) {
                ///  ICENABLER7
                ICENABLER7: u32,
            }),
            ///  For interrupts ID
            GICD_ICENABLER8: mmio.Mmio(packed struct(u32) {
                ///  ICENABLER8
                ICENABLER8: u32,
            }),
            reserved512: [92]u8,
            ///  For interrupts ID
            GICD_ISPENDR0: mmio.Mmio(packed struct(u32) {
                ///  ISPENDR0
                ISPENDR0: u32,
            }),
            ///  For interrupts ID
            GICD_ISPENDR1: mmio.Mmio(packed struct(u32) {
                ///  ISPENDR1
                ISPENDR1: u32,
            }),
            ///  For interrupts ID
            GICD_ISPENDR2: mmio.Mmio(packed struct(u32) {
                ///  ISPENDR2
                ISPENDR2: u32,
            }),
            ///  For interrupts ID
            GICD_ISPENDR3: mmio.Mmio(packed struct(u32) {
                ///  ISPENDR3
                ISPENDR3: u32,
            }),
            ///  For interrupts ID
            GICD_ISPENDR4: mmio.Mmio(packed struct(u32) {
                ///  ISPENDR4
                ISPENDR4: u32,
            }),
            ///  For interrupts ID
            GICD_ISPENDR5: mmio.Mmio(packed struct(u32) {
                ///  ISPENDR5
                ISPENDR5: u32,
            }),
            ///  For interrupts ID
            GICD_ISPENDR6: mmio.Mmio(packed struct(u32) {
                ///  ISPENDR6
                ISPENDR6: u32,
            }),
            ///  For interrupts ID
            GICD_ISPENDR7: mmio.Mmio(packed struct(u32) {
                ///  ISPENDR7
                ISPENDR7: u32,
            }),
            ///  For interrupts ID
            GICD_ISPENDR8: mmio.Mmio(packed struct(u32) {
                ///  ISPENDR8
                ISPENDR8: u32,
            }),
            reserved640: [92]u8,
            ///  For interrupts ID
            GICD_ICPENDR0: mmio.Mmio(packed struct(u32) {
                ///  ICPENDR0
                ICPENDR0: u32,
            }),
            ///  For interrupts ID
            GICD_ICPENDR1: mmio.Mmio(packed struct(u32) {
                ///  ICPENDR1
                ICPENDR1: u32,
            }),
            ///  For interrupts ID
            GICD_ICPENDR2: mmio.Mmio(packed struct(u32) {
                ///  ICPENDR2
                ICPENDR2: u32,
            }),
            ///  For interrupts ID
            GICD_ICPENDR3: mmio.Mmio(packed struct(u32) {
                ///  ICPENDR3
                ICPENDR3: u32,
            }),
            ///  For interrupts ID
            GICD_ICPENDR4: mmio.Mmio(packed struct(u32) {
                ///  ICPENDR4
                ICPENDR4: u32,
            }),
            ///  For interrupts ID
            GICD_ICPENDR5: mmio.Mmio(packed struct(u32) {
                ///  ICPENDR5
                ICPENDR5: u32,
            }),
            ///  For interrupts ID
            GICD_ICPENDR6: mmio.Mmio(packed struct(u32) {
                ///  ICPENDR6
                ICPENDR6: u32,
            }),
            ///  For interrupts ID
            GICD_ICPENDR7: mmio.Mmio(packed struct(u32) {
                ///  ICPENDR7
                ICPENDR7: u32,
            }),
            ///  For interrupts ID
            GICD_ICPENDR8: mmio.Mmio(packed struct(u32) {
                ///  ICPENDR8
                ICPENDR8: u32,
            }),
            reserved768: [92]u8,
            ///  For interrupts ID
            GICD_ISACTIVER0: mmio.Mmio(packed struct(u32) {
                ///  ISACTIVER0
                ISACTIVER0: u32,
            }),
            ///  For interrupts ID
            GICD_ISACTIVER1: mmio.Mmio(packed struct(u32) {
                ///  ISACTIVER1
                ISACTIVER1: u32,
            }),
            ///  For interrupts ID
            GICD_ISACTIVER2: mmio.Mmio(packed struct(u32) {
                ///  ISACTIVER2
                ISACTIVER2: u32,
            }),
            ///  For interrupts ID
            GICD_ISACTIVER3: mmio.Mmio(packed struct(u32) {
                ///  ISACTIVER3
                ISACTIVER3: u32,
            }),
            ///  For interrupts ID
            GICD_ISACTIVER4: mmio.Mmio(packed struct(u32) {
                ///  ISACTIVER4
                ISACTIVER4: u32,
            }),
            ///  For interrupts ID
            GICD_ISACTIVER5: mmio.Mmio(packed struct(u32) {
                ///  ISACTIVER5
                ISACTIVER5: u32,
            }),
            ///  For interrupts ID
            GICD_ISACTIVER6: mmio.Mmio(packed struct(u32) {
                ///  ISACTIVER6
                ISACTIVER6: u32,
            }),
            ///  For interrupts ID
            GICD_ISACTIVER7: mmio.Mmio(packed struct(u32) {
                ///  ISACTIVER7
                ISACTIVER7: u32,
            }),
            ///  For interrupts ID
            GICD_ISACTIVER8: mmio.Mmio(packed struct(u32) {
                ///  ISACTIVER8
                ISACTIVER8: u32,
            }),
            reserved896: [92]u8,
            ///  For interrupts ID
            GICD_ICACTIVER0: mmio.Mmio(packed struct(u32) {
                ///  ICACTIVER0
                ICACTIVER0: u32,
            }),
            ///  For interrupts ID
            GICD_ICACTIVER1: mmio.Mmio(packed struct(u32) {
                ///  ICACTIVER1
                ICACTIVER1: u32,
            }),
            ///  For interrupts ID
            GICD_ICACTIVER2: mmio.Mmio(packed struct(u32) {
                ///  ICACTIVER2
                ICACTIVER2: u32,
            }),
            ///  For interrupts ID
            GICD_ICACTIVER3: mmio.Mmio(packed struct(u32) {
                ///  ICACTIVER3
                ICACTIVER3: u32,
            }),
            ///  For interrupts ID
            GICD_ICACTIVER4: mmio.Mmio(packed struct(u32) {
                ///  ICACTIVER4
                ICACTIVER4: u32,
            }),
            ///  For interrupts ID
            GICD_ICACTIVER5: mmio.Mmio(packed struct(u32) {
                ///  ICACTIVER5
                ICACTIVER5: u32,
            }),
            ///  For interrupts ID
            GICD_ICACTIVER6: mmio.Mmio(packed struct(u32) {
                ///  ICACTIVER6
                ICACTIVER6: u32,
            }),
            ///  For interrupts ID
            GICD_ICACTIVER7: mmio.Mmio(packed struct(u32) {
                ///  ICACTIVER7
                ICACTIVER7: u32,
            }),
            ///  For interrupts ID
            GICD_ICACTIVER8: mmio.Mmio(packed struct(u32) {
                ///  ICACTIVER8
                ICACTIVER8: u32,
            }),
            reserved1024: [92]u8,
            ///  GICD interrupt priority register 0
            GICD_IPRIORITYR0: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 1
            GICD_IPRIORITYR1: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 2
            GICD_IPRIORITYR2: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 3
            GICD_IPRIORITYR3: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 4
            GICD_IPRIORITYR4: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 5
            GICD_IPRIORITYR5: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 6
            GICD_IPRIORITYR6: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 7
            GICD_IPRIORITYR7: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 8
            GICD_IPRIORITYR8: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 9
            GICD_IPRIORITYR9: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 10
            GICD_IPRIORITYR10: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 11
            GICD_IPRIORITYR11: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 12
            GICD_IPRIORITYR12: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 13
            GICD_IPRIORITYR13: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 14
            GICD_IPRIORITYR14: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 15
            GICD_IPRIORITYR15: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 16
            GICD_IPRIORITYR16: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 17
            GICD_IPRIORITYR17: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 18
            GICD_IPRIORITYR18: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 19
            GICD_IPRIORITYR19: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 20
            GICD_IPRIORITYR20: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 21
            GICD_IPRIORITYR21: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 22
            GICD_IPRIORITYR22: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 23
            GICD_IPRIORITYR23: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 24
            GICD_IPRIORITYR24: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 25
            GICD_IPRIORITYR25: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 26
            GICD_IPRIORITYR26: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 27
            GICD_IPRIORITYR27: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 28
            GICD_IPRIORITYR28: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 29
            GICD_IPRIORITYR29: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 30
            GICD_IPRIORITYR30: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 31
            GICD_IPRIORITYR31: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 32
            GICD_IPRIORITYR32: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 33
            GICD_IPRIORITYR33: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 34
            GICD_IPRIORITYR34: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 35
            GICD_IPRIORITYR35: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 36
            GICD_IPRIORITYR36: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 37
            GICD_IPRIORITYR37: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 38
            GICD_IPRIORITYR38: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 39
            GICD_IPRIORITYR39: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 40
            GICD_IPRIORITYR40: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 41
            GICD_IPRIORITYR41: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 42
            GICD_IPRIORITYR42: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 43
            GICD_IPRIORITYR43: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 44
            GICD_IPRIORITYR44: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 45
            GICD_IPRIORITYR45: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 46
            GICD_IPRIORITYR46: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 47
            GICD_IPRIORITYR47: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 48
            GICD_IPRIORITYR48: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 49
            GICD_IPRIORITYR49: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 50
            GICD_IPRIORITYR50: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 51
            GICD_IPRIORITYR51: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 52
            GICD_IPRIORITYR52: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 53
            GICD_IPRIORITYR53: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 54
            GICD_IPRIORITYR54: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 55
            GICD_IPRIORITYR55: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 56
            GICD_IPRIORITYR56: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 57
            GICD_IPRIORITYR57: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 58
            GICD_IPRIORITYR58: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 59
            GICD_IPRIORITYR59: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 60
            GICD_IPRIORITYR60: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 61
            GICD_IPRIORITYR61: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 62
            GICD_IPRIORITYR62: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 63
            GICD_IPRIORITYR63: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 64
            GICD_IPRIORITYR64: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 65
            GICD_IPRIORITYR65: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 66
            GICD_IPRIORITYR66: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 67
            GICD_IPRIORITYR67: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 68
            GICD_IPRIORITYR68: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 69
            GICD_IPRIORITYR69: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 70
            GICD_IPRIORITYR70: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            ///  GICD interrupt priority register 71
            GICD_IPRIORITYR71: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY0
                PRIORITY0: u5,
                reserved11: u3,
                ///  PRIORITY1
                PRIORITY1: u5,
                reserved19: u3,
                ///  PRIORITY2
                PRIORITY2: u5,
                reserved27: u3,
                ///  PRIORITY3
                PRIORITY3: u5,
            }),
            reserved2048: [736]u8,
            ///  For existing SGIs and PPIs, read of CPU targets field returns the number of the processor performing the read.
            GICD_ITARGETSR0: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  For existing SGIs and PPIs, read of CPU targets field returns the number of the processor performing the read.
            GICD_ITARGETSR1: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  For existing SGIs and PPIs, read of CPU targets field returns the number of the processor performing the read.
            GICD_ITARGETSR2: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  For existing SGIs and PPIs, read of CPU targets field returns the number of the processor performing the read.
            GICD_ITARGETSR3: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  For existing SGIs and PPIs, read of CPU targets field returns the number of the processor performing the read.
            GICD_ITARGETSR4: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  For existing SGIs and PPIs, read of CPU targets field returns the number of the processor performing the read.
            GICD_ITARGETSR5: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  For existing SGIs and PPIs, read of CPU targets field returns the number of the processor performing the read.
            GICD_ITARGETSR6: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  For existing SGIs and PPIs, read of CPU targets field returns the number of the processor performing the read.
            GICD_ITARGETSR7: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 8
            GICD_ITARGETSR8: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 9
            GICD_ITARGETSR9: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 10
            GICD_ITARGETSR10: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 11
            GICD_ITARGETSR11: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 12
            GICD_ITARGETSR12: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 13
            GICD_ITARGETSR13: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 14
            GICD_ITARGETSR14: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 15
            GICD_ITARGETSR15: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 16
            GICD_ITARGETSR16: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 17
            GICD_ITARGETSR17: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 18
            GICD_ITARGETSR18: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 19
            GICD_ITARGETSR19: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 20
            GICD_ITARGETSR20: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 21
            GICD_ITARGETSR21: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 22
            GICD_ITARGETSR22: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 23
            GICD_ITARGETSR23: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 24
            GICD_ITARGETSR24: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 25
            GICD_ITARGETSR25: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 26
            GICD_ITARGETSR26: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 27
            GICD_ITARGETSR27: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 28
            GICD_ITARGETSR28: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 29
            GICD_ITARGETSR29: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 30
            GICD_ITARGETSR30: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 31
            GICD_ITARGETSR31: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 32
            GICD_ITARGETSR32: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 33
            GICD_ITARGETSR33: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 34
            GICD_ITARGETSR34: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 35
            GICD_ITARGETSR35: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 36
            GICD_ITARGETSR36: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 37
            GICD_ITARGETSR37: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 38
            GICD_ITARGETSR38: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 39
            GICD_ITARGETSR39: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 40
            GICD_ITARGETSR40: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 41
            GICD_ITARGETSR41: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 42
            GICD_ITARGETSR42: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 43
            GICD_ITARGETSR43: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 44
            GICD_ITARGETSR44: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 45
            GICD_ITARGETSR45: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 46
            GICD_ITARGETSR46: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 47
            GICD_ITARGETSR47: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 48
            GICD_ITARGETSR48: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 49
            GICD_ITARGETSR49: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 50
            GICD_ITARGETSR50: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 51
            GICD_ITARGETSR51: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 52
            GICD_ITARGETSR52: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 53
            GICD_ITARGETSR53: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 54
            GICD_ITARGETSR54: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 55
            GICD_ITARGETSR55: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 56
            GICD_ITARGETSR56: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 57
            GICD_ITARGETSR57: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 58
            GICD_ITARGETSR58: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 59
            GICD_ITARGETSR59: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 60
            GICD_ITARGETSR60: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 61
            GICD_ITARGETSR61: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 62
            GICD_ITARGETSR62: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 63
            GICD_ITARGETSR63: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 64
            GICD_ITARGETSR64: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 65
            GICD_ITARGETSR65: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 66
            GICD_ITARGETSR66: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 67
            GICD_ITARGETSR67: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 68
            GICD_ITARGETSR68: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 69
            GICD_ITARGETSR69: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 70
            GICD_ITARGETSR70: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            ///  GICD interrupt processor target register 71
            GICD_ITARGETSR71: mmio.Mmio(packed struct(u32) {
                ///  CPU_TARGETS0
                CPU_TARGETS0: u2,
                reserved8: u6,
                ///  CPU_TARGETS1
                CPU_TARGETS1: u2,
                reserved16: u6,
                ///  CPU_TARGETS2
                CPU_TARGETS2: u2,
                reserved24: u6,
                ///  CPU_TARGETS3
                CPU_TARGETS3: u2,
                padding: u6,
            }),
            reserved3072: [736]u8,
            ///  GICD interrupt configuration register
            GICD_ICFGR0: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register
            GICD_ICFGR1: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register 2
            GICD_ICFGR2: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register 3
            GICD_ICFGR3: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register 4
            GICD_ICFGR4: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register 5
            GICD_ICFGR5: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register 6
            GICD_ICFGR6: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register 7
            GICD_ICFGR7: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register 8
            GICD_ICFGR8: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register 9
            GICD_ICFGR9: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register 10
            GICD_ICFGR10: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register 11
            GICD_ICFGR11: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register 12
            GICD_ICFGR12: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register 13
            GICD_ICFGR13: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register 14
            GICD_ICFGR14: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register 15
            GICD_ICFGR15: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register 16
            GICD_ICFGR16: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            ///  GICD interrupt configuration register 17
            GICD_ICFGR17: mmio.Mmio(packed struct(u32) {
                ///  INT_CONFIG0
                INT_CONFIG0: u2,
                ///  INT_CONFIG1
                INT_CONFIG1: u2,
                ///  INT_CONFIG2
                INT_CONFIG2: u2,
                ///  INT_CONFIG3
                INT_CONFIG3: u2,
                ///  INT_CONFIG4
                INT_CONFIG4: u2,
                ///  INT_CONFIG5
                INT_CONFIG5: u2,
                ///  INT_CONFIG6
                INT_CONFIG6: u2,
                ///  INT_CONFIG7
                INT_CONFIG7: u2,
                ///  INT_CONFIG8
                INT_CONFIG8: u2,
                ///  INT_CONFIG9
                INT_CONFIG9: u2,
                ///  INT_CONFIG10
                INT_CONFIG10: u2,
                ///  INT_CONFIG11
                INT_CONFIG11: u2,
                ///  INT_CONFIG12
                INT_CONFIG12: u2,
                ///  INT_CONFIG13
                INT_CONFIG13: u2,
                ///  INT_CONFIG14
                INT_CONFIG14: u2,
                ///  INT_CONFIG15
                INT_CONFIG15: u2,
            }),
            reserved3328: [184]u8,
            ///  GICD private peripheral interrupt status register
            GICD_PPISR: mmio.Mmio(packed struct(u32) {
                reserved9: u9,
                ///  PPI6
                PPI6: u1,
                ///  PPI5
                PPI5: u1,
                ///  PPI4
                PPI4: u1,
                ///  PPI0
                PPI0: u1,
                ///  PPI1
                PPI1: u1,
                ///  PPI2
                PPI2: u1,
                ///  PPI3
                PPI3: u1,
                padding: u16,
            }),
            reserved3336: [4]u8,
            ///  For interrupts ID = SPI number+32, from SPI [x*32+31] to SPI [x*32]
            GICD_SPISR1: mmio.Mmio(packed struct(u32) {
                ///  SPISR1
                SPISR1: u32,
            }),
            ///  For interrupts ID
            GICD_SPISR2: mmio.Mmio(packed struct(u32) {
                ///  SPISR2
                SPISR2: u32,
            }),
            ///  For interrupts ID
            GICD_SPISR3: mmio.Mmio(packed struct(u32) {
                ///  SPISR3
                SPISR3: u32,
            }),
            ///  For interrupts ID
            GICD_SPISR4: mmio.Mmio(packed struct(u32) {
                ///  SPISR4
                SPISR4: u32,
            }),
            ///  For interrupts ID
            GICD_SPISR5: mmio.Mmio(packed struct(u32) {
                ///  SPISR5
                SPISR5: u32,
            }),
            ///  For interrupts ID
            GICD_SPISR6: mmio.Mmio(packed struct(u32) {
                ///  SPISR6
                SPISR6: u32,
            }),
            ///  For interrupts ID
            GICD_SPISR7: mmio.Mmio(packed struct(u32) {
                ///  SPISR7
                SPISR7: u32,
            }),
            reserved3840: [476]u8,
            ///  GICD software generated interrupt register
            GICD_SGIR: mmio.Mmio(packed struct(u32) {
                ///  SGIINTID
                SGIINTID: u4,
                reserved15: u11,
                ///  NSATT
                NSATT: u1,
                ///  CPUTARGETLIST
                CPUTARGETLIST: u2,
                reserved24: u6,
                ///  TARGETLISTFILTER
                TARGETLISTFILTER: u2,
                padding: u6,
            }),
            reserved3856: [12]u8,
            ///  For SGI x*4 to SGI x*4+3
            GICD_CPENDSGIR0: mmio.Mmio(packed struct(u32) {
                ///  SGI_CLEAR_PENDING0
                SGI_CLEAR_PENDING0: u2,
                reserved8: u6,
                ///  SGI_CLEAR_PENDING1
                SGI_CLEAR_PENDING1: u2,
                reserved16: u6,
                ///  SGI_CLEAR_PENDING2
                SGI_CLEAR_PENDING2: u2,
                reserved24: u6,
                ///  SGI_CLEAR_PENDING3
                SGI_CLEAR_PENDING3: u2,
                padding: u6,
            }),
            ///  For SGI x*4 to SGI x*4+3
            GICD_CPENDSGIR1: mmio.Mmio(packed struct(u32) {
                ///  SGI_CLEAR_PENDING0
                SGI_CLEAR_PENDING0: u2,
                reserved8: u6,
                ///  SGI_CLEAR_PENDING1
                SGI_CLEAR_PENDING1: u2,
                reserved16: u6,
                ///  SGI_CLEAR_PENDING2
                SGI_CLEAR_PENDING2: u2,
                reserved24: u6,
                ///  SGI_CLEAR_PENDING3
                SGI_CLEAR_PENDING3: u2,
                padding: u6,
            }),
            ///  For SGI x*4 to SGI x*4+3
            GICD_CPENDSGIR2: mmio.Mmio(packed struct(u32) {
                ///  SGI_CLEAR_PENDING0
                SGI_CLEAR_PENDING0: u2,
                reserved8: u6,
                ///  SGI_CLEAR_PENDING1
                SGI_CLEAR_PENDING1: u2,
                reserved16: u6,
                ///  SGI_CLEAR_PENDING2
                SGI_CLEAR_PENDING2: u2,
                reserved24: u6,
                ///  SGI_CLEAR_PENDING3
                SGI_CLEAR_PENDING3: u2,
                padding: u6,
            }),
            ///  For SGI x*4 to SGI x*4+3
            GICD_CPENDSGIR3: mmio.Mmio(packed struct(u32) {
                ///  SGI_CLEAR_PENDING0
                SGI_CLEAR_PENDING0: u2,
                reserved8: u6,
                ///  SGI_CLEAR_PENDING1
                SGI_CLEAR_PENDING1: u2,
                reserved16: u6,
                ///  SGI_CLEAR_PENDING2
                SGI_CLEAR_PENDING2: u2,
                reserved24: u6,
                ///  SGI_CLEAR_PENDING3
                SGI_CLEAR_PENDING3: u2,
                padding: u6,
            }),
            ///  For SGI x*4 to SGI x*4+3
            GICD_SPENDSGIR0: mmio.Mmio(packed struct(u32) {
                ///  SGI_SET_PENDING0
                SGI_SET_PENDING0: u2,
                reserved8: u6,
                ///  SGI_SET_PENDING1
                SGI_SET_PENDING1: u2,
                reserved16: u6,
                ///  SGI_SET_PENDING2
                SGI_SET_PENDING2: u2,
                reserved24: u6,
                ///  SGI_SET_PENDING3
                SGI_SET_PENDING3: u2,
                padding: u6,
            }),
            ///  For SGI x*4 to SGI x*4+3
            GICD_SPENDSGIR1: mmio.Mmio(packed struct(u32) {
                ///  SGI_SET_PENDING0
                SGI_SET_PENDING0: u2,
                reserved8: u6,
                ///  SGI_SET_PENDING1
                SGI_SET_PENDING1: u2,
                reserved16: u6,
                ///  SGI_SET_PENDING2
                SGI_SET_PENDING2: u2,
                reserved24: u6,
                ///  SGI_SET_PENDING3
                SGI_SET_PENDING3: u2,
                padding: u6,
            }),
            ///  For SGI x*4 to SGI x*4+3
            GICD_SPENDSGIR2: mmio.Mmio(packed struct(u32) {
                ///  SGI_SET_PENDING0
                SGI_SET_PENDING0: u2,
                reserved8: u6,
                ///  SGI_SET_PENDING1
                SGI_SET_PENDING1: u2,
                reserved16: u6,
                ///  SGI_SET_PENDING2
                SGI_SET_PENDING2: u2,
                reserved24: u6,
                ///  SGI_SET_PENDING3
                SGI_SET_PENDING3: u2,
                padding: u6,
            }),
            ///  For SGI x*4 to SGI x*4+3
            GICD_SPENDSGIR3: mmio.Mmio(packed struct(u32) {
                ///  SGI_SET_PENDING0
                SGI_SET_PENDING0: u2,
                reserved8: u6,
                ///  SGI_SET_PENDING1
                SGI_SET_PENDING1: u2,
                reserved16: u6,
                ///  SGI_SET_PENDING2
                SGI_SET_PENDING2: u2,
                reserved24: u6,
                ///  SGI_SET_PENDING3
                SGI_SET_PENDING3: u2,
                padding: u6,
            }),
            reserved4048: [160]u8,
            ///  GICD peripheral ID4 register
            GICD_PIDR4: mmio.Mmio(packed struct(u32) {
                ///  PIDR4
                PIDR4: u32,
            }),
            ///  GICD peripheral ID5 to ID7 register 5
            GICD_PIDR5: mmio.Mmio(packed struct(u32) {
                ///  PIDR5
                PIDR5: u32,
            }),
            ///  GICD peripheral ID5 to ID7 register 6
            GICD_PIDR6: mmio.Mmio(packed struct(u32) {
                ///  PIDR6
                PIDR6: u32,
            }),
            ///  GICD peripheral ID5 to ID7 register 7
            GICD_PIDR7: mmio.Mmio(packed struct(u32) {
                ///  PIDR7
                PIDR7: u32,
            }),
            ///  GICD peripheral ID0 register
            GICD_PIDR0: mmio.Mmio(packed struct(u32) {
                ///  PIDR0
                PIDR0: u32,
            }),
            ///  GICD peripheral ID1 register
            GICD_PIDR1: mmio.Mmio(packed struct(u32) {
                ///  PIDR1
                PIDR1: u32,
            }),
            ///  GICD peripheral ID2 register
            GICD_PIDR2: mmio.Mmio(packed struct(u32) {
                ///  PIDR2
                PIDR2: u32,
            }),
            ///  GICD peripheral ID3 register
            GICD_PIDR3: mmio.Mmio(packed struct(u32) {
                ///  PIDR3
                PIDR3: u32,
            }),
            ///  GICD component ID0 register
            GICD_CIDR0: mmio.Mmio(packed struct(u32) {
                ///  CIDR0
                CIDR0: u32,
            }),
            ///  GICD component ID1 register
            GICD_CIDR1: mmio.Mmio(packed struct(u32) {
                ///  CIDR1
                CIDR1: u32,
            }),
            ///  GICD component ID2 register
            GICD_CIDR2: mmio.Mmio(packed struct(u32) {
                ///  CIDR2
                CIDR2: u32,
            }),
            ///  GICD component ID3 register
            GICD_CIDR3: mmio.Mmio(packed struct(u32) {
                ///  CIDR3
                CIDR3: u32,
            }),
        };

        ///  GICH
        pub const GICH = extern struct {
            ///  GICH hypervisor control register
            GICH_HCR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  UIE
                UIE: u1,
                ///  LRENPIE
                LRENPIE: u1,
                ///  NPIE
                NPIE: u1,
                ///  VGRP0EIE
                VGRP0EIE: u1,
                ///  VGRP0DIE
                VGRP0DIE: u1,
                ///  VGRP1EIE
                VGRP1EIE: u1,
                ///  VGRP1DIE
                VGRP1DIE: u1,
                reserved27: u19,
                ///  EOICOUNT
                EOICOUNT: u5,
            }),
            ///  GICH VGIC type register
            GICH_VTR: mmio.Mmio(packed struct(u32) {
                ///  LISTREGS
                LISTREGS: u5,
                reserved26: u21,
                ///  PREBITS
                PREBITS: u3,
                ///  PRIBITS
                PRIBITS: u3,
            }),
            ///  GICH virtual machine control register
            GICH_VMCR: mmio.Mmio(packed struct(u32) {
                ///  VMGRP0EN
                VMGRP0EN: u1,
                ///  VMGRP1EN
                VMGRP1EN: u1,
                ///  VMACKCTL
                VMACKCTL: u1,
                ///  VMFIQEN
                VMFIQEN: u1,
                ///  VMCBPR
                VMCBPR: u1,
                reserved9: u4,
                ///  VEM
                VEM: u1,
                reserved18: u8,
                ///  VMABP
                VMABP: u3,
                ///  VMBP
                VMBP: u3,
                reserved27: u3,
                ///  VMPRIMASK
                VMPRIMASK: u5,
            }),
            reserved16: [4]u8,
            ///  GICH maintenance interrupt status register
            GICH_MISR: mmio.Mmio(packed struct(u32) {
                ///  EOI
                EOI: u1,
                ///  U
                U: u1,
                ///  LRENP
                LRENP: u1,
                ///  NP
                NP: u1,
                ///  VGRP0E
                VGRP0E: u1,
                ///  VGRP0D
                VGRP0D: u1,
                ///  VGRP1E
                VGRP1E: u1,
                ///  VGRP1D
                VGRP1D: u1,
                padding: u24,
            }),
            reserved32: [12]u8,
            ///  GICH end of interrupt status register
            GICH_EISR0: mmio.Mmio(packed struct(u32) {
                ///  EISR0
                EISR0: u32,
            }),
            reserved48: [12]u8,
            ///  GICH empty list status register
            GICH_ELSR0: mmio.Mmio(packed struct(u32) {
                ///  ELSR0
                ELSR0: u32,
            }),
            reserved240: [188]u8,
            ///  GICH active priority register
            GICH_APR0: mmio.Mmio(packed struct(u32) {
                ///  APR0
                APR0: u32,
            }),
            reserved256: [12]u8,
            ///  GICH list register 0
            GICH_LR0: mmio.Mmio(packed struct(u32) {
                ///  VIRTUALID
                VIRTUALID: u10,
                ///  PHYSICALID
                PHYSICALID: u10,
                reserved23: u3,
                ///  PRIORITY
                PRIORITY: u5,
                ///  STATE
                STATE: u2,
                ///  GRP1
                GRP1: u1,
                ///  HW
                HW: u1,
            }),
            ///  GICH list register 1
            GICH_LR1: mmio.Mmio(packed struct(u32) {
                ///  VIRTUALID
                VIRTUALID: u10,
                ///  PHYSICALID
                PHYSICALID: u10,
                reserved23: u3,
                ///  PRIORITY
                PRIORITY: u5,
                ///  STATE
                STATE: u2,
                ///  GRP1
                GRP1: u1,
                ///  HW
                HW: u1,
            }),
            ///  GICH list register 2
            GICH_LR2: mmio.Mmio(packed struct(u32) {
                ///  VIRTUALID
                VIRTUALID: u10,
                ///  PHYSICALID
                PHYSICALID: u10,
                reserved23: u3,
                ///  PRIORITY
                PRIORITY: u5,
                ///  STATE
                STATE: u2,
                ///  GRP1
                GRP1: u1,
                ///  HW
                HW: u1,
            }),
            ///  GICH list register 3
            GICH_LR3: mmio.Mmio(packed struct(u32) {
                ///  VIRTUALID
                VIRTUALID: u10,
                ///  PHYSICALID
                PHYSICALID: u10,
                reserved23: u3,
                ///  PRIORITY
                PRIORITY: u5,
                ///  STATE
                STATE: u2,
                ///  GRP1
                GRP1: u1,
                ///  HW
                HW: u1,
            }),
        };

        ///  GICV
        pub const GICV = extern struct {
            ///  GICV virtual machine control register
            GICV_CTLR: mmio.Mmio(packed struct(u32) {
                ///  ENABLEGRP0
                ENABLEGRP0: u1,
                ///  ENABLEGRP1
                ENABLEGRP1: u1,
                ///  ACKCTL
                ACKCTL: u1,
                ///  FIQEN
                FIQEN: u1,
                ///  CBPR
                CBPR: u1,
                reserved9: u4,
                ///  EOIMODE
                EOIMODE: u1,
                padding: u22,
            }),
            ///  GICV VM priority mask register
            GICV_PMR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY
                PRIORITY: u5,
                padding: u24,
            }),
            ///  GICV VM binary point register
            GICV_BPR: mmio.Mmio(packed struct(u32) {
                ///  BINARY_POINT
                BINARY_POINT: u3,
                padding: u29,
            }),
            ///  GICV VM interrupt acknowledge register
            GICV_IAR: mmio.Mmio(packed struct(u32) {
                ///  INTERRUPT_ID
                INTERRUPT_ID: u10,
                ///  CPUID
                CPUID: u1,
                padding: u21,
            }),
            ///  GICV VM end of interrupt register
            GICV_EOIR: mmio.Mmio(packed struct(u32) {
                ///  EOIINTID
                EOIINTID: u10,
                ///  CPUID
                CPUID: u1,
                padding: u21,
            }),
            ///  GICV VM running priority register
            GICV_RPR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  PRIORITY
                PRIORITY: u5,
                padding: u24,
            }),
            ///  GICV VM highest priority pending interrupt register
            GICV_HPPIR: mmio.Mmio(packed struct(u32) {
                ///  PENDINTID
                PENDINTID: u10,
                ///  CPUID
                CPUID: u1,
                padding: u21,
            }),
            ///  GICV VM aliased binary point register
            GICV_ABPR: mmio.Mmio(packed struct(u32) {
                ///  BINARY_POINT
                BINARY_POINT: u3,
                padding: u29,
            }),
            ///  GICV VM aliased interrupt register
            GICV_AIAR: mmio.Mmio(packed struct(u32) {
                ///  INTERRUPT_ID
                INTERRUPT_ID: u10,
                ///  CPUID
                CPUID: u1,
                padding: u21,
            }),
            ///  GICV VM aliased end of interrupt register
            GICV_AEOIR: mmio.Mmio(packed struct(u32) {
                ///  EOIINTID
                EOIINTID: u10,
                ///  CPUID
                CPUID: u1,
                padding: u21,
            }),
            ///  GICV VM aliased highest priority pending interrupt register
            GICV_AHPPIR: mmio.Mmio(packed struct(u32) {
                ///  PENDINTID
                PENDINTID: u10,
                ///  CPUID
                CPUID: u1,
                padding: u21,
            }),
            reserved208: [164]u8,
            ///  The GICV_APR0 is an alias of GICH_APR.
            GICV_APR0: mmio.Mmio(packed struct(u32) {
                ///  APR0
                APR0: u32,
            }),
            reserved252: [40]u8,
            ///  The GICV_IIDR is an alias of GICC_IIDR.
            GICV_IIDR: mmio.Mmio(packed struct(u32) {
                ///  IIDR
                IIDR: u32,
            }),
            reserved4096: [3840]u8,
            ///  GICV VM deactivate interrupt register
            GICV_DIR: mmio.Mmio(packed struct(u32) {
                ///  INTERRUPT_ID
                INTERRUPT_ID: u10,
                ///  CPUID
                CPUID: u1,
                padding: u21,
            }),
        };

        ///  GPIOA
        pub const GPIOA = extern struct {
            ///  GPIO port mode register
            GPIOA_MODER: mmio.Mmio(packed struct(u32) {
                ///  MODER0
                MODER0: u2,
                ///  MODER1
                MODER1: u2,
                ///  MODER2
                MODER2: u2,
                ///  MODER3
                MODER3: u2,
                ///  MODER4
                MODER4: u2,
                ///  MODER5
                MODER5: u2,
                ///  MODER6
                MODER6: u2,
                ///  MODER7
                MODER7: u2,
                ///  MODER8
                MODER8: u2,
                ///  MODER9
                MODER9: u2,
                ///  MODER10
                MODER10: u2,
                ///  MODER11
                MODER11: u2,
                ///  MODER12
                MODER12: u2,
                ///  MODER13
                MODER13: u2,
                ///  MODER14
                MODER14: u2,
                ///  MODER15
                MODER15: u2,
            }),
            ///  GPIO port output type register
            GPIOA_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  OT0
                OT0: u1,
                ///  OT1
                OT1: u1,
                ///  OT2
                OT2: u1,
                ///  OT3
                OT3: u1,
                ///  OT4
                OT4: u1,
                ///  OT5
                OT5: u1,
                ///  OT6
                OT6: u1,
                ///  OT7
                OT7: u1,
                ///  OT8
                OT8: u1,
                ///  OT9
                OT9: u1,
                ///  OT10
                OT10: u1,
                ///  OT11
                OT11: u1,
                ///  OT12
                OT12: u1,
                ///  OT13
                OT13: u1,
                ///  OT14
                OT14: u1,
                ///  OT15
                OT15: u1,
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOA_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  OSPEEDR0
                OSPEEDR0: u2,
                ///  OSPEEDR1
                OSPEEDR1: u2,
                ///  OSPEEDR2
                OSPEEDR2: u2,
                ///  OSPEEDR3
                OSPEEDR3: u2,
                ///  OSPEEDR4
                OSPEEDR4: u2,
                ///  OSPEEDR5
                OSPEEDR5: u2,
                ///  OSPEEDR6
                OSPEEDR6: u2,
                ///  OSPEEDR7
                OSPEEDR7: u2,
                ///  OSPEEDR8
                OSPEEDR8: u2,
                ///  OSPEEDR9
                OSPEEDR9: u2,
                ///  OSPEEDR10
                OSPEEDR10: u2,
                ///  OSPEEDR11
                OSPEEDR11: u2,
                ///  OSPEEDR12
                OSPEEDR12: u2,
                ///  OSPEEDR13
                OSPEEDR13: u2,
                ///  OSPEEDR14
                OSPEEDR14: u2,
                ///  OSPEEDR15
                OSPEEDR15: u2,
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOA_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  PUPDR0
                PUPDR0: u2,
                ///  PUPDR1
                PUPDR1: u2,
                ///  PUPDR2
                PUPDR2: u2,
                ///  PUPDR3
                PUPDR3: u2,
                ///  PUPDR4
                PUPDR4: u2,
                ///  PUPDR5
                PUPDR5: u2,
                ///  PUPDR6
                PUPDR6: u2,
                ///  PUPDR7
                PUPDR7: u2,
                ///  PUPDR8
                PUPDR8: u2,
                ///  PUPDR9
                PUPDR9: u2,
                ///  PUPDR10
                PUPDR10: u2,
                ///  PUPDR11
                PUPDR11: u2,
                ///  PUPDR12
                PUPDR12: u2,
                ///  PUPDR13
                PUPDR13: u2,
                ///  PUPDR14
                PUPDR14: u2,
                ///  PUPDR15
                PUPDR15: u2,
            }),
            ///  GPIO port input data register
            GPIOA_IDR: mmio.Mmio(packed struct(u32) {
                ///  IDR0
                IDR0: u1,
                ///  IDR1
                IDR1: u1,
                ///  IDR2
                IDR2: u1,
                ///  IDR3
                IDR3: u1,
                ///  IDR4
                IDR4: u1,
                ///  IDR5
                IDR5: u1,
                ///  IDR6
                IDR6: u1,
                ///  IDR7
                IDR7: u1,
                ///  IDR8
                IDR8: u1,
                ///  IDR9
                IDR9: u1,
                ///  IDR10
                IDR10: u1,
                ///  IDR11
                IDR11: u1,
                ///  IDR12
                IDR12: u1,
                ///  IDR13
                IDR13: u1,
                ///  IDR14
                IDR14: u1,
                ///  IDR15
                IDR15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOA_ODR: mmio.Mmio(packed struct(u32) {
                ///  ODR0
                ODR0: u1,
                ///  ODR1
                ODR1: u1,
                ///  ODR2
                ODR2: u1,
                ///  ODR3
                ODR3: u1,
                ///  ODR4
                ODR4: u1,
                ///  ODR5
                ODR5: u1,
                ///  ODR6
                ODR6: u1,
                ///  ODR7
                ODR7: u1,
                ///  ODR8
                ODR8: u1,
                ///  ODR9
                ODR9: u1,
                ///  ODR10
                ODR10: u1,
                ///  ODR11
                ODR11: u1,
                ///  ODR12
                ODR12: u1,
                ///  ODR13
                ODR13: u1,
                ///  ODR14
                ODR14: u1,
                ///  ODR15
                ODR15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOA_BSRR: mmio.Mmio(packed struct(u32) {
                ///  BS0
                BS0: u1,
                ///  BS1
                BS1: u1,
                ///  BS2
                BS2: u1,
                ///  BS3
                BS3: u1,
                ///  BS4
                BS4: u1,
                ///  BS5
                BS5: u1,
                ///  BS6
                BS6: u1,
                ///  BS7
                BS7: u1,
                ///  BS8
                BS8: u1,
                ///  BS9
                BS9: u1,
                ///  BS10
                BS10: u1,
                ///  BS11
                BS11: u1,
                ///  BS12
                BS12: u1,
                ///  BS13
                BS13: u1,
                ///  BS14
                BS14: u1,
                ///  BS15
                BS15: u1,
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
            }),
            ///  This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
            GPIOA_LCKR: mmio.Mmio(packed struct(u32) {
                ///  LCK0
                LCK0: u1,
                ///  LCK1
                LCK1: u1,
                ///  LCK2
                LCK2: u1,
                ///  LCK3
                LCK3: u1,
                ///  LCK4
                LCK4: u1,
                ///  LCK5
                LCK5: u1,
                ///  LCK6
                LCK6: u1,
                ///  LCK7
                LCK7: u1,
                ///  LCK8
                LCK8: u1,
                ///  LCK9
                LCK9: u1,
                ///  LCK10
                LCK10: u1,
                ///  LCK11
                LCK11: u1,
                ///  LCK12
                LCK12: u1,
                ///  LCK13
                LCK13: u1,
                ///  LCK14
                LCK14: u1,
                ///  LCK15
                LCK15: u1,
                ///  LCKK
                LCKK: u1,
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOA_AFRL: mmio.Mmio(packed struct(u32) {
                ///  AFR0
                AFR0: u4,
                ///  AFR1
                AFR1: u4,
                ///  AFR2
                AFR2: u4,
                ///  AFR3
                AFR3: u4,
                ///  AFR4
                AFR4: u4,
                ///  AFR5
                AFR5: u4,
                ///  AFR6
                AFR6: u4,
                ///  AFR7
                AFR7: u4,
            }),
            ///  GPIO alternate function high register
            GPIOA_AFRH: mmio.Mmio(packed struct(u32) {
                ///  AFR8
                AFR8: u4,
                ///  AFR9
                AFR9: u4,
                ///  AFR10
                AFR10: u4,
                ///  AFR11
                AFR11: u4,
                ///  AFR12
                AFR12: u4,
                ///  AFR13
                AFR13: u4,
                ///  AFR14
                AFR14: u4,
                ///  AFR15
                AFR15: u4,
            }),
            ///  GPIO port bit reset register
            GPIOA_BRR: mmio.Mmio(packed struct(u32) {
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
                padding: u16,
            }),
            reserved968: [924]u8,
            ///  For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
            GPIOA_HWCFGR10: mmio.Mmio(packed struct(u32) {
                ///  AHB_IOP
                AHB_IOP: u4,
                ///  AF_SIZE
                AF_SIZE: u4,
                ///  SPEED_CFG
                SPEED_CFG: u4,
                ///  LOCK_CFG
                LOCK_CFG: u4,
                ///  SEC_CFG
                SEC_CFG: u4,
                ///  OR_CFG
                OR_CFG: u4,
                padding: u8,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOA_HWCFGR9: mmio.Mmio(packed struct(u32) {
                ///  EN_IO
                EN_IO: u16,
                padding: u16,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOA_HWCFGR8: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO8
                AF_PRIO8: u4,
                ///  AF_PRIO9
                AF_PRIO9: u4,
                ///  AF_PRIO10
                AF_PRIO10: u4,
                ///  AF_PRIO11
                AF_PRIO11: u4,
                ///  AF_PRIO12
                AF_PRIO12: u4,
                ///  AF_PRIO13
                AF_PRIO13: u4,
                ///  AF_PRIO14
                AF_PRIO14: u4,
                ///  AF_PRIO15
                AF_PRIO15: u4,
            }),
            ///  GPIO hardware configuration register 7
            GPIOA_HWCFGR7: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO0
                AF_PRIO0: u4,
                ///  AF_PRIO1
                AF_PRIO1: u4,
                ///  AF_PRIO2
                AF_PRIO2: u4,
                ///  AF_PRIO3
                AF_PRIO3: u4,
                ///  AF_PRIO4
                AF_PRIO4: u4,
                ///  AF_PRIO5
                AF_PRIO5: u4,
                ///  AF_PRIO6
                AF_PRIO6: u4,
                ///  AF_PRIO7
                AF_PRIO7: u4,
            }),
            ///  GPIO hardware configuration register 6
            GPIOA_HWCFGR6: mmio.Mmio(packed struct(u32) {
                ///  MODER_RES
                MODER_RES: u32,
            }),
            ///  GPIO hardware configuration register 5
            GPIOA_HWCFGR5: mmio.Mmio(packed struct(u32) {
                ///  PUPDR_RES
                PUPDR_RES: u32,
            }),
            ///  GPIO hardware configuration register 4
            GPIOA_HWCFGR4: mmio.Mmio(packed struct(u32) {
                ///  OSPEED_RES
                OSPEED_RES: u32,
            }),
            ///  GPIO hardware configuration register 3
            GPIOA_HWCFGR3: mmio.Mmio(packed struct(u32) {
                ///  ODR_RES
                ODR_RES: u16,
                ///  OTYPER_RES
                OTYPER_RES: u16,
            }),
            ///  GPIO hardware configuration register 2
            GPIOA_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  AFRL_RES
                AFRL_RES: u32,
            }),
            ///  GPIO hardware configuration register 1
            GPIOA_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  AFRH_RES
                AFRH_RES: u32,
            }),
            ///  GPIO hardware configuration register 0
            GPIOA_HWCFGR0: mmio.Mmio(packed struct(u32) {
                ///  OR_RES
                OR_RES: u16,
                padding: u16,
            }),
            ///  GPIO version register
            GPIOA_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  GPIO identification register
            GPIOA_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  IPIDR
                IPIDR: u32,
            }),
            ///  GPIO size identification register
            GPIOA_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SIDR
                SIDR: u32,
            }),
        };

        ///  GPIOB
        pub const GPIOB = extern struct {
            ///  GPIO port mode register
            GPIOB_MODER: mmio.Mmio(packed struct(u32) {
                ///  MODER0
                MODER0: u2,
                ///  MODER1
                MODER1: u2,
                ///  MODER2
                MODER2: u2,
                ///  MODER3
                MODER3: u2,
                ///  MODER4
                MODER4: u2,
                ///  MODER5
                MODER5: u2,
                ///  MODER6
                MODER6: u2,
                ///  MODER7
                MODER7: u2,
                ///  MODER8
                MODER8: u2,
                ///  MODER9
                MODER9: u2,
                ///  MODER10
                MODER10: u2,
                ///  MODER11
                MODER11: u2,
                ///  MODER12
                MODER12: u2,
                ///  MODER13
                MODER13: u2,
                ///  MODER14
                MODER14: u2,
                ///  MODER15
                MODER15: u2,
            }),
            ///  GPIO port output type register
            GPIOB_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  OT0
                OT0: u1,
                ///  OT1
                OT1: u1,
                ///  OT2
                OT2: u1,
                ///  OT3
                OT3: u1,
                ///  OT4
                OT4: u1,
                ///  OT5
                OT5: u1,
                ///  OT6
                OT6: u1,
                ///  OT7
                OT7: u1,
                ///  OT8
                OT8: u1,
                ///  OT9
                OT9: u1,
                ///  OT10
                OT10: u1,
                ///  OT11
                OT11: u1,
                ///  OT12
                OT12: u1,
                ///  OT13
                OT13: u1,
                ///  OT14
                OT14: u1,
                ///  OT15
                OT15: u1,
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOB_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  OSPEEDR0
                OSPEEDR0: u2,
                ///  OSPEEDR1
                OSPEEDR1: u2,
                ///  OSPEEDR2
                OSPEEDR2: u2,
                ///  OSPEEDR3
                OSPEEDR3: u2,
                ///  OSPEEDR4
                OSPEEDR4: u2,
                ///  OSPEEDR5
                OSPEEDR5: u2,
                ///  OSPEEDR6
                OSPEEDR6: u2,
                ///  OSPEEDR7
                OSPEEDR7: u2,
                ///  OSPEEDR8
                OSPEEDR8: u2,
                ///  OSPEEDR9
                OSPEEDR9: u2,
                ///  OSPEEDR10
                OSPEEDR10: u2,
                ///  OSPEEDR11
                OSPEEDR11: u2,
                ///  OSPEEDR12
                OSPEEDR12: u2,
                ///  OSPEEDR13
                OSPEEDR13: u2,
                ///  OSPEEDR14
                OSPEEDR14: u2,
                ///  OSPEEDR15
                OSPEEDR15: u2,
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOB_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  PUPDR0
                PUPDR0: u2,
                ///  PUPDR1
                PUPDR1: u2,
                ///  PUPDR2
                PUPDR2: u2,
                ///  PUPDR3
                PUPDR3: u2,
                ///  PUPDR4
                PUPDR4: u2,
                ///  PUPDR5
                PUPDR5: u2,
                ///  PUPDR6
                PUPDR6: u2,
                ///  PUPDR7
                PUPDR7: u2,
                ///  PUPDR8
                PUPDR8: u2,
                ///  PUPDR9
                PUPDR9: u2,
                ///  PUPDR10
                PUPDR10: u2,
                ///  PUPDR11
                PUPDR11: u2,
                ///  PUPDR12
                PUPDR12: u2,
                ///  PUPDR13
                PUPDR13: u2,
                ///  PUPDR14
                PUPDR14: u2,
                ///  PUPDR15
                PUPDR15: u2,
            }),
            ///  GPIO port input data register
            GPIOB_IDR: mmio.Mmio(packed struct(u32) {
                ///  IDR0
                IDR0: u1,
                ///  IDR1
                IDR1: u1,
                ///  IDR2
                IDR2: u1,
                ///  IDR3
                IDR3: u1,
                ///  IDR4
                IDR4: u1,
                ///  IDR5
                IDR5: u1,
                ///  IDR6
                IDR6: u1,
                ///  IDR7
                IDR7: u1,
                ///  IDR8
                IDR8: u1,
                ///  IDR9
                IDR9: u1,
                ///  IDR10
                IDR10: u1,
                ///  IDR11
                IDR11: u1,
                ///  IDR12
                IDR12: u1,
                ///  IDR13
                IDR13: u1,
                ///  IDR14
                IDR14: u1,
                ///  IDR15
                IDR15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOB_ODR: mmio.Mmio(packed struct(u32) {
                ///  ODR0
                ODR0: u1,
                ///  ODR1
                ODR1: u1,
                ///  ODR2
                ODR2: u1,
                ///  ODR3
                ODR3: u1,
                ///  ODR4
                ODR4: u1,
                ///  ODR5
                ODR5: u1,
                ///  ODR6
                ODR6: u1,
                ///  ODR7
                ODR7: u1,
                ///  ODR8
                ODR8: u1,
                ///  ODR9
                ODR9: u1,
                ///  ODR10
                ODR10: u1,
                ///  ODR11
                ODR11: u1,
                ///  ODR12
                ODR12: u1,
                ///  ODR13
                ODR13: u1,
                ///  ODR14
                ODR14: u1,
                ///  ODR15
                ODR15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOB_BSRR: mmio.Mmio(packed struct(u32) {
                ///  BS0
                BS0: u1,
                ///  BS1
                BS1: u1,
                ///  BS2
                BS2: u1,
                ///  BS3
                BS3: u1,
                ///  BS4
                BS4: u1,
                ///  BS5
                BS5: u1,
                ///  BS6
                BS6: u1,
                ///  BS7
                BS7: u1,
                ///  BS8
                BS8: u1,
                ///  BS9
                BS9: u1,
                ///  BS10
                BS10: u1,
                ///  BS11
                BS11: u1,
                ///  BS12
                BS12: u1,
                ///  BS13
                BS13: u1,
                ///  BS14
                BS14: u1,
                ///  BS15
                BS15: u1,
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
            }),
            ///  This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
            GPIOB_LCKR: mmio.Mmio(packed struct(u32) {
                ///  LCK0
                LCK0: u1,
                ///  LCK1
                LCK1: u1,
                ///  LCK2
                LCK2: u1,
                ///  LCK3
                LCK3: u1,
                ///  LCK4
                LCK4: u1,
                ///  LCK5
                LCK5: u1,
                ///  LCK6
                LCK6: u1,
                ///  LCK7
                LCK7: u1,
                ///  LCK8
                LCK8: u1,
                ///  LCK9
                LCK9: u1,
                ///  LCK10
                LCK10: u1,
                ///  LCK11
                LCK11: u1,
                ///  LCK12
                LCK12: u1,
                ///  LCK13
                LCK13: u1,
                ///  LCK14
                LCK14: u1,
                ///  LCK15
                LCK15: u1,
                ///  LCKK
                LCKK: u1,
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOB_AFRL: mmio.Mmio(packed struct(u32) {
                ///  AFR0
                AFR0: u4,
                ///  AFR1
                AFR1: u4,
                ///  AFR2
                AFR2: u4,
                ///  AFR3
                AFR3: u4,
                ///  AFR4
                AFR4: u4,
                ///  AFR5
                AFR5: u4,
                ///  AFR6
                AFR6: u4,
                ///  AFR7
                AFR7: u4,
            }),
            ///  GPIO alternate function high register
            GPIOB_AFRH: mmio.Mmio(packed struct(u32) {
                ///  AFR8
                AFR8: u4,
                ///  AFR9
                AFR9: u4,
                ///  AFR10
                AFR10: u4,
                ///  AFR11
                AFR11: u4,
                ///  AFR12
                AFR12: u4,
                ///  AFR13
                AFR13: u4,
                ///  AFR14
                AFR14: u4,
                ///  AFR15
                AFR15: u4,
            }),
            ///  GPIO port bit reset register
            GPIOB_BRR: mmio.Mmio(packed struct(u32) {
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
                padding: u16,
            }),
            reserved968: [924]u8,
            ///  For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
            GPIOB_HWCFGR10: mmio.Mmio(packed struct(u32) {
                ///  AHB_IOP
                AHB_IOP: u4,
                ///  AF_SIZE
                AF_SIZE: u4,
                ///  SPEED_CFG
                SPEED_CFG: u4,
                ///  LOCK_CFG
                LOCK_CFG: u4,
                ///  SEC_CFG
                SEC_CFG: u4,
                ///  OR_CFG
                OR_CFG: u4,
                padding: u8,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOB_HWCFGR9: mmio.Mmio(packed struct(u32) {
                ///  EN_IO
                EN_IO: u16,
                padding: u16,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOB_HWCFGR8: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO8
                AF_PRIO8: u4,
                ///  AF_PRIO9
                AF_PRIO9: u4,
                ///  AF_PRIO10
                AF_PRIO10: u4,
                ///  AF_PRIO11
                AF_PRIO11: u4,
                ///  AF_PRIO12
                AF_PRIO12: u4,
                ///  AF_PRIO13
                AF_PRIO13: u4,
                ///  AF_PRIO14
                AF_PRIO14: u4,
                ///  AF_PRIO15
                AF_PRIO15: u4,
            }),
            ///  GPIO hardware configuration register 7
            GPIOB_HWCFGR7: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO0
                AF_PRIO0: u4,
                ///  AF_PRIO1
                AF_PRIO1: u4,
                ///  AF_PRIO2
                AF_PRIO2: u4,
                ///  AF_PRIO3
                AF_PRIO3: u4,
                ///  AF_PRIO4
                AF_PRIO4: u4,
                ///  AF_PRIO5
                AF_PRIO5: u4,
                ///  AF_PRIO6
                AF_PRIO6: u4,
                ///  AF_PRIO7
                AF_PRIO7: u4,
            }),
            ///  GPIO hardware configuration register 6
            GPIOB_HWCFGR6: mmio.Mmio(packed struct(u32) {
                ///  MODER_RES
                MODER_RES: u32,
            }),
            ///  GPIO hardware configuration register 5
            GPIOB_HWCFGR5: mmio.Mmio(packed struct(u32) {
                ///  PUPDR_RES
                PUPDR_RES: u32,
            }),
            ///  GPIO hardware configuration register 4
            GPIOB_HWCFGR4: mmio.Mmio(packed struct(u32) {
                ///  OSPEED_RES
                OSPEED_RES: u32,
            }),
            ///  GPIO hardware configuration register 3
            GPIOB_HWCFGR3: mmio.Mmio(packed struct(u32) {
                ///  ODR_RES
                ODR_RES: u16,
                ///  OTYPER_RES
                OTYPER_RES: u16,
            }),
            ///  GPIO hardware configuration register 2
            GPIOB_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  AFRL_RES
                AFRL_RES: u32,
            }),
            ///  GPIO hardware configuration register 1
            GPIOB_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  AFRH_RES
                AFRH_RES: u32,
            }),
            ///  GPIO hardware configuration register 0
            GPIOB_HWCFGR0: mmio.Mmio(packed struct(u32) {
                ///  OR_RES
                OR_RES: u16,
                padding: u16,
            }),
            ///  GPIO version register
            GPIOB_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  GPIO identification register
            GPIOB_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  IPIDR
                IPIDR: u32,
            }),
            ///  GPIO size identification register
            GPIOB_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SIDR
                SIDR: u32,
            }),
        };

        ///  GPIOC
        pub const GPIOC = extern struct {
            ///  GPIO port mode register
            GPIOC_MODER: mmio.Mmio(packed struct(u32) {
                ///  MODER0
                MODER0: u2,
                ///  MODER1
                MODER1: u2,
                ///  MODER2
                MODER2: u2,
                ///  MODER3
                MODER3: u2,
                ///  MODER4
                MODER4: u2,
                ///  MODER5
                MODER5: u2,
                ///  MODER6
                MODER6: u2,
                ///  MODER7
                MODER7: u2,
                ///  MODER8
                MODER8: u2,
                ///  MODER9
                MODER9: u2,
                ///  MODER10
                MODER10: u2,
                ///  MODER11
                MODER11: u2,
                ///  MODER12
                MODER12: u2,
                ///  MODER13
                MODER13: u2,
                ///  MODER14
                MODER14: u2,
                ///  MODER15
                MODER15: u2,
            }),
            ///  GPIO port output type register
            GPIOC_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  OT0
                OT0: u1,
                ///  OT1
                OT1: u1,
                ///  OT2
                OT2: u1,
                ///  OT3
                OT3: u1,
                ///  OT4
                OT4: u1,
                ///  OT5
                OT5: u1,
                ///  OT6
                OT6: u1,
                ///  OT7
                OT7: u1,
                ///  OT8
                OT8: u1,
                ///  OT9
                OT9: u1,
                ///  OT10
                OT10: u1,
                ///  OT11
                OT11: u1,
                ///  OT12
                OT12: u1,
                ///  OT13
                OT13: u1,
                ///  OT14
                OT14: u1,
                ///  OT15
                OT15: u1,
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOC_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  OSPEEDR0
                OSPEEDR0: u2,
                ///  OSPEEDR1
                OSPEEDR1: u2,
                ///  OSPEEDR2
                OSPEEDR2: u2,
                ///  OSPEEDR3
                OSPEEDR3: u2,
                ///  OSPEEDR4
                OSPEEDR4: u2,
                ///  OSPEEDR5
                OSPEEDR5: u2,
                ///  OSPEEDR6
                OSPEEDR6: u2,
                ///  OSPEEDR7
                OSPEEDR7: u2,
                ///  OSPEEDR8
                OSPEEDR8: u2,
                ///  OSPEEDR9
                OSPEEDR9: u2,
                ///  OSPEEDR10
                OSPEEDR10: u2,
                ///  OSPEEDR11
                OSPEEDR11: u2,
                ///  OSPEEDR12
                OSPEEDR12: u2,
                ///  OSPEEDR13
                OSPEEDR13: u2,
                ///  OSPEEDR14
                OSPEEDR14: u2,
                ///  OSPEEDR15
                OSPEEDR15: u2,
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOC_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  PUPDR0
                PUPDR0: u2,
                ///  PUPDR1
                PUPDR1: u2,
                ///  PUPDR2
                PUPDR2: u2,
                ///  PUPDR3
                PUPDR3: u2,
                ///  PUPDR4
                PUPDR4: u2,
                ///  PUPDR5
                PUPDR5: u2,
                ///  PUPDR6
                PUPDR6: u2,
                ///  PUPDR7
                PUPDR7: u2,
                ///  PUPDR8
                PUPDR8: u2,
                ///  PUPDR9
                PUPDR9: u2,
                ///  PUPDR10
                PUPDR10: u2,
                ///  PUPDR11
                PUPDR11: u2,
                ///  PUPDR12
                PUPDR12: u2,
                ///  PUPDR13
                PUPDR13: u2,
                ///  PUPDR14
                PUPDR14: u2,
                ///  PUPDR15
                PUPDR15: u2,
            }),
            ///  GPIO port input data register
            GPIOC_IDR: mmio.Mmio(packed struct(u32) {
                ///  IDR0
                IDR0: u1,
                ///  IDR1
                IDR1: u1,
                ///  IDR2
                IDR2: u1,
                ///  IDR3
                IDR3: u1,
                ///  IDR4
                IDR4: u1,
                ///  IDR5
                IDR5: u1,
                ///  IDR6
                IDR6: u1,
                ///  IDR7
                IDR7: u1,
                ///  IDR8
                IDR8: u1,
                ///  IDR9
                IDR9: u1,
                ///  IDR10
                IDR10: u1,
                ///  IDR11
                IDR11: u1,
                ///  IDR12
                IDR12: u1,
                ///  IDR13
                IDR13: u1,
                ///  IDR14
                IDR14: u1,
                ///  IDR15
                IDR15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOC_ODR: mmio.Mmio(packed struct(u32) {
                ///  ODR0
                ODR0: u1,
                ///  ODR1
                ODR1: u1,
                ///  ODR2
                ODR2: u1,
                ///  ODR3
                ODR3: u1,
                ///  ODR4
                ODR4: u1,
                ///  ODR5
                ODR5: u1,
                ///  ODR6
                ODR6: u1,
                ///  ODR7
                ODR7: u1,
                ///  ODR8
                ODR8: u1,
                ///  ODR9
                ODR9: u1,
                ///  ODR10
                ODR10: u1,
                ///  ODR11
                ODR11: u1,
                ///  ODR12
                ODR12: u1,
                ///  ODR13
                ODR13: u1,
                ///  ODR14
                ODR14: u1,
                ///  ODR15
                ODR15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOC_BSRR: mmio.Mmio(packed struct(u32) {
                ///  BS0
                BS0: u1,
                ///  BS1
                BS1: u1,
                ///  BS2
                BS2: u1,
                ///  BS3
                BS3: u1,
                ///  BS4
                BS4: u1,
                ///  BS5
                BS5: u1,
                ///  BS6
                BS6: u1,
                ///  BS7
                BS7: u1,
                ///  BS8
                BS8: u1,
                ///  BS9
                BS9: u1,
                ///  BS10
                BS10: u1,
                ///  BS11
                BS11: u1,
                ///  BS12
                BS12: u1,
                ///  BS13
                BS13: u1,
                ///  BS14
                BS14: u1,
                ///  BS15
                BS15: u1,
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
            }),
            ///  This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
            GPIOC_LCKR: mmio.Mmio(packed struct(u32) {
                ///  LCK0
                LCK0: u1,
                ///  LCK1
                LCK1: u1,
                ///  LCK2
                LCK2: u1,
                ///  LCK3
                LCK3: u1,
                ///  LCK4
                LCK4: u1,
                ///  LCK5
                LCK5: u1,
                ///  LCK6
                LCK6: u1,
                ///  LCK7
                LCK7: u1,
                ///  LCK8
                LCK8: u1,
                ///  LCK9
                LCK9: u1,
                ///  LCK10
                LCK10: u1,
                ///  LCK11
                LCK11: u1,
                ///  LCK12
                LCK12: u1,
                ///  LCK13
                LCK13: u1,
                ///  LCK14
                LCK14: u1,
                ///  LCK15
                LCK15: u1,
                ///  LCKK
                LCKK: u1,
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOC_AFRL: mmio.Mmio(packed struct(u32) {
                ///  AFR0
                AFR0: u4,
                ///  AFR1
                AFR1: u4,
                ///  AFR2
                AFR2: u4,
                ///  AFR3
                AFR3: u4,
                ///  AFR4
                AFR4: u4,
                ///  AFR5
                AFR5: u4,
                ///  AFR6
                AFR6: u4,
                ///  AFR7
                AFR7: u4,
            }),
            ///  GPIO alternate function high register
            GPIOC_AFRH: mmio.Mmio(packed struct(u32) {
                ///  AFR8
                AFR8: u4,
                ///  AFR9
                AFR9: u4,
                ///  AFR10
                AFR10: u4,
                ///  AFR11
                AFR11: u4,
                ///  AFR12
                AFR12: u4,
                ///  AFR13
                AFR13: u4,
                ///  AFR14
                AFR14: u4,
                ///  AFR15
                AFR15: u4,
            }),
            ///  GPIO port bit reset register
            GPIOC_BRR: mmio.Mmio(packed struct(u32) {
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
                padding: u16,
            }),
            reserved968: [924]u8,
            ///  For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
            GPIOC_HWCFGR10: mmio.Mmio(packed struct(u32) {
                ///  AHB_IOP
                AHB_IOP: u4,
                ///  AF_SIZE
                AF_SIZE: u4,
                ///  SPEED_CFG
                SPEED_CFG: u4,
                ///  LOCK_CFG
                LOCK_CFG: u4,
                ///  SEC_CFG
                SEC_CFG: u4,
                ///  OR_CFG
                OR_CFG: u4,
                padding: u8,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOC_HWCFGR9: mmio.Mmio(packed struct(u32) {
                ///  EN_IO
                EN_IO: u16,
                padding: u16,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOC_HWCFGR8: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO8
                AF_PRIO8: u4,
                ///  AF_PRIO9
                AF_PRIO9: u4,
                ///  AF_PRIO10
                AF_PRIO10: u4,
                ///  AF_PRIO11
                AF_PRIO11: u4,
                ///  AF_PRIO12
                AF_PRIO12: u4,
                ///  AF_PRIO13
                AF_PRIO13: u4,
                ///  AF_PRIO14
                AF_PRIO14: u4,
                ///  AF_PRIO15
                AF_PRIO15: u4,
            }),
            ///  GPIO hardware configuration register 7
            GPIOC_HWCFGR7: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO0
                AF_PRIO0: u4,
                ///  AF_PRIO1
                AF_PRIO1: u4,
                ///  AF_PRIO2
                AF_PRIO2: u4,
                ///  AF_PRIO3
                AF_PRIO3: u4,
                ///  AF_PRIO4
                AF_PRIO4: u4,
                ///  AF_PRIO5
                AF_PRIO5: u4,
                ///  AF_PRIO6
                AF_PRIO6: u4,
                ///  AF_PRIO7
                AF_PRIO7: u4,
            }),
            ///  GPIO hardware configuration register 6
            GPIOC_HWCFGR6: mmio.Mmio(packed struct(u32) {
                ///  MODER_RES
                MODER_RES: u32,
            }),
            ///  GPIO hardware configuration register 5
            GPIOC_HWCFGR5: mmio.Mmio(packed struct(u32) {
                ///  PUPDR_RES
                PUPDR_RES: u32,
            }),
            ///  GPIO hardware configuration register 4
            GPIOC_HWCFGR4: mmio.Mmio(packed struct(u32) {
                ///  OSPEED_RES
                OSPEED_RES: u32,
            }),
            ///  GPIO hardware configuration register 3
            GPIOC_HWCFGR3: mmio.Mmio(packed struct(u32) {
                ///  ODR_RES
                ODR_RES: u16,
                ///  OTYPER_RES
                OTYPER_RES: u16,
            }),
            ///  GPIO hardware configuration register 2
            GPIOC_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  AFRL_RES
                AFRL_RES: u32,
            }),
            ///  GPIO hardware configuration register 1
            GPIOC_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  AFRH_RES
                AFRH_RES: u32,
            }),
            ///  GPIO hardware configuration register 0
            GPIOC_HWCFGR0: mmio.Mmio(packed struct(u32) {
                ///  OR_RES
                OR_RES: u16,
                padding: u16,
            }),
            ///  GPIO version register
            GPIOC_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  GPIO identification register
            GPIOC_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  IPIDR
                IPIDR: u32,
            }),
            ///  GPIO size identification register
            GPIOC_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SIDR
                SIDR: u32,
            }),
        };

        ///  GPIOD
        pub const GPIOD = extern struct {
            ///  GPIO port mode register
            GPIOD_MODER: mmio.Mmio(packed struct(u32) {
                ///  MODER0
                MODER0: u2,
                ///  MODER1
                MODER1: u2,
                ///  MODER2
                MODER2: u2,
                ///  MODER3
                MODER3: u2,
                ///  MODER4
                MODER4: u2,
                ///  MODER5
                MODER5: u2,
                ///  MODER6
                MODER6: u2,
                ///  MODER7
                MODER7: u2,
                ///  MODER8
                MODER8: u2,
                ///  MODER9
                MODER9: u2,
                ///  MODER10
                MODER10: u2,
                ///  MODER11
                MODER11: u2,
                ///  MODER12
                MODER12: u2,
                ///  MODER13
                MODER13: u2,
                ///  MODER14
                MODER14: u2,
                ///  MODER15
                MODER15: u2,
            }),
            ///  GPIO port output type register
            GPIOD_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  OT0
                OT0: u1,
                ///  OT1
                OT1: u1,
                ///  OT2
                OT2: u1,
                ///  OT3
                OT3: u1,
                ///  OT4
                OT4: u1,
                ///  OT5
                OT5: u1,
                ///  OT6
                OT6: u1,
                ///  OT7
                OT7: u1,
                ///  OT8
                OT8: u1,
                ///  OT9
                OT9: u1,
                ///  OT10
                OT10: u1,
                ///  OT11
                OT11: u1,
                ///  OT12
                OT12: u1,
                ///  OT13
                OT13: u1,
                ///  OT14
                OT14: u1,
                ///  OT15
                OT15: u1,
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOD_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  OSPEEDR0
                OSPEEDR0: u2,
                ///  OSPEEDR1
                OSPEEDR1: u2,
                ///  OSPEEDR2
                OSPEEDR2: u2,
                ///  OSPEEDR3
                OSPEEDR3: u2,
                ///  OSPEEDR4
                OSPEEDR4: u2,
                ///  OSPEEDR5
                OSPEEDR5: u2,
                ///  OSPEEDR6
                OSPEEDR6: u2,
                ///  OSPEEDR7
                OSPEEDR7: u2,
                ///  OSPEEDR8
                OSPEEDR8: u2,
                ///  OSPEEDR9
                OSPEEDR9: u2,
                ///  OSPEEDR10
                OSPEEDR10: u2,
                ///  OSPEEDR11
                OSPEEDR11: u2,
                ///  OSPEEDR12
                OSPEEDR12: u2,
                ///  OSPEEDR13
                OSPEEDR13: u2,
                ///  OSPEEDR14
                OSPEEDR14: u2,
                ///  OSPEEDR15
                OSPEEDR15: u2,
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOD_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  PUPDR0
                PUPDR0: u2,
                ///  PUPDR1
                PUPDR1: u2,
                ///  PUPDR2
                PUPDR2: u2,
                ///  PUPDR3
                PUPDR3: u2,
                ///  PUPDR4
                PUPDR4: u2,
                ///  PUPDR5
                PUPDR5: u2,
                ///  PUPDR6
                PUPDR6: u2,
                ///  PUPDR7
                PUPDR7: u2,
                ///  PUPDR8
                PUPDR8: u2,
                ///  PUPDR9
                PUPDR9: u2,
                ///  PUPDR10
                PUPDR10: u2,
                ///  PUPDR11
                PUPDR11: u2,
                ///  PUPDR12
                PUPDR12: u2,
                ///  PUPDR13
                PUPDR13: u2,
                ///  PUPDR14
                PUPDR14: u2,
                ///  PUPDR15
                PUPDR15: u2,
            }),
            ///  GPIO port input data register
            GPIOD_IDR: mmio.Mmio(packed struct(u32) {
                ///  IDR0
                IDR0: u1,
                ///  IDR1
                IDR1: u1,
                ///  IDR2
                IDR2: u1,
                ///  IDR3
                IDR3: u1,
                ///  IDR4
                IDR4: u1,
                ///  IDR5
                IDR5: u1,
                ///  IDR6
                IDR6: u1,
                ///  IDR7
                IDR7: u1,
                ///  IDR8
                IDR8: u1,
                ///  IDR9
                IDR9: u1,
                ///  IDR10
                IDR10: u1,
                ///  IDR11
                IDR11: u1,
                ///  IDR12
                IDR12: u1,
                ///  IDR13
                IDR13: u1,
                ///  IDR14
                IDR14: u1,
                ///  IDR15
                IDR15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOD_ODR: mmio.Mmio(packed struct(u32) {
                ///  ODR0
                ODR0: u1,
                ///  ODR1
                ODR1: u1,
                ///  ODR2
                ODR2: u1,
                ///  ODR3
                ODR3: u1,
                ///  ODR4
                ODR4: u1,
                ///  ODR5
                ODR5: u1,
                ///  ODR6
                ODR6: u1,
                ///  ODR7
                ODR7: u1,
                ///  ODR8
                ODR8: u1,
                ///  ODR9
                ODR9: u1,
                ///  ODR10
                ODR10: u1,
                ///  ODR11
                ODR11: u1,
                ///  ODR12
                ODR12: u1,
                ///  ODR13
                ODR13: u1,
                ///  ODR14
                ODR14: u1,
                ///  ODR15
                ODR15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOD_BSRR: mmio.Mmio(packed struct(u32) {
                ///  BS0
                BS0: u1,
                ///  BS1
                BS1: u1,
                ///  BS2
                BS2: u1,
                ///  BS3
                BS3: u1,
                ///  BS4
                BS4: u1,
                ///  BS5
                BS5: u1,
                ///  BS6
                BS6: u1,
                ///  BS7
                BS7: u1,
                ///  BS8
                BS8: u1,
                ///  BS9
                BS9: u1,
                ///  BS10
                BS10: u1,
                ///  BS11
                BS11: u1,
                ///  BS12
                BS12: u1,
                ///  BS13
                BS13: u1,
                ///  BS14
                BS14: u1,
                ///  BS15
                BS15: u1,
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
            }),
            ///  This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
            GPIOD_LCKR: mmio.Mmio(packed struct(u32) {
                ///  LCK0
                LCK0: u1,
                ///  LCK1
                LCK1: u1,
                ///  LCK2
                LCK2: u1,
                ///  LCK3
                LCK3: u1,
                ///  LCK4
                LCK4: u1,
                ///  LCK5
                LCK5: u1,
                ///  LCK6
                LCK6: u1,
                ///  LCK7
                LCK7: u1,
                ///  LCK8
                LCK8: u1,
                ///  LCK9
                LCK9: u1,
                ///  LCK10
                LCK10: u1,
                ///  LCK11
                LCK11: u1,
                ///  LCK12
                LCK12: u1,
                ///  LCK13
                LCK13: u1,
                ///  LCK14
                LCK14: u1,
                ///  LCK15
                LCK15: u1,
                ///  LCKK
                LCKK: u1,
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOD_AFRL: mmio.Mmio(packed struct(u32) {
                ///  AFR0
                AFR0: u4,
                ///  AFR1
                AFR1: u4,
                ///  AFR2
                AFR2: u4,
                ///  AFR3
                AFR3: u4,
                ///  AFR4
                AFR4: u4,
                ///  AFR5
                AFR5: u4,
                ///  AFR6
                AFR6: u4,
                ///  AFR7
                AFR7: u4,
            }),
            ///  GPIO alternate function high register
            GPIOD_AFRH: mmio.Mmio(packed struct(u32) {
                ///  AFR8
                AFR8: u4,
                ///  AFR9
                AFR9: u4,
                ///  AFR10
                AFR10: u4,
                ///  AFR11
                AFR11: u4,
                ///  AFR12
                AFR12: u4,
                ///  AFR13
                AFR13: u4,
                ///  AFR14
                AFR14: u4,
                ///  AFR15
                AFR15: u4,
            }),
            ///  GPIO port bit reset register
            GPIOD_BRR: mmio.Mmio(packed struct(u32) {
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
                padding: u16,
            }),
            reserved968: [924]u8,
            ///  For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
            GPIOD_HWCFGR10: mmio.Mmio(packed struct(u32) {
                ///  AHB_IOP
                AHB_IOP: u4,
                ///  AF_SIZE
                AF_SIZE: u4,
                ///  SPEED_CFG
                SPEED_CFG: u4,
                ///  LOCK_CFG
                LOCK_CFG: u4,
                ///  SEC_CFG
                SEC_CFG: u4,
                ///  OR_CFG
                OR_CFG: u4,
                padding: u8,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOD_HWCFGR9: mmio.Mmio(packed struct(u32) {
                ///  EN_IO
                EN_IO: u16,
                padding: u16,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOD_HWCFGR8: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO8
                AF_PRIO8: u4,
                ///  AF_PRIO9
                AF_PRIO9: u4,
                ///  AF_PRIO10
                AF_PRIO10: u4,
                ///  AF_PRIO11
                AF_PRIO11: u4,
                ///  AF_PRIO12
                AF_PRIO12: u4,
                ///  AF_PRIO13
                AF_PRIO13: u4,
                ///  AF_PRIO14
                AF_PRIO14: u4,
                ///  AF_PRIO15
                AF_PRIO15: u4,
            }),
            ///  GPIO hardware configuration register 7
            GPIOD_HWCFGR7: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO0
                AF_PRIO0: u4,
                ///  AF_PRIO1
                AF_PRIO1: u4,
                ///  AF_PRIO2
                AF_PRIO2: u4,
                ///  AF_PRIO3
                AF_PRIO3: u4,
                ///  AF_PRIO4
                AF_PRIO4: u4,
                ///  AF_PRIO5
                AF_PRIO5: u4,
                ///  AF_PRIO6
                AF_PRIO6: u4,
                ///  AF_PRIO7
                AF_PRIO7: u4,
            }),
            ///  GPIO hardware configuration register 6
            GPIOD_HWCFGR6: mmio.Mmio(packed struct(u32) {
                ///  MODER_RES
                MODER_RES: u32,
            }),
            ///  GPIO hardware configuration register 5
            GPIOD_HWCFGR5: mmio.Mmio(packed struct(u32) {
                ///  PUPDR_RES
                PUPDR_RES: u32,
            }),
            ///  GPIO hardware configuration register 4
            GPIOD_HWCFGR4: mmio.Mmio(packed struct(u32) {
                ///  OSPEED_RES
                OSPEED_RES: u32,
            }),
            ///  GPIO hardware configuration register 3
            GPIOD_HWCFGR3: mmio.Mmio(packed struct(u32) {
                ///  ODR_RES
                ODR_RES: u16,
                ///  OTYPER_RES
                OTYPER_RES: u16,
            }),
            ///  GPIO hardware configuration register 2
            GPIOD_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  AFRL_RES
                AFRL_RES: u32,
            }),
            ///  GPIO hardware configuration register 1
            GPIOD_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  AFRH_RES
                AFRH_RES: u32,
            }),
            ///  GPIO hardware configuration register 0
            GPIOD_HWCFGR0: mmio.Mmio(packed struct(u32) {
                ///  OR_RES
                OR_RES: u16,
                padding: u16,
            }),
            ///  GPIO version register
            GPIOD_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  GPIO identification register
            GPIOD_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  IPIDR
                IPIDR: u32,
            }),
            ///  GPIO size identification register
            GPIOD_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SIDR
                SIDR: u32,
            }),
        };

        ///  GPIOE
        pub const GPIOE = extern struct {
            ///  GPIO port mode register
            GPIOE_MODER: mmio.Mmio(packed struct(u32) {
                ///  MODER0
                MODER0: u2,
                ///  MODER1
                MODER1: u2,
                ///  MODER2
                MODER2: u2,
                ///  MODER3
                MODER3: u2,
                ///  MODER4
                MODER4: u2,
                ///  MODER5
                MODER5: u2,
                ///  MODER6
                MODER6: u2,
                ///  MODER7
                MODER7: u2,
                ///  MODER8
                MODER8: u2,
                ///  MODER9
                MODER9: u2,
                ///  MODER10
                MODER10: u2,
                ///  MODER11
                MODER11: u2,
                ///  MODER12
                MODER12: u2,
                ///  MODER13
                MODER13: u2,
                ///  MODER14
                MODER14: u2,
                ///  MODER15
                MODER15: u2,
            }),
            ///  GPIO port output type register
            GPIOE_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  OT0
                OT0: u1,
                ///  OT1
                OT1: u1,
                ///  OT2
                OT2: u1,
                ///  OT3
                OT3: u1,
                ///  OT4
                OT4: u1,
                ///  OT5
                OT5: u1,
                ///  OT6
                OT6: u1,
                ///  OT7
                OT7: u1,
                ///  OT8
                OT8: u1,
                ///  OT9
                OT9: u1,
                ///  OT10
                OT10: u1,
                ///  OT11
                OT11: u1,
                ///  OT12
                OT12: u1,
                ///  OT13
                OT13: u1,
                ///  OT14
                OT14: u1,
                ///  OT15
                OT15: u1,
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOE_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  OSPEEDR0
                OSPEEDR0: u2,
                ///  OSPEEDR1
                OSPEEDR1: u2,
                ///  OSPEEDR2
                OSPEEDR2: u2,
                ///  OSPEEDR3
                OSPEEDR3: u2,
                ///  OSPEEDR4
                OSPEEDR4: u2,
                ///  OSPEEDR5
                OSPEEDR5: u2,
                ///  OSPEEDR6
                OSPEEDR6: u2,
                ///  OSPEEDR7
                OSPEEDR7: u2,
                ///  OSPEEDR8
                OSPEEDR8: u2,
                ///  OSPEEDR9
                OSPEEDR9: u2,
                ///  OSPEEDR10
                OSPEEDR10: u2,
                ///  OSPEEDR11
                OSPEEDR11: u2,
                ///  OSPEEDR12
                OSPEEDR12: u2,
                ///  OSPEEDR13
                OSPEEDR13: u2,
                ///  OSPEEDR14
                OSPEEDR14: u2,
                ///  OSPEEDR15
                OSPEEDR15: u2,
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOE_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  PUPDR0
                PUPDR0: u2,
                ///  PUPDR1
                PUPDR1: u2,
                ///  PUPDR2
                PUPDR2: u2,
                ///  PUPDR3
                PUPDR3: u2,
                ///  PUPDR4
                PUPDR4: u2,
                ///  PUPDR5
                PUPDR5: u2,
                ///  PUPDR6
                PUPDR6: u2,
                ///  PUPDR7
                PUPDR7: u2,
                ///  PUPDR8
                PUPDR8: u2,
                ///  PUPDR9
                PUPDR9: u2,
                ///  PUPDR10
                PUPDR10: u2,
                ///  PUPDR11
                PUPDR11: u2,
                ///  PUPDR12
                PUPDR12: u2,
                ///  PUPDR13
                PUPDR13: u2,
                ///  PUPDR14
                PUPDR14: u2,
                ///  PUPDR15
                PUPDR15: u2,
            }),
            ///  GPIO port input data register
            GPIOE_IDR: mmio.Mmio(packed struct(u32) {
                ///  IDR0
                IDR0: u1,
                ///  IDR1
                IDR1: u1,
                ///  IDR2
                IDR2: u1,
                ///  IDR3
                IDR3: u1,
                ///  IDR4
                IDR4: u1,
                ///  IDR5
                IDR5: u1,
                ///  IDR6
                IDR6: u1,
                ///  IDR7
                IDR7: u1,
                ///  IDR8
                IDR8: u1,
                ///  IDR9
                IDR9: u1,
                ///  IDR10
                IDR10: u1,
                ///  IDR11
                IDR11: u1,
                ///  IDR12
                IDR12: u1,
                ///  IDR13
                IDR13: u1,
                ///  IDR14
                IDR14: u1,
                ///  IDR15
                IDR15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOE_ODR: mmio.Mmio(packed struct(u32) {
                ///  ODR0
                ODR0: u1,
                ///  ODR1
                ODR1: u1,
                ///  ODR2
                ODR2: u1,
                ///  ODR3
                ODR3: u1,
                ///  ODR4
                ODR4: u1,
                ///  ODR5
                ODR5: u1,
                ///  ODR6
                ODR6: u1,
                ///  ODR7
                ODR7: u1,
                ///  ODR8
                ODR8: u1,
                ///  ODR9
                ODR9: u1,
                ///  ODR10
                ODR10: u1,
                ///  ODR11
                ODR11: u1,
                ///  ODR12
                ODR12: u1,
                ///  ODR13
                ODR13: u1,
                ///  ODR14
                ODR14: u1,
                ///  ODR15
                ODR15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOE_BSRR: mmio.Mmio(packed struct(u32) {
                ///  BS0
                BS0: u1,
                ///  BS1
                BS1: u1,
                ///  BS2
                BS2: u1,
                ///  BS3
                BS3: u1,
                ///  BS4
                BS4: u1,
                ///  BS5
                BS5: u1,
                ///  BS6
                BS6: u1,
                ///  BS7
                BS7: u1,
                ///  BS8
                BS8: u1,
                ///  BS9
                BS9: u1,
                ///  BS10
                BS10: u1,
                ///  BS11
                BS11: u1,
                ///  BS12
                BS12: u1,
                ///  BS13
                BS13: u1,
                ///  BS14
                BS14: u1,
                ///  BS15
                BS15: u1,
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
            }),
            ///  This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
            GPIOE_LCKR: mmio.Mmio(packed struct(u32) {
                ///  LCK0
                LCK0: u1,
                ///  LCK1
                LCK1: u1,
                ///  LCK2
                LCK2: u1,
                ///  LCK3
                LCK3: u1,
                ///  LCK4
                LCK4: u1,
                ///  LCK5
                LCK5: u1,
                ///  LCK6
                LCK6: u1,
                ///  LCK7
                LCK7: u1,
                ///  LCK8
                LCK8: u1,
                ///  LCK9
                LCK9: u1,
                ///  LCK10
                LCK10: u1,
                ///  LCK11
                LCK11: u1,
                ///  LCK12
                LCK12: u1,
                ///  LCK13
                LCK13: u1,
                ///  LCK14
                LCK14: u1,
                ///  LCK15
                LCK15: u1,
                ///  LCKK
                LCKK: u1,
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOE_AFRL: mmio.Mmio(packed struct(u32) {
                ///  AFR0
                AFR0: u4,
                ///  AFR1
                AFR1: u4,
                ///  AFR2
                AFR2: u4,
                ///  AFR3
                AFR3: u4,
                ///  AFR4
                AFR4: u4,
                ///  AFR5
                AFR5: u4,
                ///  AFR6
                AFR6: u4,
                ///  AFR7
                AFR7: u4,
            }),
            ///  GPIO alternate function high register
            GPIOE_AFRH: mmio.Mmio(packed struct(u32) {
                ///  AFR8
                AFR8: u4,
                ///  AFR9
                AFR9: u4,
                ///  AFR10
                AFR10: u4,
                ///  AFR11
                AFR11: u4,
                ///  AFR12
                AFR12: u4,
                ///  AFR13
                AFR13: u4,
                ///  AFR14
                AFR14: u4,
                ///  AFR15
                AFR15: u4,
            }),
            ///  GPIO port bit reset register
            GPIOE_BRR: mmio.Mmio(packed struct(u32) {
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
                padding: u16,
            }),
            reserved968: [924]u8,
            ///  For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
            GPIOE_HWCFGR10: mmio.Mmio(packed struct(u32) {
                ///  AHB_IOP
                AHB_IOP: u4,
                ///  AF_SIZE
                AF_SIZE: u4,
                ///  SPEED_CFG
                SPEED_CFG: u4,
                ///  LOCK_CFG
                LOCK_CFG: u4,
                ///  SEC_CFG
                SEC_CFG: u4,
                ///  OR_CFG
                OR_CFG: u4,
                padding: u8,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOE_HWCFGR9: mmio.Mmio(packed struct(u32) {
                ///  EN_IO
                EN_IO: u16,
                padding: u16,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOE_HWCFGR8: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO8
                AF_PRIO8: u4,
                ///  AF_PRIO9
                AF_PRIO9: u4,
                ///  AF_PRIO10
                AF_PRIO10: u4,
                ///  AF_PRIO11
                AF_PRIO11: u4,
                ///  AF_PRIO12
                AF_PRIO12: u4,
                ///  AF_PRIO13
                AF_PRIO13: u4,
                ///  AF_PRIO14
                AF_PRIO14: u4,
                ///  AF_PRIO15
                AF_PRIO15: u4,
            }),
            ///  GPIO hardware configuration register 7
            GPIOE_HWCFGR7: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO0
                AF_PRIO0: u4,
                ///  AF_PRIO1
                AF_PRIO1: u4,
                ///  AF_PRIO2
                AF_PRIO2: u4,
                ///  AF_PRIO3
                AF_PRIO3: u4,
                ///  AF_PRIO4
                AF_PRIO4: u4,
                ///  AF_PRIO5
                AF_PRIO5: u4,
                ///  AF_PRIO6
                AF_PRIO6: u4,
                ///  AF_PRIO7
                AF_PRIO7: u4,
            }),
            ///  GPIO hardware configuration register 6
            GPIOE_HWCFGR6: mmio.Mmio(packed struct(u32) {
                ///  MODER_RES
                MODER_RES: u32,
            }),
            ///  GPIO hardware configuration register 5
            GPIOE_HWCFGR5: mmio.Mmio(packed struct(u32) {
                ///  PUPDR_RES
                PUPDR_RES: u32,
            }),
            ///  GPIO hardware configuration register 4
            GPIOE_HWCFGR4: mmio.Mmio(packed struct(u32) {
                ///  OSPEED_RES
                OSPEED_RES: u32,
            }),
            ///  GPIO hardware configuration register 3
            GPIOE_HWCFGR3: mmio.Mmio(packed struct(u32) {
                ///  ODR_RES
                ODR_RES: u16,
                ///  OTYPER_RES
                OTYPER_RES: u16,
            }),
            ///  GPIO hardware configuration register 2
            GPIOE_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  AFRL_RES
                AFRL_RES: u32,
            }),
            ///  GPIO hardware configuration register 1
            GPIOE_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  AFRH_RES
                AFRH_RES: u32,
            }),
            ///  GPIO hardware configuration register 0
            GPIOE_HWCFGR0: mmio.Mmio(packed struct(u32) {
                ///  OR_RES
                OR_RES: u16,
                padding: u16,
            }),
            ///  GPIO version register
            GPIOE_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  GPIO identification register
            GPIOE_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  IPIDR
                IPIDR: u32,
            }),
            ///  GPIO size identification register
            GPIOE_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SIDR
                SIDR: u32,
            }),
        };

        ///  GPIOF
        pub const GPIOF = extern struct {
            ///  GPIO port mode register
            GPIOF_MODER: mmio.Mmio(packed struct(u32) {
                ///  MODER0
                MODER0: u2,
                ///  MODER1
                MODER1: u2,
                ///  MODER2
                MODER2: u2,
                ///  MODER3
                MODER3: u2,
                ///  MODER4
                MODER4: u2,
                ///  MODER5
                MODER5: u2,
                ///  MODER6
                MODER6: u2,
                ///  MODER7
                MODER7: u2,
                ///  MODER8
                MODER8: u2,
                ///  MODER9
                MODER9: u2,
                ///  MODER10
                MODER10: u2,
                ///  MODER11
                MODER11: u2,
                ///  MODER12
                MODER12: u2,
                ///  MODER13
                MODER13: u2,
                ///  MODER14
                MODER14: u2,
                ///  MODER15
                MODER15: u2,
            }),
            ///  GPIO port output type register
            GPIOF_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  OT0
                OT0: u1,
                ///  OT1
                OT1: u1,
                ///  OT2
                OT2: u1,
                ///  OT3
                OT3: u1,
                ///  OT4
                OT4: u1,
                ///  OT5
                OT5: u1,
                ///  OT6
                OT6: u1,
                ///  OT7
                OT7: u1,
                ///  OT8
                OT8: u1,
                ///  OT9
                OT9: u1,
                ///  OT10
                OT10: u1,
                ///  OT11
                OT11: u1,
                ///  OT12
                OT12: u1,
                ///  OT13
                OT13: u1,
                ///  OT14
                OT14: u1,
                ///  OT15
                OT15: u1,
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOF_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  OSPEEDR0
                OSPEEDR0: u2,
                ///  OSPEEDR1
                OSPEEDR1: u2,
                ///  OSPEEDR2
                OSPEEDR2: u2,
                ///  OSPEEDR3
                OSPEEDR3: u2,
                ///  OSPEEDR4
                OSPEEDR4: u2,
                ///  OSPEEDR5
                OSPEEDR5: u2,
                ///  OSPEEDR6
                OSPEEDR6: u2,
                ///  OSPEEDR7
                OSPEEDR7: u2,
                ///  OSPEEDR8
                OSPEEDR8: u2,
                ///  OSPEEDR9
                OSPEEDR9: u2,
                ///  OSPEEDR10
                OSPEEDR10: u2,
                ///  OSPEEDR11
                OSPEEDR11: u2,
                ///  OSPEEDR12
                OSPEEDR12: u2,
                ///  OSPEEDR13
                OSPEEDR13: u2,
                ///  OSPEEDR14
                OSPEEDR14: u2,
                ///  OSPEEDR15
                OSPEEDR15: u2,
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOF_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  PUPDR0
                PUPDR0: u2,
                ///  PUPDR1
                PUPDR1: u2,
                ///  PUPDR2
                PUPDR2: u2,
                ///  PUPDR3
                PUPDR3: u2,
                ///  PUPDR4
                PUPDR4: u2,
                ///  PUPDR5
                PUPDR5: u2,
                ///  PUPDR6
                PUPDR6: u2,
                ///  PUPDR7
                PUPDR7: u2,
                ///  PUPDR8
                PUPDR8: u2,
                ///  PUPDR9
                PUPDR9: u2,
                ///  PUPDR10
                PUPDR10: u2,
                ///  PUPDR11
                PUPDR11: u2,
                ///  PUPDR12
                PUPDR12: u2,
                ///  PUPDR13
                PUPDR13: u2,
                ///  PUPDR14
                PUPDR14: u2,
                ///  PUPDR15
                PUPDR15: u2,
            }),
            ///  GPIO port input data register
            GPIOF_IDR: mmio.Mmio(packed struct(u32) {
                ///  IDR0
                IDR0: u1,
                ///  IDR1
                IDR1: u1,
                ///  IDR2
                IDR2: u1,
                ///  IDR3
                IDR3: u1,
                ///  IDR4
                IDR4: u1,
                ///  IDR5
                IDR5: u1,
                ///  IDR6
                IDR6: u1,
                ///  IDR7
                IDR7: u1,
                ///  IDR8
                IDR8: u1,
                ///  IDR9
                IDR9: u1,
                ///  IDR10
                IDR10: u1,
                ///  IDR11
                IDR11: u1,
                ///  IDR12
                IDR12: u1,
                ///  IDR13
                IDR13: u1,
                ///  IDR14
                IDR14: u1,
                ///  IDR15
                IDR15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOF_ODR: mmio.Mmio(packed struct(u32) {
                ///  ODR0
                ODR0: u1,
                ///  ODR1
                ODR1: u1,
                ///  ODR2
                ODR2: u1,
                ///  ODR3
                ODR3: u1,
                ///  ODR4
                ODR4: u1,
                ///  ODR5
                ODR5: u1,
                ///  ODR6
                ODR6: u1,
                ///  ODR7
                ODR7: u1,
                ///  ODR8
                ODR8: u1,
                ///  ODR9
                ODR9: u1,
                ///  ODR10
                ODR10: u1,
                ///  ODR11
                ODR11: u1,
                ///  ODR12
                ODR12: u1,
                ///  ODR13
                ODR13: u1,
                ///  ODR14
                ODR14: u1,
                ///  ODR15
                ODR15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOF_BSRR: mmio.Mmio(packed struct(u32) {
                ///  BS0
                BS0: u1,
                ///  BS1
                BS1: u1,
                ///  BS2
                BS2: u1,
                ///  BS3
                BS3: u1,
                ///  BS4
                BS4: u1,
                ///  BS5
                BS5: u1,
                ///  BS6
                BS6: u1,
                ///  BS7
                BS7: u1,
                ///  BS8
                BS8: u1,
                ///  BS9
                BS9: u1,
                ///  BS10
                BS10: u1,
                ///  BS11
                BS11: u1,
                ///  BS12
                BS12: u1,
                ///  BS13
                BS13: u1,
                ///  BS14
                BS14: u1,
                ///  BS15
                BS15: u1,
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
            }),
            ///  This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
            GPIOF_LCKR: mmio.Mmio(packed struct(u32) {
                ///  LCK0
                LCK0: u1,
                ///  LCK1
                LCK1: u1,
                ///  LCK2
                LCK2: u1,
                ///  LCK3
                LCK3: u1,
                ///  LCK4
                LCK4: u1,
                ///  LCK5
                LCK5: u1,
                ///  LCK6
                LCK6: u1,
                ///  LCK7
                LCK7: u1,
                ///  LCK8
                LCK8: u1,
                ///  LCK9
                LCK9: u1,
                ///  LCK10
                LCK10: u1,
                ///  LCK11
                LCK11: u1,
                ///  LCK12
                LCK12: u1,
                ///  LCK13
                LCK13: u1,
                ///  LCK14
                LCK14: u1,
                ///  LCK15
                LCK15: u1,
                ///  LCKK
                LCKK: u1,
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOF_AFRL: mmio.Mmio(packed struct(u32) {
                ///  AFR0
                AFR0: u4,
                ///  AFR1
                AFR1: u4,
                ///  AFR2
                AFR2: u4,
                ///  AFR3
                AFR3: u4,
                ///  AFR4
                AFR4: u4,
                ///  AFR5
                AFR5: u4,
                ///  AFR6
                AFR6: u4,
                ///  AFR7
                AFR7: u4,
            }),
            ///  GPIO alternate function high register
            GPIOF_AFRH: mmio.Mmio(packed struct(u32) {
                ///  AFR8
                AFR8: u4,
                ///  AFR9
                AFR9: u4,
                ///  AFR10
                AFR10: u4,
                ///  AFR11
                AFR11: u4,
                ///  AFR12
                AFR12: u4,
                ///  AFR13
                AFR13: u4,
                ///  AFR14
                AFR14: u4,
                ///  AFR15
                AFR15: u4,
            }),
            ///  GPIO port bit reset register
            GPIOF_BRR: mmio.Mmio(packed struct(u32) {
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
                padding: u16,
            }),
            reserved968: [924]u8,
            ///  For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
            GPIOF_HWCFGR10: mmio.Mmio(packed struct(u32) {
                ///  AHB_IOP
                AHB_IOP: u4,
                ///  AF_SIZE
                AF_SIZE: u4,
                ///  SPEED_CFG
                SPEED_CFG: u4,
                ///  LOCK_CFG
                LOCK_CFG: u4,
                ///  SEC_CFG
                SEC_CFG: u4,
                ///  OR_CFG
                OR_CFG: u4,
                padding: u8,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOF_HWCFGR9: mmio.Mmio(packed struct(u32) {
                ///  EN_IO
                EN_IO: u16,
                padding: u16,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOF_HWCFGR8: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO8
                AF_PRIO8: u4,
                ///  AF_PRIO9
                AF_PRIO9: u4,
                ///  AF_PRIO10
                AF_PRIO10: u4,
                ///  AF_PRIO11
                AF_PRIO11: u4,
                ///  AF_PRIO12
                AF_PRIO12: u4,
                ///  AF_PRIO13
                AF_PRIO13: u4,
                ///  AF_PRIO14
                AF_PRIO14: u4,
                ///  AF_PRIO15
                AF_PRIO15: u4,
            }),
            ///  GPIO hardware configuration register 7
            GPIOF_HWCFGR7: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO0
                AF_PRIO0: u4,
                ///  AF_PRIO1
                AF_PRIO1: u4,
                ///  AF_PRIO2
                AF_PRIO2: u4,
                ///  AF_PRIO3
                AF_PRIO3: u4,
                ///  AF_PRIO4
                AF_PRIO4: u4,
                ///  AF_PRIO5
                AF_PRIO5: u4,
                ///  AF_PRIO6
                AF_PRIO6: u4,
                ///  AF_PRIO7
                AF_PRIO7: u4,
            }),
            ///  GPIO hardware configuration register 6
            GPIOF_HWCFGR6: mmio.Mmio(packed struct(u32) {
                ///  MODER_RES
                MODER_RES: u32,
            }),
            ///  GPIO hardware configuration register 5
            GPIOF_HWCFGR5: mmio.Mmio(packed struct(u32) {
                ///  PUPDR_RES
                PUPDR_RES: u32,
            }),
            ///  GPIO hardware configuration register 4
            GPIOF_HWCFGR4: mmio.Mmio(packed struct(u32) {
                ///  OSPEED_RES
                OSPEED_RES: u32,
            }),
            ///  GPIO hardware configuration register 3
            GPIOF_HWCFGR3: mmio.Mmio(packed struct(u32) {
                ///  ODR_RES
                ODR_RES: u16,
                ///  OTYPER_RES
                OTYPER_RES: u16,
            }),
            ///  GPIO hardware configuration register 2
            GPIOF_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  AFRL_RES
                AFRL_RES: u32,
            }),
            ///  GPIO hardware configuration register 1
            GPIOF_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  AFRH_RES
                AFRH_RES: u32,
            }),
            ///  GPIO hardware configuration register 0
            GPIOF_HWCFGR0: mmio.Mmio(packed struct(u32) {
                ///  OR_RES
                OR_RES: u16,
                padding: u16,
            }),
            ///  GPIO version register
            GPIOF_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  GPIO identification register
            GPIOF_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  IPIDR
                IPIDR: u32,
            }),
            ///  GPIO size identification register
            GPIOF_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SIDR
                SIDR: u32,
            }),
        };

        ///  GPIOG
        pub const GPIOG = extern struct {
            ///  GPIO port mode register
            GPIOG_MODER: mmio.Mmio(packed struct(u32) {
                ///  MODER0
                MODER0: u2,
                ///  MODER1
                MODER1: u2,
                ///  MODER2
                MODER2: u2,
                ///  MODER3
                MODER3: u2,
                ///  MODER4
                MODER4: u2,
                ///  MODER5
                MODER5: u2,
                ///  MODER6
                MODER6: u2,
                ///  MODER7
                MODER7: u2,
                ///  MODER8
                MODER8: u2,
                ///  MODER9
                MODER9: u2,
                ///  MODER10
                MODER10: u2,
                ///  MODER11
                MODER11: u2,
                ///  MODER12
                MODER12: u2,
                ///  MODER13
                MODER13: u2,
                ///  MODER14
                MODER14: u2,
                ///  MODER15
                MODER15: u2,
            }),
            ///  GPIO port output type register
            GPIOG_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  OT0
                OT0: u1,
                ///  OT1
                OT1: u1,
                ///  OT2
                OT2: u1,
                ///  OT3
                OT3: u1,
                ///  OT4
                OT4: u1,
                ///  OT5
                OT5: u1,
                ///  OT6
                OT6: u1,
                ///  OT7
                OT7: u1,
                ///  OT8
                OT8: u1,
                ///  OT9
                OT9: u1,
                ///  OT10
                OT10: u1,
                ///  OT11
                OT11: u1,
                ///  OT12
                OT12: u1,
                ///  OT13
                OT13: u1,
                ///  OT14
                OT14: u1,
                ///  OT15
                OT15: u1,
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOG_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  OSPEEDR0
                OSPEEDR0: u2,
                ///  OSPEEDR1
                OSPEEDR1: u2,
                ///  OSPEEDR2
                OSPEEDR2: u2,
                ///  OSPEEDR3
                OSPEEDR3: u2,
                ///  OSPEEDR4
                OSPEEDR4: u2,
                ///  OSPEEDR5
                OSPEEDR5: u2,
                ///  OSPEEDR6
                OSPEEDR6: u2,
                ///  OSPEEDR7
                OSPEEDR7: u2,
                ///  OSPEEDR8
                OSPEEDR8: u2,
                ///  OSPEEDR9
                OSPEEDR9: u2,
                ///  OSPEEDR10
                OSPEEDR10: u2,
                ///  OSPEEDR11
                OSPEEDR11: u2,
                ///  OSPEEDR12
                OSPEEDR12: u2,
                ///  OSPEEDR13
                OSPEEDR13: u2,
                ///  OSPEEDR14
                OSPEEDR14: u2,
                ///  OSPEEDR15
                OSPEEDR15: u2,
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOG_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  PUPDR0
                PUPDR0: u2,
                ///  PUPDR1
                PUPDR1: u2,
                ///  PUPDR2
                PUPDR2: u2,
                ///  PUPDR3
                PUPDR3: u2,
                ///  PUPDR4
                PUPDR4: u2,
                ///  PUPDR5
                PUPDR5: u2,
                ///  PUPDR6
                PUPDR6: u2,
                ///  PUPDR7
                PUPDR7: u2,
                ///  PUPDR8
                PUPDR8: u2,
                ///  PUPDR9
                PUPDR9: u2,
                ///  PUPDR10
                PUPDR10: u2,
                ///  PUPDR11
                PUPDR11: u2,
                ///  PUPDR12
                PUPDR12: u2,
                ///  PUPDR13
                PUPDR13: u2,
                ///  PUPDR14
                PUPDR14: u2,
                ///  PUPDR15
                PUPDR15: u2,
            }),
            ///  GPIO port input data register
            GPIOG_IDR: mmio.Mmio(packed struct(u32) {
                ///  IDR0
                IDR0: u1,
                ///  IDR1
                IDR1: u1,
                ///  IDR2
                IDR2: u1,
                ///  IDR3
                IDR3: u1,
                ///  IDR4
                IDR4: u1,
                ///  IDR5
                IDR5: u1,
                ///  IDR6
                IDR6: u1,
                ///  IDR7
                IDR7: u1,
                ///  IDR8
                IDR8: u1,
                ///  IDR9
                IDR9: u1,
                ///  IDR10
                IDR10: u1,
                ///  IDR11
                IDR11: u1,
                ///  IDR12
                IDR12: u1,
                ///  IDR13
                IDR13: u1,
                ///  IDR14
                IDR14: u1,
                ///  IDR15
                IDR15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOG_ODR: mmio.Mmio(packed struct(u32) {
                ///  ODR0
                ODR0: u1,
                ///  ODR1
                ODR1: u1,
                ///  ODR2
                ODR2: u1,
                ///  ODR3
                ODR3: u1,
                ///  ODR4
                ODR4: u1,
                ///  ODR5
                ODR5: u1,
                ///  ODR6
                ODR6: u1,
                ///  ODR7
                ODR7: u1,
                ///  ODR8
                ODR8: u1,
                ///  ODR9
                ODR9: u1,
                ///  ODR10
                ODR10: u1,
                ///  ODR11
                ODR11: u1,
                ///  ODR12
                ODR12: u1,
                ///  ODR13
                ODR13: u1,
                ///  ODR14
                ODR14: u1,
                ///  ODR15
                ODR15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOG_BSRR: mmio.Mmio(packed struct(u32) {
                ///  BS0
                BS0: u1,
                ///  BS1
                BS1: u1,
                ///  BS2
                BS2: u1,
                ///  BS3
                BS3: u1,
                ///  BS4
                BS4: u1,
                ///  BS5
                BS5: u1,
                ///  BS6
                BS6: u1,
                ///  BS7
                BS7: u1,
                ///  BS8
                BS8: u1,
                ///  BS9
                BS9: u1,
                ///  BS10
                BS10: u1,
                ///  BS11
                BS11: u1,
                ///  BS12
                BS12: u1,
                ///  BS13
                BS13: u1,
                ///  BS14
                BS14: u1,
                ///  BS15
                BS15: u1,
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
            }),
            ///  This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
            GPIOG_LCKR: mmio.Mmio(packed struct(u32) {
                ///  LCK0
                LCK0: u1,
                ///  LCK1
                LCK1: u1,
                ///  LCK2
                LCK2: u1,
                ///  LCK3
                LCK3: u1,
                ///  LCK4
                LCK4: u1,
                ///  LCK5
                LCK5: u1,
                ///  LCK6
                LCK6: u1,
                ///  LCK7
                LCK7: u1,
                ///  LCK8
                LCK8: u1,
                ///  LCK9
                LCK9: u1,
                ///  LCK10
                LCK10: u1,
                ///  LCK11
                LCK11: u1,
                ///  LCK12
                LCK12: u1,
                ///  LCK13
                LCK13: u1,
                ///  LCK14
                LCK14: u1,
                ///  LCK15
                LCK15: u1,
                ///  LCKK
                LCKK: u1,
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOG_AFRL: mmio.Mmio(packed struct(u32) {
                ///  AFR0
                AFR0: u4,
                ///  AFR1
                AFR1: u4,
                ///  AFR2
                AFR2: u4,
                ///  AFR3
                AFR3: u4,
                ///  AFR4
                AFR4: u4,
                ///  AFR5
                AFR5: u4,
                ///  AFR6
                AFR6: u4,
                ///  AFR7
                AFR7: u4,
            }),
            ///  GPIO alternate function high register
            GPIOG_AFRH: mmio.Mmio(packed struct(u32) {
                ///  AFR8
                AFR8: u4,
                ///  AFR9
                AFR9: u4,
                ///  AFR10
                AFR10: u4,
                ///  AFR11
                AFR11: u4,
                ///  AFR12
                AFR12: u4,
                ///  AFR13
                AFR13: u4,
                ///  AFR14
                AFR14: u4,
                ///  AFR15
                AFR15: u4,
            }),
            ///  GPIO port bit reset register
            GPIOG_BRR: mmio.Mmio(packed struct(u32) {
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
                padding: u16,
            }),
            reserved968: [924]u8,
            ///  For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
            GPIOG_HWCFGR10: mmio.Mmio(packed struct(u32) {
                ///  AHB_IOP
                AHB_IOP: u4,
                ///  AF_SIZE
                AF_SIZE: u4,
                ///  SPEED_CFG
                SPEED_CFG: u4,
                ///  LOCK_CFG
                LOCK_CFG: u4,
                ///  SEC_CFG
                SEC_CFG: u4,
                ///  OR_CFG
                OR_CFG: u4,
                padding: u8,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOG_HWCFGR9: mmio.Mmio(packed struct(u32) {
                ///  EN_IO
                EN_IO: u16,
                padding: u16,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOG_HWCFGR8: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO8
                AF_PRIO8: u4,
                ///  AF_PRIO9
                AF_PRIO9: u4,
                ///  AF_PRIO10
                AF_PRIO10: u4,
                ///  AF_PRIO11
                AF_PRIO11: u4,
                ///  AF_PRIO12
                AF_PRIO12: u4,
                ///  AF_PRIO13
                AF_PRIO13: u4,
                ///  AF_PRIO14
                AF_PRIO14: u4,
                ///  AF_PRIO15
                AF_PRIO15: u4,
            }),
            ///  GPIO hardware configuration register 7
            GPIOG_HWCFGR7: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO0
                AF_PRIO0: u4,
                ///  AF_PRIO1
                AF_PRIO1: u4,
                ///  AF_PRIO2
                AF_PRIO2: u4,
                ///  AF_PRIO3
                AF_PRIO3: u4,
                ///  AF_PRIO4
                AF_PRIO4: u4,
                ///  AF_PRIO5
                AF_PRIO5: u4,
                ///  AF_PRIO6
                AF_PRIO6: u4,
                ///  AF_PRIO7
                AF_PRIO7: u4,
            }),
            ///  GPIO hardware configuration register 6
            GPIOG_HWCFGR6: mmio.Mmio(packed struct(u32) {
                ///  MODER_RES
                MODER_RES: u32,
            }),
            ///  GPIO hardware configuration register 5
            GPIOG_HWCFGR5: mmio.Mmio(packed struct(u32) {
                ///  PUPDR_RES
                PUPDR_RES: u32,
            }),
            ///  GPIO hardware configuration register 4
            GPIOG_HWCFGR4: mmio.Mmio(packed struct(u32) {
                ///  OSPEED_RES
                OSPEED_RES: u32,
            }),
            ///  GPIO hardware configuration register 3
            GPIOG_HWCFGR3: mmio.Mmio(packed struct(u32) {
                ///  ODR_RES
                ODR_RES: u16,
                ///  OTYPER_RES
                OTYPER_RES: u16,
            }),
            ///  GPIO hardware configuration register 2
            GPIOG_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  AFRL_RES
                AFRL_RES: u32,
            }),
            ///  GPIO hardware configuration register 1
            GPIOG_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  AFRH_RES
                AFRH_RES: u32,
            }),
            ///  GPIO hardware configuration register 0
            GPIOG_HWCFGR0: mmio.Mmio(packed struct(u32) {
                ///  OR_RES
                OR_RES: u16,
                padding: u16,
            }),
            ///  GPIO version register
            GPIOG_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  GPIO identification register
            GPIOG_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  IPIDR
                IPIDR: u32,
            }),
            ///  GPIO size identification register
            GPIOG_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SIDR
                SIDR: u32,
            }),
        };

        ///  GPIOH
        pub const GPIOH = extern struct {
            ///  GPIO port mode register
            GPIOH_MODER: mmio.Mmio(packed struct(u32) {
                ///  MODER0
                MODER0: u2,
                ///  MODER1
                MODER1: u2,
                ///  MODER2
                MODER2: u2,
                ///  MODER3
                MODER3: u2,
                ///  MODER4
                MODER4: u2,
                ///  MODER5
                MODER5: u2,
                ///  MODER6
                MODER6: u2,
                ///  MODER7
                MODER7: u2,
                ///  MODER8
                MODER8: u2,
                ///  MODER9
                MODER9: u2,
                ///  MODER10
                MODER10: u2,
                ///  MODER11
                MODER11: u2,
                ///  MODER12
                MODER12: u2,
                ///  MODER13
                MODER13: u2,
                ///  MODER14
                MODER14: u2,
                ///  MODER15
                MODER15: u2,
            }),
            ///  GPIO port output type register
            GPIOH_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  OT0
                OT0: u1,
                ///  OT1
                OT1: u1,
                ///  OT2
                OT2: u1,
                ///  OT3
                OT3: u1,
                ///  OT4
                OT4: u1,
                ///  OT5
                OT5: u1,
                ///  OT6
                OT6: u1,
                ///  OT7
                OT7: u1,
                ///  OT8
                OT8: u1,
                ///  OT9
                OT9: u1,
                ///  OT10
                OT10: u1,
                ///  OT11
                OT11: u1,
                ///  OT12
                OT12: u1,
                ///  OT13
                OT13: u1,
                ///  OT14
                OT14: u1,
                ///  OT15
                OT15: u1,
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOH_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  OSPEEDR0
                OSPEEDR0: u2,
                ///  OSPEEDR1
                OSPEEDR1: u2,
                ///  OSPEEDR2
                OSPEEDR2: u2,
                ///  OSPEEDR3
                OSPEEDR3: u2,
                ///  OSPEEDR4
                OSPEEDR4: u2,
                ///  OSPEEDR5
                OSPEEDR5: u2,
                ///  OSPEEDR6
                OSPEEDR6: u2,
                ///  OSPEEDR7
                OSPEEDR7: u2,
                ///  OSPEEDR8
                OSPEEDR8: u2,
                ///  OSPEEDR9
                OSPEEDR9: u2,
                ///  OSPEEDR10
                OSPEEDR10: u2,
                ///  OSPEEDR11
                OSPEEDR11: u2,
                ///  OSPEEDR12
                OSPEEDR12: u2,
                ///  OSPEEDR13
                OSPEEDR13: u2,
                ///  OSPEEDR14
                OSPEEDR14: u2,
                ///  OSPEEDR15
                OSPEEDR15: u2,
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOH_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  PUPDR0
                PUPDR0: u2,
                ///  PUPDR1
                PUPDR1: u2,
                ///  PUPDR2
                PUPDR2: u2,
                ///  PUPDR3
                PUPDR3: u2,
                ///  PUPDR4
                PUPDR4: u2,
                ///  PUPDR5
                PUPDR5: u2,
                ///  PUPDR6
                PUPDR6: u2,
                ///  PUPDR7
                PUPDR7: u2,
                ///  PUPDR8
                PUPDR8: u2,
                ///  PUPDR9
                PUPDR9: u2,
                ///  PUPDR10
                PUPDR10: u2,
                ///  PUPDR11
                PUPDR11: u2,
                ///  PUPDR12
                PUPDR12: u2,
                ///  PUPDR13
                PUPDR13: u2,
                ///  PUPDR14
                PUPDR14: u2,
                ///  PUPDR15
                PUPDR15: u2,
            }),
            ///  GPIO port input data register
            GPIOH_IDR: mmio.Mmio(packed struct(u32) {
                ///  IDR0
                IDR0: u1,
                ///  IDR1
                IDR1: u1,
                ///  IDR2
                IDR2: u1,
                ///  IDR3
                IDR3: u1,
                ///  IDR4
                IDR4: u1,
                ///  IDR5
                IDR5: u1,
                ///  IDR6
                IDR6: u1,
                ///  IDR7
                IDR7: u1,
                ///  IDR8
                IDR8: u1,
                ///  IDR9
                IDR9: u1,
                ///  IDR10
                IDR10: u1,
                ///  IDR11
                IDR11: u1,
                ///  IDR12
                IDR12: u1,
                ///  IDR13
                IDR13: u1,
                ///  IDR14
                IDR14: u1,
                ///  IDR15
                IDR15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOH_ODR: mmio.Mmio(packed struct(u32) {
                ///  ODR0
                ODR0: u1,
                ///  ODR1
                ODR1: u1,
                ///  ODR2
                ODR2: u1,
                ///  ODR3
                ODR3: u1,
                ///  ODR4
                ODR4: u1,
                ///  ODR5
                ODR5: u1,
                ///  ODR6
                ODR6: u1,
                ///  ODR7
                ODR7: u1,
                ///  ODR8
                ODR8: u1,
                ///  ODR9
                ODR9: u1,
                ///  ODR10
                ODR10: u1,
                ///  ODR11
                ODR11: u1,
                ///  ODR12
                ODR12: u1,
                ///  ODR13
                ODR13: u1,
                ///  ODR14
                ODR14: u1,
                ///  ODR15
                ODR15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOH_BSRR: mmio.Mmio(packed struct(u32) {
                ///  BS0
                BS0: u1,
                ///  BS1
                BS1: u1,
                ///  BS2
                BS2: u1,
                ///  BS3
                BS3: u1,
                ///  BS4
                BS4: u1,
                ///  BS5
                BS5: u1,
                ///  BS6
                BS6: u1,
                ///  BS7
                BS7: u1,
                ///  BS8
                BS8: u1,
                ///  BS9
                BS9: u1,
                ///  BS10
                BS10: u1,
                ///  BS11
                BS11: u1,
                ///  BS12
                BS12: u1,
                ///  BS13
                BS13: u1,
                ///  BS14
                BS14: u1,
                ///  BS15
                BS15: u1,
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
            }),
            ///  This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
            GPIOH_LCKR: mmio.Mmio(packed struct(u32) {
                ///  LCK0
                LCK0: u1,
                ///  LCK1
                LCK1: u1,
                ///  LCK2
                LCK2: u1,
                ///  LCK3
                LCK3: u1,
                ///  LCK4
                LCK4: u1,
                ///  LCK5
                LCK5: u1,
                ///  LCK6
                LCK6: u1,
                ///  LCK7
                LCK7: u1,
                ///  LCK8
                LCK8: u1,
                ///  LCK9
                LCK9: u1,
                ///  LCK10
                LCK10: u1,
                ///  LCK11
                LCK11: u1,
                ///  LCK12
                LCK12: u1,
                ///  LCK13
                LCK13: u1,
                ///  LCK14
                LCK14: u1,
                ///  LCK15
                LCK15: u1,
                ///  LCKK
                LCKK: u1,
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOH_AFRL: mmio.Mmio(packed struct(u32) {
                ///  AFR0
                AFR0: u4,
                ///  AFR1
                AFR1: u4,
                ///  AFR2
                AFR2: u4,
                ///  AFR3
                AFR3: u4,
                ///  AFR4
                AFR4: u4,
                ///  AFR5
                AFR5: u4,
                ///  AFR6
                AFR6: u4,
                ///  AFR7
                AFR7: u4,
            }),
            ///  GPIO alternate function high register
            GPIOH_AFRH: mmio.Mmio(packed struct(u32) {
                ///  AFR8
                AFR8: u4,
                ///  AFR9
                AFR9: u4,
                ///  AFR10
                AFR10: u4,
                ///  AFR11
                AFR11: u4,
                ///  AFR12
                AFR12: u4,
                ///  AFR13
                AFR13: u4,
                ///  AFR14
                AFR14: u4,
                ///  AFR15
                AFR15: u4,
            }),
            ///  GPIO port bit reset register
            GPIOH_BRR: mmio.Mmio(packed struct(u32) {
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
                padding: u16,
            }),
            reserved968: [924]u8,
            ///  For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
            GPIOH_HWCFGR10: mmio.Mmio(packed struct(u32) {
                ///  AHB_IOP
                AHB_IOP: u4,
                ///  AF_SIZE
                AF_SIZE: u4,
                ///  SPEED_CFG
                SPEED_CFG: u4,
                ///  LOCK_CFG
                LOCK_CFG: u4,
                ///  SEC_CFG
                SEC_CFG: u4,
                ///  OR_CFG
                OR_CFG: u4,
                padding: u8,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOH_HWCFGR9: mmio.Mmio(packed struct(u32) {
                ///  EN_IO
                EN_IO: u16,
                padding: u16,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOH_HWCFGR8: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO8
                AF_PRIO8: u4,
                ///  AF_PRIO9
                AF_PRIO9: u4,
                ///  AF_PRIO10
                AF_PRIO10: u4,
                ///  AF_PRIO11
                AF_PRIO11: u4,
                ///  AF_PRIO12
                AF_PRIO12: u4,
                ///  AF_PRIO13
                AF_PRIO13: u4,
                ///  AF_PRIO14
                AF_PRIO14: u4,
                ///  AF_PRIO15
                AF_PRIO15: u4,
            }),
            ///  GPIO hardware configuration register 7
            GPIOH_HWCFGR7: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO0
                AF_PRIO0: u4,
                ///  AF_PRIO1
                AF_PRIO1: u4,
                ///  AF_PRIO2
                AF_PRIO2: u4,
                ///  AF_PRIO3
                AF_PRIO3: u4,
                ///  AF_PRIO4
                AF_PRIO4: u4,
                ///  AF_PRIO5
                AF_PRIO5: u4,
                ///  AF_PRIO6
                AF_PRIO6: u4,
                ///  AF_PRIO7
                AF_PRIO7: u4,
            }),
            ///  GPIO hardware configuration register 6
            GPIOH_HWCFGR6: mmio.Mmio(packed struct(u32) {
                ///  MODER_RES
                MODER_RES: u32,
            }),
            ///  GPIO hardware configuration register 5
            GPIOH_HWCFGR5: mmio.Mmio(packed struct(u32) {
                ///  PUPDR_RES
                PUPDR_RES: u32,
            }),
            ///  GPIO hardware configuration register 4
            GPIOH_HWCFGR4: mmio.Mmio(packed struct(u32) {
                ///  OSPEED_RES
                OSPEED_RES: u32,
            }),
            ///  GPIO hardware configuration register 3
            GPIOH_HWCFGR3: mmio.Mmio(packed struct(u32) {
                ///  ODR_RES
                ODR_RES: u16,
                ///  OTYPER_RES
                OTYPER_RES: u16,
            }),
            ///  GPIO hardware configuration register 2
            GPIOH_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  AFRL_RES
                AFRL_RES: u32,
            }),
            ///  GPIO hardware configuration register 1
            GPIOH_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  AFRH_RES
                AFRH_RES: u32,
            }),
            ///  GPIO hardware configuration register 0
            GPIOH_HWCFGR0: mmio.Mmio(packed struct(u32) {
                ///  OR_RES
                OR_RES: u16,
                padding: u16,
            }),
            ///  GPIO version register
            GPIOH_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  GPIO identification register
            GPIOH_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  IPIDR
                IPIDR: u32,
            }),
            ///  GPIO size identification register
            GPIOH_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SIDR
                SIDR: u32,
            }),
        };

        ///  GPIOI
        pub const GPIOI = extern struct {
            ///  GPIO port mode register
            GPIOI_MODER: mmio.Mmio(packed struct(u32) {
                ///  MODER0
                MODER0: u2,
                ///  MODER1
                MODER1: u2,
                ///  MODER2
                MODER2: u2,
                ///  MODER3
                MODER3: u2,
                ///  MODER4
                MODER4: u2,
                ///  MODER5
                MODER5: u2,
                ///  MODER6
                MODER6: u2,
                ///  MODER7
                MODER7: u2,
                ///  MODER8
                MODER8: u2,
                ///  MODER9
                MODER9: u2,
                ///  MODER10
                MODER10: u2,
                ///  MODER11
                MODER11: u2,
                ///  MODER12
                MODER12: u2,
                ///  MODER13
                MODER13: u2,
                ///  MODER14
                MODER14: u2,
                ///  MODER15
                MODER15: u2,
            }),
            ///  GPIO port output type register
            GPIOI_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  OT0
                OT0: u1,
                ///  OT1
                OT1: u1,
                ///  OT2
                OT2: u1,
                ///  OT3
                OT3: u1,
                ///  OT4
                OT4: u1,
                ///  OT5
                OT5: u1,
                ///  OT6
                OT6: u1,
                ///  OT7
                OT7: u1,
                ///  OT8
                OT8: u1,
                ///  OT9
                OT9: u1,
                ///  OT10
                OT10: u1,
                ///  OT11
                OT11: u1,
                ///  OT12
                OT12: u1,
                ///  OT13
                OT13: u1,
                ///  OT14
                OT14: u1,
                ///  OT15
                OT15: u1,
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOI_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  OSPEEDR0
                OSPEEDR0: u2,
                ///  OSPEEDR1
                OSPEEDR1: u2,
                ///  OSPEEDR2
                OSPEEDR2: u2,
                ///  OSPEEDR3
                OSPEEDR3: u2,
                ///  OSPEEDR4
                OSPEEDR4: u2,
                ///  OSPEEDR5
                OSPEEDR5: u2,
                ///  OSPEEDR6
                OSPEEDR6: u2,
                ///  OSPEEDR7
                OSPEEDR7: u2,
                ///  OSPEEDR8
                OSPEEDR8: u2,
                ///  OSPEEDR9
                OSPEEDR9: u2,
                ///  OSPEEDR10
                OSPEEDR10: u2,
                ///  OSPEEDR11
                OSPEEDR11: u2,
                ///  OSPEEDR12
                OSPEEDR12: u2,
                ///  OSPEEDR13
                OSPEEDR13: u2,
                ///  OSPEEDR14
                OSPEEDR14: u2,
                ///  OSPEEDR15
                OSPEEDR15: u2,
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOI_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  PUPDR0
                PUPDR0: u2,
                ///  PUPDR1
                PUPDR1: u2,
                ///  PUPDR2
                PUPDR2: u2,
                ///  PUPDR3
                PUPDR3: u2,
                ///  PUPDR4
                PUPDR4: u2,
                ///  PUPDR5
                PUPDR5: u2,
                ///  PUPDR6
                PUPDR6: u2,
                ///  PUPDR7
                PUPDR7: u2,
                ///  PUPDR8
                PUPDR8: u2,
                ///  PUPDR9
                PUPDR9: u2,
                ///  PUPDR10
                PUPDR10: u2,
                ///  PUPDR11
                PUPDR11: u2,
                ///  PUPDR12
                PUPDR12: u2,
                ///  PUPDR13
                PUPDR13: u2,
                ///  PUPDR14
                PUPDR14: u2,
                ///  PUPDR15
                PUPDR15: u2,
            }),
            ///  GPIO port input data register
            GPIOI_IDR: mmio.Mmio(packed struct(u32) {
                ///  IDR0
                IDR0: u1,
                ///  IDR1
                IDR1: u1,
                ///  IDR2
                IDR2: u1,
                ///  IDR3
                IDR3: u1,
                ///  IDR4
                IDR4: u1,
                ///  IDR5
                IDR5: u1,
                ///  IDR6
                IDR6: u1,
                ///  IDR7
                IDR7: u1,
                ///  IDR8
                IDR8: u1,
                ///  IDR9
                IDR9: u1,
                ///  IDR10
                IDR10: u1,
                ///  IDR11
                IDR11: u1,
                ///  IDR12
                IDR12: u1,
                ///  IDR13
                IDR13: u1,
                ///  IDR14
                IDR14: u1,
                ///  IDR15
                IDR15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOI_ODR: mmio.Mmio(packed struct(u32) {
                ///  ODR0
                ODR0: u1,
                ///  ODR1
                ODR1: u1,
                ///  ODR2
                ODR2: u1,
                ///  ODR3
                ODR3: u1,
                ///  ODR4
                ODR4: u1,
                ///  ODR5
                ODR5: u1,
                ///  ODR6
                ODR6: u1,
                ///  ODR7
                ODR7: u1,
                ///  ODR8
                ODR8: u1,
                ///  ODR9
                ODR9: u1,
                ///  ODR10
                ODR10: u1,
                ///  ODR11
                ODR11: u1,
                ///  ODR12
                ODR12: u1,
                ///  ODR13
                ODR13: u1,
                ///  ODR14
                ODR14: u1,
                ///  ODR15
                ODR15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOI_BSRR: mmio.Mmio(packed struct(u32) {
                ///  BS0
                BS0: u1,
                ///  BS1
                BS1: u1,
                ///  BS2
                BS2: u1,
                ///  BS3
                BS3: u1,
                ///  BS4
                BS4: u1,
                ///  BS5
                BS5: u1,
                ///  BS6
                BS6: u1,
                ///  BS7
                BS7: u1,
                ///  BS8
                BS8: u1,
                ///  BS9
                BS9: u1,
                ///  BS10
                BS10: u1,
                ///  BS11
                BS11: u1,
                ///  BS12
                BS12: u1,
                ///  BS13
                BS13: u1,
                ///  BS14
                BS14: u1,
                ///  BS15
                BS15: u1,
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
            }),
            ///  This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
            GPIOI_LCKR: mmio.Mmio(packed struct(u32) {
                ///  LCK0
                LCK0: u1,
                ///  LCK1
                LCK1: u1,
                ///  LCK2
                LCK2: u1,
                ///  LCK3
                LCK3: u1,
                ///  LCK4
                LCK4: u1,
                ///  LCK5
                LCK5: u1,
                ///  LCK6
                LCK6: u1,
                ///  LCK7
                LCK7: u1,
                ///  LCK8
                LCK8: u1,
                ///  LCK9
                LCK9: u1,
                ///  LCK10
                LCK10: u1,
                ///  LCK11
                LCK11: u1,
                ///  LCK12
                LCK12: u1,
                ///  LCK13
                LCK13: u1,
                ///  LCK14
                LCK14: u1,
                ///  LCK15
                LCK15: u1,
                ///  LCKK
                LCKK: u1,
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOI_AFRL: mmio.Mmio(packed struct(u32) {
                ///  AFR0
                AFR0: u4,
                ///  AFR1
                AFR1: u4,
                ///  AFR2
                AFR2: u4,
                ///  AFR3
                AFR3: u4,
                ///  AFR4
                AFR4: u4,
                ///  AFR5
                AFR5: u4,
                ///  AFR6
                AFR6: u4,
                ///  AFR7
                AFR7: u4,
            }),
            ///  GPIO alternate function high register
            GPIOI_AFRH: mmio.Mmio(packed struct(u32) {
                ///  AFR8
                AFR8: u4,
                ///  AFR9
                AFR9: u4,
                ///  AFR10
                AFR10: u4,
                ///  AFR11
                AFR11: u4,
                ///  AFR12
                AFR12: u4,
                ///  AFR13
                AFR13: u4,
                ///  AFR14
                AFR14: u4,
                ///  AFR15
                AFR15: u4,
            }),
            ///  GPIO port bit reset register
            GPIOI_BRR: mmio.Mmio(packed struct(u32) {
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
                padding: u16,
            }),
            reserved968: [924]u8,
            ///  For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
            GPIOI_HWCFGR10: mmio.Mmio(packed struct(u32) {
                ///  AHB_IOP
                AHB_IOP: u4,
                ///  AF_SIZE
                AF_SIZE: u4,
                ///  SPEED_CFG
                SPEED_CFG: u4,
                ///  LOCK_CFG
                LOCK_CFG: u4,
                ///  SEC_CFG
                SEC_CFG: u4,
                ///  OR_CFG
                OR_CFG: u4,
                padding: u8,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOI_HWCFGR9: mmio.Mmio(packed struct(u32) {
                ///  EN_IO
                EN_IO: u16,
                padding: u16,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOI_HWCFGR8: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO8
                AF_PRIO8: u4,
                ///  AF_PRIO9
                AF_PRIO9: u4,
                ///  AF_PRIO10
                AF_PRIO10: u4,
                ///  AF_PRIO11
                AF_PRIO11: u4,
                ///  AF_PRIO12
                AF_PRIO12: u4,
                ///  AF_PRIO13
                AF_PRIO13: u4,
                ///  AF_PRIO14
                AF_PRIO14: u4,
                ///  AF_PRIO15
                AF_PRIO15: u4,
            }),
            ///  GPIO hardware configuration register 7
            GPIOI_HWCFGR7: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO0
                AF_PRIO0: u4,
                ///  AF_PRIO1
                AF_PRIO1: u4,
                ///  AF_PRIO2
                AF_PRIO2: u4,
                ///  AF_PRIO3
                AF_PRIO3: u4,
                ///  AF_PRIO4
                AF_PRIO4: u4,
                ///  AF_PRIO5
                AF_PRIO5: u4,
                ///  AF_PRIO6
                AF_PRIO6: u4,
                ///  AF_PRIO7
                AF_PRIO7: u4,
            }),
            ///  GPIO hardware configuration register 6
            GPIOI_HWCFGR6: mmio.Mmio(packed struct(u32) {
                ///  MODER_RES
                MODER_RES: u32,
            }),
            ///  GPIO hardware configuration register 5
            GPIOI_HWCFGR5: mmio.Mmio(packed struct(u32) {
                ///  PUPDR_RES
                PUPDR_RES: u32,
            }),
            ///  GPIO hardware configuration register 4
            GPIOI_HWCFGR4: mmio.Mmio(packed struct(u32) {
                ///  OSPEED_RES
                OSPEED_RES: u32,
            }),
            ///  GPIO hardware configuration register 3
            GPIOI_HWCFGR3: mmio.Mmio(packed struct(u32) {
                ///  ODR_RES
                ODR_RES: u16,
                ///  OTYPER_RES
                OTYPER_RES: u16,
            }),
            ///  GPIO hardware configuration register 2
            GPIOI_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  AFRL_RES
                AFRL_RES: u32,
            }),
            ///  GPIO hardware configuration register 1
            GPIOI_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  AFRH_RES
                AFRH_RES: u32,
            }),
            ///  GPIO hardware configuration register 0
            GPIOI_HWCFGR0: mmio.Mmio(packed struct(u32) {
                ///  OR_RES
                OR_RES: u16,
                padding: u16,
            }),
            ///  GPIO version register
            GPIOI_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  GPIO identification register
            GPIOI_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  IPIDR
                IPIDR: u32,
            }),
            ///  GPIO size identification register
            GPIOI_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SIDR
                SIDR: u32,
            }),
        };

        ///  GPIOJ
        pub const GPIOJ = extern struct {
            ///  GPIO port mode register
            GPIOJ_MODER: mmio.Mmio(packed struct(u32) {
                ///  MODER0
                MODER0: u2,
                ///  MODER1
                MODER1: u2,
                ///  MODER2
                MODER2: u2,
                ///  MODER3
                MODER3: u2,
                ///  MODER4
                MODER4: u2,
                ///  MODER5
                MODER5: u2,
                ///  MODER6
                MODER6: u2,
                ///  MODER7
                MODER7: u2,
                ///  MODER8
                MODER8: u2,
                ///  MODER9
                MODER9: u2,
                ///  MODER10
                MODER10: u2,
                ///  MODER11
                MODER11: u2,
                ///  MODER12
                MODER12: u2,
                ///  MODER13
                MODER13: u2,
                ///  MODER14
                MODER14: u2,
                ///  MODER15
                MODER15: u2,
            }),
            ///  GPIO port output type register
            GPIOJ_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  OT0
                OT0: u1,
                ///  OT1
                OT1: u1,
                ///  OT2
                OT2: u1,
                ///  OT3
                OT3: u1,
                ///  OT4
                OT4: u1,
                ///  OT5
                OT5: u1,
                ///  OT6
                OT6: u1,
                ///  OT7
                OT7: u1,
                ///  OT8
                OT8: u1,
                ///  OT9
                OT9: u1,
                ///  OT10
                OT10: u1,
                ///  OT11
                OT11: u1,
                ///  OT12
                OT12: u1,
                ///  OT13
                OT13: u1,
                ///  OT14
                OT14: u1,
                ///  OT15
                OT15: u1,
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOJ_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  OSPEEDR0
                OSPEEDR0: u2,
                ///  OSPEEDR1
                OSPEEDR1: u2,
                ///  OSPEEDR2
                OSPEEDR2: u2,
                ///  OSPEEDR3
                OSPEEDR3: u2,
                ///  OSPEEDR4
                OSPEEDR4: u2,
                ///  OSPEEDR5
                OSPEEDR5: u2,
                ///  OSPEEDR6
                OSPEEDR6: u2,
                ///  OSPEEDR7
                OSPEEDR7: u2,
                ///  OSPEEDR8
                OSPEEDR8: u2,
                ///  OSPEEDR9
                OSPEEDR9: u2,
                ///  OSPEEDR10
                OSPEEDR10: u2,
                ///  OSPEEDR11
                OSPEEDR11: u2,
                ///  OSPEEDR12
                OSPEEDR12: u2,
                ///  OSPEEDR13
                OSPEEDR13: u2,
                ///  OSPEEDR14
                OSPEEDR14: u2,
                ///  OSPEEDR15
                OSPEEDR15: u2,
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOJ_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  PUPDR0
                PUPDR0: u2,
                ///  PUPDR1
                PUPDR1: u2,
                ///  PUPDR2
                PUPDR2: u2,
                ///  PUPDR3
                PUPDR3: u2,
                ///  PUPDR4
                PUPDR4: u2,
                ///  PUPDR5
                PUPDR5: u2,
                ///  PUPDR6
                PUPDR6: u2,
                ///  PUPDR7
                PUPDR7: u2,
                ///  PUPDR8
                PUPDR8: u2,
                ///  PUPDR9
                PUPDR9: u2,
                ///  PUPDR10
                PUPDR10: u2,
                ///  PUPDR11
                PUPDR11: u2,
                ///  PUPDR12
                PUPDR12: u2,
                ///  PUPDR13
                PUPDR13: u2,
                ///  PUPDR14
                PUPDR14: u2,
                ///  PUPDR15
                PUPDR15: u2,
            }),
            ///  GPIO port input data register
            GPIOJ_IDR: mmio.Mmio(packed struct(u32) {
                ///  IDR0
                IDR0: u1,
                ///  IDR1
                IDR1: u1,
                ///  IDR2
                IDR2: u1,
                ///  IDR3
                IDR3: u1,
                ///  IDR4
                IDR4: u1,
                ///  IDR5
                IDR5: u1,
                ///  IDR6
                IDR6: u1,
                ///  IDR7
                IDR7: u1,
                ///  IDR8
                IDR8: u1,
                ///  IDR9
                IDR9: u1,
                ///  IDR10
                IDR10: u1,
                ///  IDR11
                IDR11: u1,
                ///  IDR12
                IDR12: u1,
                ///  IDR13
                IDR13: u1,
                ///  IDR14
                IDR14: u1,
                ///  IDR15
                IDR15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOJ_ODR: mmio.Mmio(packed struct(u32) {
                ///  ODR0
                ODR0: u1,
                ///  ODR1
                ODR1: u1,
                ///  ODR2
                ODR2: u1,
                ///  ODR3
                ODR3: u1,
                ///  ODR4
                ODR4: u1,
                ///  ODR5
                ODR5: u1,
                ///  ODR6
                ODR6: u1,
                ///  ODR7
                ODR7: u1,
                ///  ODR8
                ODR8: u1,
                ///  ODR9
                ODR9: u1,
                ///  ODR10
                ODR10: u1,
                ///  ODR11
                ODR11: u1,
                ///  ODR12
                ODR12: u1,
                ///  ODR13
                ODR13: u1,
                ///  ODR14
                ODR14: u1,
                ///  ODR15
                ODR15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOJ_BSRR: mmio.Mmio(packed struct(u32) {
                ///  BS0
                BS0: u1,
                ///  BS1
                BS1: u1,
                ///  BS2
                BS2: u1,
                ///  BS3
                BS3: u1,
                ///  BS4
                BS4: u1,
                ///  BS5
                BS5: u1,
                ///  BS6
                BS6: u1,
                ///  BS7
                BS7: u1,
                ///  BS8
                BS8: u1,
                ///  BS9
                BS9: u1,
                ///  BS10
                BS10: u1,
                ///  BS11
                BS11: u1,
                ///  BS12
                BS12: u1,
                ///  BS13
                BS13: u1,
                ///  BS14
                BS14: u1,
                ///  BS15
                BS15: u1,
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
            }),
            ///  This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
            GPIOJ_LCKR: mmio.Mmio(packed struct(u32) {
                ///  LCK0
                LCK0: u1,
                ///  LCK1
                LCK1: u1,
                ///  LCK2
                LCK2: u1,
                ///  LCK3
                LCK3: u1,
                ///  LCK4
                LCK4: u1,
                ///  LCK5
                LCK5: u1,
                ///  LCK6
                LCK6: u1,
                ///  LCK7
                LCK7: u1,
                ///  LCK8
                LCK8: u1,
                ///  LCK9
                LCK9: u1,
                ///  LCK10
                LCK10: u1,
                ///  LCK11
                LCK11: u1,
                ///  LCK12
                LCK12: u1,
                ///  LCK13
                LCK13: u1,
                ///  LCK14
                LCK14: u1,
                ///  LCK15
                LCK15: u1,
                ///  LCKK
                LCKK: u1,
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOJ_AFRL: mmio.Mmio(packed struct(u32) {
                ///  AFR0
                AFR0: u4,
                ///  AFR1
                AFR1: u4,
                ///  AFR2
                AFR2: u4,
                ///  AFR3
                AFR3: u4,
                ///  AFR4
                AFR4: u4,
                ///  AFR5
                AFR5: u4,
                ///  AFR6
                AFR6: u4,
                ///  AFR7
                AFR7: u4,
            }),
            ///  GPIO alternate function high register
            GPIOJ_AFRH: mmio.Mmio(packed struct(u32) {
                ///  AFR8
                AFR8: u4,
                ///  AFR9
                AFR9: u4,
                ///  AFR10
                AFR10: u4,
                ///  AFR11
                AFR11: u4,
                ///  AFR12
                AFR12: u4,
                ///  AFR13
                AFR13: u4,
                ///  AFR14
                AFR14: u4,
                ///  AFR15
                AFR15: u4,
            }),
            ///  GPIO port bit reset register
            GPIOJ_BRR: mmio.Mmio(packed struct(u32) {
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
                padding: u16,
            }),
            reserved968: [924]u8,
            ///  For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
            GPIOJ_HWCFGR10: mmio.Mmio(packed struct(u32) {
                ///  AHB_IOP
                AHB_IOP: u4,
                ///  AF_SIZE
                AF_SIZE: u4,
                ///  SPEED_CFG
                SPEED_CFG: u4,
                ///  LOCK_CFG
                LOCK_CFG: u4,
                ///  SEC_CFG
                SEC_CFG: u4,
                ///  OR_CFG
                OR_CFG: u4,
                padding: u8,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOJ_HWCFGR9: mmio.Mmio(packed struct(u32) {
                ///  EN_IO
                EN_IO: u16,
                padding: u16,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOJ_HWCFGR8: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO8
                AF_PRIO8: u4,
                ///  AF_PRIO9
                AF_PRIO9: u4,
                ///  AF_PRIO10
                AF_PRIO10: u4,
                ///  AF_PRIO11
                AF_PRIO11: u4,
                ///  AF_PRIO12
                AF_PRIO12: u4,
                ///  AF_PRIO13
                AF_PRIO13: u4,
                ///  AF_PRIO14
                AF_PRIO14: u4,
                ///  AF_PRIO15
                AF_PRIO15: u4,
            }),
            ///  GPIO hardware configuration register 7
            GPIOJ_HWCFGR7: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO0
                AF_PRIO0: u4,
                ///  AF_PRIO1
                AF_PRIO1: u4,
                ///  AF_PRIO2
                AF_PRIO2: u4,
                ///  AF_PRIO3
                AF_PRIO3: u4,
                ///  AF_PRIO4
                AF_PRIO4: u4,
                ///  AF_PRIO5
                AF_PRIO5: u4,
                ///  AF_PRIO6
                AF_PRIO6: u4,
                ///  AF_PRIO7
                AF_PRIO7: u4,
            }),
            ///  GPIO hardware configuration register 6
            GPIOJ_HWCFGR6: mmio.Mmio(packed struct(u32) {
                ///  MODER_RES
                MODER_RES: u32,
            }),
            ///  GPIO hardware configuration register 5
            GPIOJ_HWCFGR5: mmio.Mmio(packed struct(u32) {
                ///  PUPDR_RES
                PUPDR_RES: u32,
            }),
            ///  GPIO hardware configuration register 4
            GPIOJ_HWCFGR4: mmio.Mmio(packed struct(u32) {
                ///  OSPEED_RES
                OSPEED_RES: u32,
            }),
            ///  GPIO hardware configuration register 3
            GPIOJ_HWCFGR3: mmio.Mmio(packed struct(u32) {
                ///  ODR_RES
                ODR_RES: u16,
                ///  OTYPER_RES
                OTYPER_RES: u16,
            }),
            ///  GPIO hardware configuration register 2
            GPIOJ_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  AFRL_RES
                AFRL_RES: u32,
            }),
            ///  GPIO hardware configuration register 1
            GPIOJ_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  AFRH_RES
                AFRH_RES: u32,
            }),
            ///  GPIO hardware configuration register 0
            GPIOJ_HWCFGR0: mmio.Mmio(packed struct(u32) {
                ///  OR_RES
                OR_RES: u16,
                padding: u16,
            }),
            ///  GPIO version register
            GPIOJ_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  GPIO identification register
            GPIOJ_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  IPIDR
                IPIDR: u32,
            }),
            ///  GPIO size identification register
            GPIOJ_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SIDR
                SIDR: u32,
            }),
        };

        ///  GPIOK
        pub const GPIOK = extern struct {
            ///  GPIO port mode register
            GPIOK_MODER: mmio.Mmio(packed struct(u32) {
                ///  MODER0
                MODER0: u2,
                ///  MODER1
                MODER1: u2,
                ///  MODER2
                MODER2: u2,
                ///  MODER3
                MODER3: u2,
                ///  MODER4
                MODER4: u2,
                ///  MODER5
                MODER5: u2,
                ///  MODER6
                MODER6: u2,
                ///  MODER7
                MODER7: u2,
                ///  MODER8
                MODER8: u2,
                ///  MODER9
                MODER9: u2,
                ///  MODER10
                MODER10: u2,
                ///  MODER11
                MODER11: u2,
                ///  MODER12
                MODER12: u2,
                ///  MODER13
                MODER13: u2,
                ///  MODER14
                MODER14: u2,
                ///  MODER15
                MODER15: u2,
            }),
            ///  GPIO port output type register
            GPIOK_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  OT0
                OT0: u1,
                ///  OT1
                OT1: u1,
                ///  OT2
                OT2: u1,
                ///  OT3
                OT3: u1,
                ///  OT4
                OT4: u1,
                ///  OT5
                OT5: u1,
                ///  OT6
                OT6: u1,
                ///  OT7
                OT7: u1,
                ///  OT8
                OT8: u1,
                ///  OT9
                OT9: u1,
                ///  OT10
                OT10: u1,
                ///  OT11
                OT11: u1,
                ///  OT12
                OT12: u1,
                ///  OT13
                OT13: u1,
                ///  OT14
                OT14: u1,
                ///  OT15
                OT15: u1,
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOK_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  OSPEEDR0
                OSPEEDR0: u2,
                ///  OSPEEDR1
                OSPEEDR1: u2,
                ///  OSPEEDR2
                OSPEEDR2: u2,
                ///  OSPEEDR3
                OSPEEDR3: u2,
                ///  OSPEEDR4
                OSPEEDR4: u2,
                ///  OSPEEDR5
                OSPEEDR5: u2,
                ///  OSPEEDR6
                OSPEEDR6: u2,
                ///  OSPEEDR7
                OSPEEDR7: u2,
                ///  OSPEEDR8
                OSPEEDR8: u2,
                ///  OSPEEDR9
                OSPEEDR9: u2,
                ///  OSPEEDR10
                OSPEEDR10: u2,
                ///  OSPEEDR11
                OSPEEDR11: u2,
                ///  OSPEEDR12
                OSPEEDR12: u2,
                ///  OSPEEDR13
                OSPEEDR13: u2,
                ///  OSPEEDR14
                OSPEEDR14: u2,
                ///  OSPEEDR15
                OSPEEDR15: u2,
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOK_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  PUPDR0
                PUPDR0: u2,
                ///  PUPDR1
                PUPDR1: u2,
                ///  PUPDR2
                PUPDR2: u2,
                ///  PUPDR3
                PUPDR3: u2,
                ///  PUPDR4
                PUPDR4: u2,
                ///  PUPDR5
                PUPDR5: u2,
                ///  PUPDR6
                PUPDR6: u2,
                ///  PUPDR7
                PUPDR7: u2,
                ///  PUPDR8
                PUPDR8: u2,
                ///  PUPDR9
                PUPDR9: u2,
                ///  PUPDR10
                PUPDR10: u2,
                ///  PUPDR11
                PUPDR11: u2,
                ///  PUPDR12
                PUPDR12: u2,
                ///  PUPDR13
                PUPDR13: u2,
                ///  PUPDR14
                PUPDR14: u2,
                ///  PUPDR15
                PUPDR15: u2,
            }),
            ///  GPIO port input data register
            GPIOK_IDR: mmio.Mmio(packed struct(u32) {
                ///  IDR0
                IDR0: u1,
                ///  IDR1
                IDR1: u1,
                ///  IDR2
                IDR2: u1,
                ///  IDR3
                IDR3: u1,
                ///  IDR4
                IDR4: u1,
                ///  IDR5
                IDR5: u1,
                ///  IDR6
                IDR6: u1,
                ///  IDR7
                IDR7: u1,
                ///  IDR8
                IDR8: u1,
                ///  IDR9
                IDR9: u1,
                ///  IDR10
                IDR10: u1,
                ///  IDR11
                IDR11: u1,
                ///  IDR12
                IDR12: u1,
                ///  IDR13
                IDR13: u1,
                ///  IDR14
                IDR14: u1,
                ///  IDR15
                IDR15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOK_ODR: mmio.Mmio(packed struct(u32) {
                ///  ODR0
                ODR0: u1,
                ///  ODR1
                ODR1: u1,
                ///  ODR2
                ODR2: u1,
                ///  ODR3
                ODR3: u1,
                ///  ODR4
                ODR4: u1,
                ///  ODR5
                ODR5: u1,
                ///  ODR6
                ODR6: u1,
                ///  ODR7
                ODR7: u1,
                ///  ODR8
                ODR8: u1,
                ///  ODR9
                ODR9: u1,
                ///  ODR10
                ODR10: u1,
                ///  ODR11
                ODR11: u1,
                ///  ODR12
                ODR12: u1,
                ///  ODR13
                ODR13: u1,
                ///  ODR14
                ODR14: u1,
                ///  ODR15
                ODR15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOK_BSRR: mmio.Mmio(packed struct(u32) {
                ///  BS0
                BS0: u1,
                ///  BS1
                BS1: u1,
                ///  BS2
                BS2: u1,
                ///  BS3
                BS3: u1,
                ///  BS4
                BS4: u1,
                ///  BS5
                BS5: u1,
                ///  BS6
                BS6: u1,
                ///  BS7
                BS7: u1,
                ///  BS8
                BS8: u1,
                ///  BS9
                BS9: u1,
                ///  BS10
                BS10: u1,
                ///  BS11
                BS11: u1,
                ///  BS12
                BS12: u1,
                ///  BS13
                BS13: u1,
                ///  BS14
                BS14: u1,
                ///  BS15
                BS15: u1,
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
            }),
            ///  This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
            GPIOK_LCKR: mmio.Mmio(packed struct(u32) {
                ///  LCK0
                LCK0: u1,
                ///  LCK1
                LCK1: u1,
                ///  LCK2
                LCK2: u1,
                ///  LCK3
                LCK3: u1,
                ///  LCK4
                LCK4: u1,
                ///  LCK5
                LCK5: u1,
                ///  LCK6
                LCK6: u1,
                ///  LCK7
                LCK7: u1,
                ///  LCK8
                LCK8: u1,
                ///  LCK9
                LCK9: u1,
                ///  LCK10
                LCK10: u1,
                ///  LCK11
                LCK11: u1,
                ///  LCK12
                LCK12: u1,
                ///  LCK13
                LCK13: u1,
                ///  LCK14
                LCK14: u1,
                ///  LCK15
                LCK15: u1,
                ///  LCKK
                LCKK: u1,
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOK_AFRL: mmio.Mmio(packed struct(u32) {
                ///  AFR0
                AFR0: u4,
                ///  AFR1
                AFR1: u4,
                ///  AFR2
                AFR2: u4,
                ///  AFR3
                AFR3: u4,
                ///  AFR4
                AFR4: u4,
                ///  AFR5
                AFR5: u4,
                ///  AFR6
                AFR6: u4,
                ///  AFR7
                AFR7: u4,
            }),
            ///  GPIO alternate function high register
            GPIOK_AFRH: mmio.Mmio(packed struct(u32) {
                ///  AFR8
                AFR8: u4,
                ///  AFR9
                AFR9: u4,
                ///  AFR10
                AFR10: u4,
                ///  AFR11
                AFR11: u4,
                ///  AFR12
                AFR12: u4,
                ///  AFR13
                AFR13: u4,
                ///  AFR14
                AFR14: u4,
                ///  AFR15
                AFR15: u4,
            }),
            ///  GPIO port bit reset register
            GPIOK_BRR: mmio.Mmio(packed struct(u32) {
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
                padding: u16,
            }),
            reserved968: [924]u8,
            ///  For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
            GPIOK_HWCFGR10: mmio.Mmio(packed struct(u32) {
                ///  AHB_IOP
                AHB_IOP: u4,
                ///  AF_SIZE
                AF_SIZE: u4,
                ///  SPEED_CFG
                SPEED_CFG: u4,
                ///  LOCK_CFG
                LOCK_CFG: u4,
                ///  SEC_CFG
                SEC_CFG: u4,
                ///  OR_CFG
                OR_CFG: u4,
                padding: u8,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOK_HWCFGR9: mmio.Mmio(packed struct(u32) {
                ///  EN_IO
                EN_IO: u16,
                padding: u16,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOK_HWCFGR8: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO8
                AF_PRIO8: u4,
                ///  AF_PRIO9
                AF_PRIO9: u4,
                ///  AF_PRIO10
                AF_PRIO10: u4,
                ///  AF_PRIO11
                AF_PRIO11: u4,
                ///  AF_PRIO12
                AF_PRIO12: u4,
                ///  AF_PRIO13
                AF_PRIO13: u4,
                ///  AF_PRIO14
                AF_PRIO14: u4,
                ///  AF_PRIO15
                AF_PRIO15: u4,
            }),
            ///  GPIO hardware configuration register 7
            GPIOK_HWCFGR7: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO0
                AF_PRIO0: u4,
                ///  AF_PRIO1
                AF_PRIO1: u4,
                ///  AF_PRIO2
                AF_PRIO2: u4,
                ///  AF_PRIO3
                AF_PRIO3: u4,
                ///  AF_PRIO4
                AF_PRIO4: u4,
                ///  AF_PRIO5
                AF_PRIO5: u4,
                ///  AF_PRIO6
                AF_PRIO6: u4,
                ///  AF_PRIO7
                AF_PRIO7: u4,
            }),
            ///  GPIO hardware configuration register 6
            GPIOK_HWCFGR6: mmio.Mmio(packed struct(u32) {
                ///  MODER_RES
                MODER_RES: u32,
            }),
            ///  GPIO hardware configuration register 5
            GPIOK_HWCFGR5: mmio.Mmio(packed struct(u32) {
                ///  PUPDR_RES
                PUPDR_RES: u32,
            }),
            ///  GPIO hardware configuration register 4
            GPIOK_HWCFGR4: mmio.Mmio(packed struct(u32) {
                ///  OSPEED_RES
                OSPEED_RES: u32,
            }),
            ///  GPIO hardware configuration register 3
            GPIOK_HWCFGR3: mmio.Mmio(packed struct(u32) {
                ///  ODR_RES
                ODR_RES: u16,
                ///  OTYPER_RES
                OTYPER_RES: u16,
            }),
            ///  GPIO hardware configuration register 2
            GPIOK_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  AFRL_RES
                AFRL_RES: u32,
            }),
            ///  GPIO hardware configuration register 1
            GPIOK_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  AFRH_RES
                AFRH_RES: u32,
            }),
            ///  GPIO hardware configuration register 0
            GPIOK_HWCFGR0: mmio.Mmio(packed struct(u32) {
                ///  OR_RES
                OR_RES: u16,
                padding: u16,
            }),
            ///  GPIO version register
            GPIOK_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  GPIO identification register
            GPIOK_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  IPIDR
                IPIDR: u32,
            }),
            ///  GPIO size identification register
            GPIOK_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SIDR
                SIDR: u32,
            }),
        };

        ///  GPIOZ
        pub const GPIOZ = extern struct {
            ///  GPIO port mode register
            GPIOZ_MODER: mmio.Mmio(packed struct(u32) {
                ///  MODER0
                MODER0: u2,
                ///  MODER1
                MODER1: u2,
                ///  MODER2
                MODER2: u2,
                ///  MODER3
                MODER3: u2,
                ///  MODER4
                MODER4: u2,
                ///  MODER5
                MODER5: u2,
                ///  MODER6
                MODER6: u2,
                ///  MODER7
                MODER7: u2,
                ///  MODER8
                MODER8: u2,
                ///  MODER9
                MODER9: u2,
                ///  MODER10
                MODER10: u2,
                ///  MODER11
                MODER11: u2,
                ///  MODER12
                MODER12: u2,
                ///  MODER13
                MODER13: u2,
                ///  MODER14
                MODER14: u2,
                ///  MODER15
                MODER15: u2,
            }),
            ///  GPIO port output type register
            GPIOZ_OTYPER: mmio.Mmio(packed struct(u32) {
                ///  OT0
                OT0: u1,
                ///  OT1
                OT1: u1,
                ///  OT2
                OT2: u1,
                ///  OT3
                OT3: u1,
                ///  OT4
                OT4: u1,
                ///  OT5
                OT5: u1,
                ///  OT6
                OT6: u1,
                ///  OT7
                OT7: u1,
                ///  OT8
                OT8: u1,
                ///  OT9
                OT9: u1,
                ///  OT10
                OT10: u1,
                ///  OT11
                OT11: u1,
                ///  OT12
                OT12: u1,
                ///  OT13
                OT13: u1,
                ///  OT14
                OT14: u1,
                ///  OT15
                OT15: u1,
                padding: u16,
            }),
            ///  GPIO port output speed register
            GPIOZ_OSPEEDR: mmio.Mmio(packed struct(u32) {
                ///  OSPEEDR0
                OSPEEDR0: u2,
                ///  OSPEEDR1
                OSPEEDR1: u2,
                ///  OSPEEDR2
                OSPEEDR2: u2,
                ///  OSPEEDR3
                OSPEEDR3: u2,
                ///  OSPEEDR4
                OSPEEDR4: u2,
                ///  OSPEEDR5
                OSPEEDR5: u2,
                ///  OSPEEDR6
                OSPEEDR6: u2,
                ///  OSPEEDR7
                OSPEEDR7: u2,
                ///  OSPEEDR8
                OSPEEDR8: u2,
                ///  OSPEEDR9
                OSPEEDR9: u2,
                ///  OSPEEDR10
                OSPEEDR10: u2,
                ///  OSPEEDR11
                OSPEEDR11: u2,
                ///  OSPEEDR12
                OSPEEDR12: u2,
                ///  OSPEEDR13
                OSPEEDR13: u2,
                ///  OSPEEDR14
                OSPEEDR14: u2,
                ///  OSPEEDR15
                OSPEEDR15: u2,
            }),
            ///  GPIO port pull-up/pull-down register
            GPIOZ_PUPDR: mmio.Mmio(packed struct(u32) {
                ///  PUPDR0
                PUPDR0: u2,
                ///  PUPDR1
                PUPDR1: u2,
                ///  PUPDR2
                PUPDR2: u2,
                ///  PUPDR3
                PUPDR3: u2,
                ///  PUPDR4
                PUPDR4: u2,
                ///  PUPDR5
                PUPDR5: u2,
                ///  PUPDR6
                PUPDR6: u2,
                ///  PUPDR7
                PUPDR7: u2,
                ///  PUPDR8
                PUPDR8: u2,
                ///  PUPDR9
                PUPDR9: u2,
                ///  PUPDR10
                PUPDR10: u2,
                ///  PUPDR11
                PUPDR11: u2,
                ///  PUPDR12
                PUPDR12: u2,
                ///  PUPDR13
                PUPDR13: u2,
                ///  PUPDR14
                PUPDR14: u2,
                ///  PUPDR15
                PUPDR15: u2,
            }),
            ///  GPIO port input data register
            GPIOZ_IDR: mmio.Mmio(packed struct(u32) {
                ///  IDR0
                IDR0: u1,
                ///  IDR1
                IDR1: u1,
                ///  IDR2
                IDR2: u1,
                ///  IDR3
                IDR3: u1,
                ///  IDR4
                IDR4: u1,
                ///  IDR5
                IDR5: u1,
                ///  IDR6
                IDR6: u1,
                ///  IDR7
                IDR7: u1,
                ///  IDR8
                IDR8: u1,
                ///  IDR9
                IDR9: u1,
                ///  IDR10
                IDR10: u1,
                ///  IDR11
                IDR11: u1,
                ///  IDR12
                IDR12: u1,
                ///  IDR13
                IDR13: u1,
                ///  IDR14
                IDR14: u1,
                ///  IDR15
                IDR15: u1,
                padding: u16,
            }),
            ///  GPIO port output data register
            GPIOZ_ODR: mmio.Mmio(packed struct(u32) {
                ///  ODR0
                ODR0: u1,
                ///  ODR1
                ODR1: u1,
                ///  ODR2
                ODR2: u1,
                ///  ODR3
                ODR3: u1,
                ///  ODR4
                ODR4: u1,
                ///  ODR5
                ODR5: u1,
                ///  ODR6
                ODR6: u1,
                ///  ODR7
                ODR7: u1,
                ///  ODR8
                ODR8: u1,
                ///  ODR9
                ODR9: u1,
                ///  ODR10
                ODR10: u1,
                ///  ODR11
                ODR11: u1,
                ///  ODR12
                ODR12: u1,
                ///  ODR13
                ODR13: u1,
                ///  ODR14
                ODR14: u1,
                ///  ODR15
                ODR15: u1,
                padding: u16,
            }),
            ///  GPIO port bit set/reset register
            GPIOZ_BSRR: mmio.Mmio(packed struct(u32) {
                ///  BS0
                BS0: u1,
                ///  BS1
                BS1: u1,
                ///  BS2
                BS2: u1,
                ///  BS3
                BS3: u1,
                ///  BS4
                BS4: u1,
                ///  BS5
                BS5: u1,
                ///  BS6
                BS6: u1,
                ///  BS7
                BS7: u1,
                ///  BS8
                BS8: u1,
                ///  BS9
                BS9: u1,
                ///  BS10
                BS10: u1,
                ///  BS11
                BS11: u1,
                ///  BS12
                BS12: u1,
                ///  BS13
                BS13: u1,
                ///  BS14
                BS14: u1,
                ///  BS15
                BS15: u1,
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
            }),
            ///  This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset. A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence. Each lock bit freezes a specific configuration register (control and alternate function registers).
            GPIOZ_LCKR: mmio.Mmio(packed struct(u32) {
                ///  LCK0
                LCK0: u1,
                ///  LCK1
                LCK1: u1,
                ///  LCK2
                LCK2: u1,
                ///  LCK3
                LCK3: u1,
                ///  LCK4
                LCK4: u1,
                ///  LCK5
                LCK5: u1,
                ///  LCK6
                LCK6: u1,
                ///  LCK7
                LCK7: u1,
                ///  LCK8
                LCK8: u1,
                ///  LCK9
                LCK9: u1,
                ///  LCK10
                LCK10: u1,
                ///  LCK11
                LCK11: u1,
                ///  LCK12
                LCK12: u1,
                ///  LCK13
                LCK13: u1,
                ///  LCK14
                LCK14: u1,
                ///  LCK15
                LCK15: u1,
                ///  LCKK
                LCKK: u1,
                padding: u15,
            }),
            ///  GPIO alternate function low register
            GPIOZ_AFRL: mmio.Mmio(packed struct(u32) {
                ///  AFR0
                AFR0: u4,
                ///  AFR1
                AFR1: u4,
                ///  AFR2
                AFR2: u4,
                ///  AFR3
                AFR3: u4,
                ///  AFR4
                AFR4: u4,
                ///  AFR5
                AFR5: u4,
                ///  AFR6
                AFR6: u4,
                ///  AFR7
                AFR7: u4,
            }),
            ///  GPIO alternate function high register
            GPIOZ_AFRH: mmio.Mmio(packed struct(u32) {
                ///  AFR8
                AFR8: u4,
                ///  AFR9
                AFR9: u4,
                ///  AFR10
                AFR10: u4,
                ///  AFR11
                AFR11: u4,
                ///  AFR12
                AFR12: u4,
                ///  AFR13
                AFR13: u4,
                ///  AFR14
                AFR14: u4,
                ///  AFR15
                AFR15: u4,
            }),
            ///  GPIO port bit reset register
            GPIOZ_BRR: mmio.Mmio(packed struct(u32) {
                ///  BR0
                BR0: u1,
                ///  BR1
                BR1: u1,
                ///  BR2
                BR2: u1,
                ///  BR3
                BR3: u1,
                ///  BR4
                BR4: u1,
                ///  BR5
                BR5: u1,
                ///  BR6
                BR6: u1,
                ///  BR7
                BR7: u1,
                ///  BR8
                BR8: u1,
                ///  BR9
                BR9: u1,
                ///  BR10
                BR10: u1,
                ///  BR11
                BR11: u1,
                ///  BR12
                BR12: u1,
                ///  BR13
                BR13: u1,
                ///  BR14
                BR14: u1,
                ///  BR15
                BR15: u1,
                padding: u16,
            }),
            reserved48: [4]u8,
            ///  This register provides write access security and can be written only by a secure access. It is used to configure a selected I/O as secure. A non-secure write access to this register is discarded.
            GPIOZ_SECCFGR: mmio.Mmio(packed struct(u32) {
                ///  SEC0
                SEC0: u1,
                ///  SEC1
                SEC1: u1,
                ///  SEC2
                SEC2: u1,
                ///  SEC3
                SEC3: u1,
                ///  SEC4
                SEC4: u1,
                ///  SEC5
                SEC5: u1,
                ///  SEC6
                SEC6: u1,
                ///  SEC7
                SEC7: u1,
                padding: u24,
            }),
            reserved968: [916]u8,
            ///  For GPIOA, B, C, D, E, F, G, H, I, J and GPIOK: For GPIOZ:
            GPIOZ_HWCFGR10: mmio.Mmio(packed struct(u32) {
                ///  AHB_IOP
                AHB_IOP: u4,
                ///  AF_SIZE
                AF_SIZE: u4,
                ///  SPEED_CFG
                SPEED_CFG: u4,
                ///  LOCK_CFG
                LOCK_CFG: u4,
                ///  SEC_CFG
                SEC_CFG: u4,
                ///  OR_CFG
                OR_CFG: u4,
                padding: u8,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOZ_HWCFGR9: mmio.Mmio(packed struct(u32) {
                ///  EN_IO
                EN_IO: u16,
                padding: u16,
            }),
            ///  For GPIOA, B, C, D, E, F, G, H, I, and GPIOJ: For GPIOK and GPIOZ:
            GPIOZ_HWCFGR8: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO8
                AF_PRIO8: u4,
                ///  AF_PRIO9
                AF_PRIO9: u4,
                ///  AF_PRIO10
                AF_PRIO10: u4,
                ///  AF_PRIO11
                AF_PRIO11: u4,
                ///  AF_PRIO12
                AF_PRIO12: u4,
                ///  AF_PRIO13
                AF_PRIO13: u4,
                ///  AF_PRIO14
                AF_PRIO14: u4,
                ///  AF_PRIO15
                AF_PRIO15: u4,
            }),
            ///  GPIO hardware configuration register 7
            GPIOZ_HWCFGR7: mmio.Mmio(packed struct(u32) {
                ///  AF_PRIO0
                AF_PRIO0: u4,
                ///  AF_PRIO1
                AF_PRIO1: u4,
                ///  AF_PRIO2
                AF_PRIO2: u4,
                ///  AF_PRIO3
                AF_PRIO3: u4,
                ///  AF_PRIO4
                AF_PRIO4: u4,
                ///  AF_PRIO5
                AF_PRIO5: u4,
                ///  AF_PRIO6
                AF_PRIO6: u4,
                ///  AF_PRIO7
                AF_PRIO7: u4,
            }),
            ///  GPIO hardware configuration register 6
            GPIOZ_HWCFGR6: mmio.Mmio(packed struct(u32) {
                ///  MODER_RES
                MODER_RES: u32,
            }),
            ///  GPIO hardware configuration register 5
            GPIOZ_HWCFGR5: mmio.Mmio(packed struct(u32) {
                ///  PUPDR_RES
                PUPDR_RES: u32,
            }),
            ///  GPIO hardware configuration register 4
            GPIOZ_HWCFGR4: mmio.Mmio(packed struct(u32) {
                ///  OSPEED_RES
                OSPEED_RES: u32,
            }),
            ///  GPIO hardware configuration register 3
            GPIOZ_HWCFGR3: mmio.Mmio(packed struct(u32) {
                ///  ODR_RES
                ODR_RES: u16,
                ///  OTYPER_RES
                OTYPER_RES: u16,
            }),
            ///  GPIO hardware configuration register 2
            GPIOZ_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  AFRL_RES
                AFRL_RES: u32,
            }),
            ///  GPIO hardware configuration register 1
            GPIOZ_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  AFRH_RES
                AFRH_RES: u32,
            }),
            ///  GPIO hardware configuration register 0
            GPIOZ_HWCFGR0: mmio.Mmio(packed struct(u32) {
                ///  OR_RES
                OR_RES: u16,
                padding: u16,
            }),
            ///  GPIO version register
            GPIOZ_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  GPIO identification register
            GPIOZ_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  IPIDR
                IPIDR: u32,
            }),
            ///  GPIO size identification register
            GPIOZ_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SIDR
                SIDR: u32,
            }),
        };

        ///  HASH register block
        pub const HASH1 = extern struct {
            ///  HASH control register
            HASH_CR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  INIT
                INIT: u1,
                ///  DMAE
                DMAE: u1,
                ///  DATATYPE
                DATATYPE: u2,
                ///  MODE
                MODE: u1,
                ///  ALGO0
                ALGO0: u1,
                ///  NBW
                NBW: u4,
                ///  DINNE
                DINNE: u1,
                ///  MDMAT
                MDMAT: u1,
                ///  DMAA
                DMAA: u1,
                reserved16: u1,
                ///  LKEY
                LKEY: u1,
                reserved18: u1,
                ///  ALGO1
                ALGO1: u1,
                padding: u13,
            }),
            ///  HASH_DIN is the data input register.
            HASH_DIN: mmio.Mmio(packed struct(u32) {
                ///  DATAIN
                DATAIN: u32,
            }),
            ///  The HASH_STR register has two functions: It is used to define the number of valid bits in the last word of the message entered in the hash processor (that is the number of valid least significant bits in the last data written to the HASH_DIN register) It is used to start the processing of the last block in the message by writing the DCAL bit to 1
            HASH_STR: mmio.Mmio(packed struct(u32) {
                ///  NBLW
                NBLW: u5,
                reserved8: u3,
                ///  DCAL
                DCAL: u1,
                padding: u23,
            }),
            ///  HASH digest register 0
            HASH_HR0: mmio.Mmio(packed struct(u32) {
                ///  H0
                H0: u32,
            }),
            ///  HASH digest register 1
            HASH_HR1: mmio.Mmio(packed struct(u32) {
                ///  H1
                H1: u32,
            }),
            ///  HASH digest register 2
            HASH_HR2: mmio.Mmio(packed struct(u32) {
                ///  H2
                H2: u32,
            }),
            ///  HASH digest register 3
            HASH_HR3: mmio.Mmio(packed struct(u32) {
                ///  H3
                H3: u32,
            }),
            ///  HASH digest register 4
            HASH_HR4: mmio.Mmio(packed struct(u32) {
                ///  H4
                H4: u32,
            }),
            ///  HASH interrupt enable register
            HASH_IMR: mmio.Mmio(packed struct(u32) {
                ///  DINIE
                DINIE: u1,
                ///  DCIE
                DCIE: u1,
                padding: u30,
            }),
            ///  HASH status register
            HASH_SR: mmio.Mmio(packed struct(u32) {
                ///  DINIS
                DINIS: u1,
                ///  DCIS
                DCIS: u1,
                ///  DMAS
                DMAS: u1,
                ///  BUSY
                BUSY: u1,
                padding: u28,
            }),
            reserved248: [208]u8,
            ///  These registers contain the complete internal register states of the hash processor. They are useful when a context swap has to be done because a high-priority task needs to use the hash processor while it is already used by another task. When such an event occurs, the HASH_CSRx registers have to be read and the read values have to be saved in the system memory space. Then the hash processor can be used by the preemptive task, and when the hash computation is complete, the saved context can be read from memory and written back into the HASH_CSRx registers.
            HASH_CSR0: mmio.Mmio(packed struct(u32) {
                ///  CS0
                CS0: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR1: mmio.Mmio(packed struct(u32) {
                ///  CS1
                CS1: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR2: mmio.Mmio(packed struct(u32) {
                ///  CS2
                CS2: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR3: mmio.Mmio(packed struct(u32) {
                ///  CS3
                CS3: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR4: mmio.Mmio(packed struct(u32) {
                ///  CS4
                CS4: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR5: mmio.Mmio(packed struct(u32) {
                ///  CS5
                CS5: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR6: mmio.Mmio(packed struct(u32) {
                ///  CS6
                CS6: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR7: mmio.Mmio(packed struct(u32) {
                ///  CS7
                CS7: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR8: mmio.Mmio(packed struct(u32) {
                ///  CS8
                CS8: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR9: mmio.Mmio(packed struct(u32) {
                ///  CS9
                CS9: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR10: mmio.Mmio(packed struct(u32) {
                ///  CS10
                CS10: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR11: mmio.Mmio(packed struct(u32) {
                ///  CS11
                CS11: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR12: mmio.Mmio(packed struct(u32) {
                ///  CS12
                CS12: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR13: mmio.Mmio(packed struct(u32) {
                ///  CS13
                CS13: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR14: mmio.Mmio(packed struct(u32) {
                ///  CS14
                CS14: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR15: mmio.Mmio(packed struct(u32) {
                ///  CS15
                CS15: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR16: mmio.Mmio(packed struct(u32) {
                ///  CS16
                CS16: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR17: mmio.Mmio(packed struct(u32) {
                ///  CS17
                CS17: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR18: mmio.Mmio(packed struct(u32) {
                ///  CS18
                CS18: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR19: mmio.Mmio(packed struct(u32) {
                ///  CS19
                CS19: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR20: mmio.Mmio(packed struct(u32) {
                ///  CS20
                CS20: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR21: mmio.Mmio(packed struct(u32) {
                ///  CS21
                CS21: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR22: mmio.Mmio(packed struct(u32) {
                ///  CS22
                CS22: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR23: mmio.Mmio(packed struct(u32) {
                ///  CS23
                CS23: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR24: mmio.Mmio(packed struct(u32) {
                ///  CS24
                CS24: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR25: mmio.Mmio(packed struct(u32) {
                ///  CS25
                CS25: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR26: mmio.Mmio(packed struct(u32) {
                ///  CS26
                CS26: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR27: mmio.Mmio(packed struct(u32) {
                ///  CS27
                CS27: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR28: mmio.Mmio(packed struct(u32) {
                ///  CS28
                CS28: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR29: mmio.Mmio(packed struct(u32) {
                ///  CS29
                CS29: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR30: mmio.Mmio(packed struct(u32) {
                ///  CS30
                CS30: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR31: mmio.Mmio(packed struct(u32) {
                ///  CS31
                CS31: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR32: mmio.Mmio(packed struct(u32) {
                ///  CS32
                CS32: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR33: mmio.Mmio(packed struct(u32) {
                ///  CS33
                CS33: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR34: mmio.Mmio(packed struct(u32) {
                ///  CS34
                CS34: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR35: mmio.Mmio(packed struct(u32) {
                ///  CS35
                CS35: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR36: mmio.Mmio(packed struct(u32) {
                ///  CS36
                CS36: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR37: mmio.Mmio(packed struct(u32) {
                ///  CS37
                CS37: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR38: mmio.Mmio(packed struct(u32) {
                ///  CS38
                CS38: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR39: mmio.Mmio(packed struct(u32) {
                ///  CS39
                CS39: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR40: mmio.Mmio(packed struct(u32) {
                ///  CS40
                CS40: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR41: mmio.Mmio(packed struct(u32) {
                ///  CS41
                CS41: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR42: mmio.Mmio(packed struct(u32) {
                ///  CS42
                CS42: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR43: mmio.Mmio(packed struct(u32) {
                ///  CS43
                CS43: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR44: mmio.Mmio(packed struct(u32) {
                ///  CS44
                CS44: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR45: mmio.Mmio(packed struct(u32) {
                ///  CS45
                CS45: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR46: mmio.Mmio(packed struct(u32) {
                ///  CS46
                CS46: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR47: mmio.Mmio(packed struct(u32) {
                ///  CS47
                CS47: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR48: mmio.Mmio(packed struct(u32) {
                ///  CS48
                CS48: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR49: mmio.Mmio(packed struct(u32) {
                ///  CS49
                CS49: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR50: mmio.Mmio(packed struct(u32) {
                ///  CS50
                CS50: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR51: mmio.Mmio(packed struct(u32) {
                ///  CS51
                CS51: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR52: mmio.Mmio(packed struct(u32) {
                ///  CS52
                CS52: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR53: mmio.Mmio(packed struct(u32) {
                ///  CS53
                CS53: u32,
            }),
            reserved804: [340]u8,
            ///  HASH digest register 5
            HASH_HR5: mmio.Mmio(packed struct(u32) {
                ///  H5
                H5: u32,
            }),
            ///  HASH digest register 6
            HASH_HR6: mmio.Mmio(packed struct(u32) {
                ///  H6
                H6: u32,
            }),
            ///  HASH digest register 7
            HASH_HR7: mmio.Mmio(packed struct(u32) {
                ///  H7
                H7: u32,
            }),
            reserved1008: [192]u8,
            ///  HASH Hardware Configuration Register
            HASH_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  CFG1
                CFG1: u4,
                padding: u28,
            }),
            ///  HASH Version Register
            HASH_VERR: mmio.Mmio(packed struct(u32) {
                ///  VER
                VER: u8,
                padding: u24,
            }),
            ///  HASH Identification
            HASH_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  HASH Hardware Magic ID
            HASH_MID: mmio.Mmio(packed struct(u32) {
                ///  MID
                MID: u32,
            }),
        };

        ///  HASH register block
        pub const HASH2 = extern struct {
            ///  HASH control register
            HASH_CR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  INIT
                INIT: u1,
                ///  DMAE
                DMAE: u1,
                ///  DATATYPE
                DATATYPE: u2,
                ///  MODE
                MODE: u1,
                ///  ALGO0
                ALGO0: u1,
                ///  NBW
                NBW: u4,
                ///  DINNE
                DINNE: u1,
                ///  MDMAT
                MDMAT: u1,
                ///  DMAA
                DMAA: u1,
                reserved16: u1,
                ///  LKEY
                LKEY: u1,
                reserved18: u1,
                ///  ALGO1
                ALGO1: u1,
                padding: u13,
            }),
            ///  HASH_DIN is the data input register.
            HASH_DIN: mmio.Mmio(packed struct(u32) {
                ///  DATAIN
                DATAIN: u32,
            }),
            ///  The HASH_STR register has two functions: It is used to define the number of valid bits in the last word of the message entered in the hash processor (that is the number of valid least significant bits in the last data written to the HASH_DIN register) It is used to start the processing of the last block in the message by writing the DCAL bit to 1
            HASH_STR: mmio.Mmio(packed struct(u32) {
                ///  NBLW
                NBLW: u5,
                reserved8: u3,
                ///  DCAL
                DCAL: u1,
                padding: u23,
            }),
            ///  HASH digest register 0
            HASH_HR0: mmio.Mmio(packed struct(u32) {
                ///  H0
                H0: u32,
            }),
            ///  HASH digest register 1
            HASH_HR1: mmio.Mmio(packed struct(u32) {
                ///  H1
                H1: u32,
            }),
            ///  HASH digest register 2
            HASH_HR2: mmio.Mmio(packed struct(u32) {
                ///  H2
                H2: u32,
            }),
            ///  HASH digest register 3
            HASH_HR3: mmio.Mmio(packed struct(u32) {
                ///  H3
                H3: u32,
            }),
            ///  HASH digest register 4
            HASH_HR4: mmio.Mmio(packed struct(u32) {
                ///  H4
                H4: u32,
            }),
            ///  HASH interrupt enable register
            HASH_IMR: mmio.Mmio(packed struct(u32) {
                ///  DINIE
                DINIE: u1,
                ///  DCIE
                DCIE: u1,
                padding: u30,
            }),
            ///  HASH status register
            HASH_SR: mmio.Mmio(packed struct(u32) {
                ///  DINIS
                DINIS: u1,
                ///  DCIS
                DCIS: u1,
                ///  DMAS
                DMAS: u1,
                ///  BUSY
                BUSY: u1,
                padding: u28,
            }),
            reserved248: [208]u8,
            ///  These registers contain the complete internal register states of the hash processor. They are useful when a context swap has to be done because a high-priority task needs to use the hash processor while it is already used by another task. When such an event occurs, the HASH_CSRx registers have to be read and the read values have to be saved in the system memory space. Then the hash processor can be used by the preemptive task, and when the hash computation is complete, the saved context can be read from memory and written back into the HASH_CSRx registers.
            HASH_CSR0: mmio.Mmio(packed struct(u32) {
                ///  CS0
                CS0: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR1: mmio.Mmio(packed struct(u32) {
                ///  CS1
                CS1: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR2: mmio.Mmio(packed struct(u32) {
                ///  CS2
                CS2: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR3: mmio.Mmio(packed struct(u32) {
                ///  CS3
                CS3: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR4: mmio.Mmio(packed struct(u32) {
                ///  CS4
                CS4: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR5: mmio.Mmio(packed struct(u32) {
                ///  CS5
                CS5: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR6: mmio.Mmio(packed struct(u32) {
                ///  CS6
                CS6: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR7: mmio.Mmio(packed struct(u32) {
                ///  CS7
                CS7: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR8: mmio.Mmio(packed struct(u32) {
                ///  CS8
                CS8: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR9: mmio.Mmio(packed struct(u32) {
                ///  CS9
                CS9: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR10: mmio.Mmio(packed struct(u32) {
                ///  CS10
                CS10: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR11: mmio.Mmio(packed struct(u32) {
                ///  CS11
                CS11: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR12: mmio.Mmio(packed struct(u32) {
                ///  CS12
                CS12: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR13: mmio.Mmio(packed struct(u32) {
                ///  CS13
                CS13: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR14: mmio.Mmio(packed struct(u32) {
                ///  CS14
                CS14: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR15: mmio.Mmio(packed struct(u32) {
                ///  CS15
                CS15: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR16: mmio.Mmio(packed struct(u32) {
                ///  CS16
                CS16: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR17: mmio.Mmio(packed struct(u32) {
                ///  CS17
                CS17: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR18: mmio.Mmio(packed struct(u32) {
                ///  CS18
                CS18: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR19: mmio.Mmio(packed struct(u32) {
                ///  CS19
                CS19: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR20: mmio.Mmio(packed struct(u32) {
                ///  CS20
                CS20: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR21: mmio.Mmio(packed struct(u32) {
                ///  CS21
                CS21: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR22: mmio.Mmio(packed struct(u32) {
                ///  CS22
                CS22: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR23: mmio.Mmio(packed struct(u32) {
                ///  CS23
                CS23: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR24: mmio.Mmio(packed struct(u32) {
                ///  CS24
                CS24: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR25: mmio.Mmio(packed struct(u32) {
                ///  CS25
                CS25: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR26: mmio.Mmio(packed struct(u32) {
                ///  CS26
                CS26: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR27: mmio.Mmio(packed struct(u32) {
                ///  CS27
                CS27: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR28: mmio.Mmio(packed struct(u32) {
                ///  CS28
                CS28: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR29: mmio.Mmio(packed struct(u32) {
                ///  CS29
                CS29: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR30: mmio.Mmio(packed struct(u32) {
                ///  CS30
                CS30: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR31: mmio.Mmio(packed struct(u32) {
                ///  CS31
                CS31: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR32: mmio.Mmio(packed struct(u32) {
                ///  CS32
                CS32: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR33: mmio.Mmio(packed struct(u32) {
                ///  CS33
                CS33: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR34: mmio.Mmio(packed struct(u32) {
                ///  CS34
                CS34: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR35: mmio.Mmio(packed struct(u32) {
                ///  CS35
                CS35: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR36: mmio.Mmio(packed struct(u32) {
                ///  CS36
                CS36: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR37: mmio.Mmio(packed struct(u32) {
                ///  CS37
                CS37: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR38: mmio.Mmio(packed struct(u32) {
                ///  CS38
                CS38: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR39: mmio.Mmio(packed struct(u32) {
                ///  CS39
                CS39: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR40: mmio.Mmio(packed struct(u32) {
                ///  CS40
                CS40: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR41: mmio.Mmio(packed struct(u32) {
                ///  CS41
                CS41: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR42: mmio.Mmio(packed struct(u32) {
                ///  CS42
                CS42: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR43: mmio.Mmio(packed struct(u32) {
                ///  CS43
                CS43: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR44: mmio.Mmio(packed struct(u32) {
                ///  CS44
                CS44: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR45: mmio.Mmio(packed struct(u32) {
                ///  CS45
                CS45: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR46: mmio.Mmio(packed struct(u32) {
                ///  CS46
                CS46: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR47: mmio.Mmio(packed struct(u32) {
                ///  CS47
                CS47: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR48: mmio.Mmio(packed struct(u32) {
                ///  CS48
                CS48: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR49: mmio.Mmio(packed struct(u32) {
                ///  CS49
                CS49: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR50: mmio.Mmio(packed struct(u32) {
                ///  CS50
                CS50: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR51: mmio.Mmio(packed struct(u32) {
                ///  CS51
                CS51: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR52: mmio.Mmio(packed struct(u32) {
                ///  CS52
                CS52: u32,
            }),
            ///  HASH context swap registers
            HASH_CSR53: mmio.Mmio(packed struct(u32) {
                ///  CS53
                CS53: u32,
            }),
            reserved804: [340]u8,
            ///  HASH digest register 5
            HASH_HR5: mmio.Mmio(packed struct(u32) {
                ///  H5
                H5: u32,
            }),
            ///  HASH digest register 6
            HASH_HR6: mmio.Mmio(packed struct(u32) {
                ///  H6
                H6: u32,
            }),
            ///  HASH digest register 7
            HASH_HR7: mmio.Mmio(packed struct(u32) {
                ///  H7
                H7: u32,
            }),
            reserved1008: [192]u8,
            ///  HASH Hardware Configuration Register
            HASH_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  CFG1
                CFG1: u4,
                padding: u28,
            }),
            ///  HASH Version Register
            HASH_VERR: mmio.Mmio(packed struct(u32) {
                ///  VER
                VER: u8,
                padding: u24,
            }),
            ///  HASH Identification
            HASH_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  HASH Hardware Magic ID
            HASH_MID: mmio.Mmio(packed struct(u32) {
                ///  MID
                MID: u32,
            }),
        };

        ///  HDMI_CEC
        pub const HDMI_CEC = extern struct {
            ///  CEC control register
            CEC_CR: mmio.Mmio(packed struct(u32) {
                ///  CECEN
                CECEN: u1,
                ///  TXSOM
                TXSOM: u1,
                ///  TXEOM
                TXEOM: u1,
                padding: u29,
            }),
            ///  This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0.
            CEC_CFGR: mmio.Mmio(packed struct(u32) {
                ///  SFT
                SFT: u3,
                ///  RXTOL
                RXTOL: u1,
                ///  BRESTP
                BRESTP: u1,
                ///  BREGEN
                BREGEN: u1,
                ///  LBPEGEN
                LBPEGEN: u1,
                ///  BRDNOGEN
                BRDNOGEN: u1,
                ///  SFTOP
                SFTOP: u1,
                reserved16: u7,
                ///  OAR
                OAR: u15,
                ///  LSTN
                LSTN: u1,
            }),
            ///  CEC Tx data register
            CEC_TXDR: mmio.Mmio(packed struct(u32) {
                ///  TXD
                TXD: u8,
                padding: u24,
            }),
            ///  CEC Rx data register
            CEC_RXDR: mmio.Mmio(packed struct(u32) {
                ///  RXD
                RXD: u8,
                padding: u24,
            }),
            ///  CEC Interrupt and Status Register
            CEC_ISR: mmio.Mmio(packed struct(u32) {
                ///  RXBR
                RXBR: u1,
                ///  RXEND
                RXEND: u1,
                ///  RXOVR
                RXOVR: u1,
                ///  BRE
                BRE: u1,
                ///  SBPE
                SBPE: u1,
                ///  LBPE
                LBPE: u1,
                ///  RXACKE
                RXACKE: u1,
                ///  ARBLST
                ARBLST: u1,
                ///  TXBR
                TXBR: u1,
                ///  TXEND
                TXEND: u1,
                ///  TXUDR
                TXUDR: u1,
                ///  TXERR
                TXERR: u1,
                ///  TXACKE
                TXACKE: u1,
                padding: u19,
            }),
            ///  CEC interrupt enable register
            CEC_IER: mmio.Mmio(packed struct(u32) {
                ///  RXBRIE
                RXBRIE: u1,
                ///  RXENDIE
                RXENDIE: u1,
                ///  RXOVRIE
                RXOVRIE: u1,
                ///  BREIE
                BREIE: u1,
                ///  SBPEIE
                SBPEIE: u1,
                ///  LBPEIE
                LBPEIE: u1,
                ///  RXACKIE
                RXACKIE: u1,
                ///  ARBLSTIE
                ARBLSTIE: u1,
                ///  TXBRIE
                TXBRIE: u1,
                ///  TXENDIE
                TXENDIE: u1,
                ///  TXUDRIE
                TXUDRIE: u1,
                ///  TXERRIE
                TXERRIE: u1,
                ///  TXACKIE
                TXACKIE: u1,
                padding: u19,
            }),
        };

        ///  HDP
        pub const HDP = extern struct {
            ///  HDP Control
            HDP_CTRL: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                padding: u31,
            }),
            ///  HDP multiplexing
            HDP_MUX: mmio.Mmio(packed struct(u32) {
                ///  MUX0
                MUX0: u4,
                ///  MUX1
                MUX1: u4,
                ///  MUX2
                MUX2: u4,
                ///  MUX3
                MUX3: u4,
                ///  MUX4
                MUX4: u4,
                ///  MUX5
                MUX5: u4,
                ///  MUX6
                MUX6: u4,
                ///  MUX7
                MUX7: u4,
            }),
            reserved16: [8]u8,
            ///  HDP value
            HDP_VAL: mmio.Mmio(packed struct(u32) {
                ///  HDPVAL
                HDPVAL: u8,
                padding: u24,
            }),
            ///  HDP GPO set
            HDP_GPOSET: mmio.Mmio(packed struct(u32) {
                ///  HDPGPOSET
                HDPGPOSET: u8,
                padding: u24,
            }),
            ///  HDP GPO clear
            HDP_GPOCLR: mmio.Mmio(packed struct(u32) {
                ///  HDPGPOCLR
                HDPGPOCLR: u8,
                padding: u24,
            }),
            ///  HDP GPO value
            HDP_GPOVAL: mmio.Mmio(packed struct(u32) {
                ///  HDPGPOVAL
                HDPGPOVAL: u8,
                padding: u24,
            }),
            reserved1012: [980]u8,
            ///  HDP version register
            HDP_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  HDP IP identification register
            HDP_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  HDP size identification register
            HDP_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  HSEM
        pub const HSEM = extern struct {
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R0: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R1: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R2: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R3: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R4: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R5: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R6: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R7: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R8: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R9: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R10: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R11: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R12: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R13: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R14: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R15: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R16: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R17: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R18: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R19: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R20: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R21: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R22: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R23: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R24: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R25: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R26: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R27: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R28: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R29: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R30: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  The HSEM_Rx shall be used to perform a 2-step Write lock and Read back. Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_R31: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR0: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR1: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR2: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR3: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR4: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR5: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR6: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR7: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR8: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR9: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR10: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR11: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR12: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR13: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR14: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR15: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR16: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR17: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR18: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR19: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR20: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR21: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR22: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR23: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR24: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR25: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR26: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR27: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR28: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR29: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR30: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  Accesses the same physical bits as HSEM_Rx. The HSEM_RLRx shall be used to perform a 1-step Read lock. Only Read accesses with authorized AHB bus master IDs are granted. Read accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_RLR31: mmio.Mmio(packed struct(u32) {
                ///  PROCID
                PROCID: u8,
                ///  COREID
                COREID: u4,
                reserved31: u19,
                ///  LOCK
                LOCK: u1,
            }),
            ///  HSEM i1terrupt enable register
            HSEM_C1IER: mmio.Mmio(packed struct(u32) {
                ///  ISE
                ISE: u32,
            }),
            ///  HSEM i1terrupt clear register
            HSEM_C1ICR: mmio.Mmio(packed struct(u32) {
                ///  ISC
                ISC: u32,
            }),
            ///  HSEM i1terrupt status register
            HSEM_C1ISR: mmio.Mmio(packed struct(u32) {
                ///  ISF
                ISF: u32,
            }),
            ///  HSEM i1terrupt status register
            HSEM_C1MISR: mmio.Mmio(packed struct(u32) {
                ///  MISF
                MISF: u32,
            }),
            ///  HSEM i2terrupt enable register
            HSEM_C2IER: mmio.Mmio(packed struct(u32) {
                ///  ISE
                ISE: u32,
            }),
            ///  HSEM i2terrupt clear register
            HSEM_C2ICR: mmio.Mmio(packed struct(u32) {
                ///  ISC
                ISC: u32,
            }),
            ///  HSEM i2terrupt status register
            HSEM_C2ISR: mmio.Mmio(packed struct(u32) {
                ///  ISF
                ISF: u32,
            }),
            ///  HSEM i2terrupt status register
            HSEM_C2MISR: mmio.Mmio(packed struct(u32) {
                ///  MISF
                MISF: u32,
            }),
            reserved320: [32]u8,
            ///  Only Write accesses with authorized AHB bus master IDs are granted. Write accesses with unauthorized AHB bus master IDs are discarded.
            HSEM_CR: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                ///  COREID
                COREID: u4,
                reserved16: u4,
                ///  KEY
                KEY: u16,
            }),
            ///  HSEM interrupt clear register
            HSEM_KEYR: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                ///  KEY
                KEY: u16,
            }),
            reserved1004: [676]u8,
            ///  HSEM hardware configuration register 2
            HSEM_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  MASTERID1
                MASTERID1: u4,
                ///  MASTERID2
                MASTERID2: u4,
                ///  MASTERID3
                MASTERID3: u4,
                ///  MASTERID4
                MASTERID4: u4,
                padding: u16,
            }),
            ///  HSEM hardware configuration register 1
            HSEM_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  NBSEM
                NBSEM: u8,
                ///  NBINT
                NBINT: u4,
                padding: u20,
            }),
            ///  HSEM IP version register
            HSEM_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  HSEM IP identification register
            HSEM_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  IPID
                IPID: u32,
            }),
            ///  HSEM size identification register
            HSEM_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  I2C1
        pub const I2C1 = extern struct {
            ///  Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2xi2c_pclk+6xi2c_ker_ck.
            I2C_CR1: mmio.Mmio(packed struct(u32) {
                ///  PE
                PE: u1,
                ///  TXIE
                TXIE: u1,
                ///  RXIE
                RXIE: u1,
                ///  ADDRIE
                ADDRIE: u1,
                ///  NACKIE
                NACKIE: u1,
                ///  STOPIE
                STOPIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  ERRIE
                ERRIE: u1,
                ///  DNF
                DNF: u4,
                ///  ANFOFF
                ANFOFF: u1,
                reserved14: u1,
                ///  TXDMAEN
                TXDMAEN: u1,
                ///  RXDMAEN
                RXDMAEN: u1,
                ///  SBC
                SBC: u1,
                ///  NOSTRETCH
                NOSTRETCH: u1,
                ///  WUPEN
                WUPEN: u1,
                ///  GCEN
                GCEN: u1,
                ///  SMBHEN
                SMBHEN: u1,
                ///  SMBDEN
                SMBDEN: u1,
                ///  ALERTEN
                ALERTEN: u1,
                ///  PECEN
                PECEN: u1,
                padding: u8,
            }),
            ///  Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
            I2C_CR2: mmio.Mmio(packed struct(u32) {
                ///  SADD
                SADD: u10,
                ///  RD_WRN
                RD_WRN: u1,
                ///  ADD10
                ADD10: u1,
                ///  HEAD10R
                HEAD10R: u1,
                ///  START
                START: u1,
                ///  STOP
                STOP: u1,
                ///  NACK
                NACK: u1,
                ///  NBYTES
                NBYTES: u8,
                ///  RELOAD
                RELOAD: u1,
                ///  AUTOEND
                AUTOEND: u1,
                ///  PECBYTE
                PECBYTE: u1,
                padding: u5,
            }),
            ///  Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
            I2C_OAR1: mmio.Mmio(packed struct(u32) {
                ///  OA1
                OA1: u10,
                ///  OA1MODE
                OA1MODE: u1,
                reserved15: u4,
                ///  OA1EN
                OA1EN: u1,
                padding: u16,
            }),
            ///  Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
            I2C_OAR2: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  OA2
                OA2: u7,
                ///  OA2MSK
                OA2MSK: u3,
                reserved15: u4,
                ///  OA2EN
                OA2EN: u1,
                padding: u16,
            }),
            ///  Access: No wait states
            I2C_TIMINGR: mmio.Mmio(packed struct(u32) {
                ///  SCLL
                SCLL: u8,
                ///  SCLH
                SCLH: u8,
                ///  SDADEL
                SDADEL: u4,
                ///  SCLDEL
                SCLDEL: u4,
                reserved28: u4,
                ///  PRESC
                PRESC: u4,
            }),
            ///  Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x i2c_pclk + 6 x i2c_ker_ck.
            I2C_TIMEOUTR: mmio.Mmio(packed struct(u32) {
                ///  TIMEOUTA
                TIMEOUTA: u12,
                ///  TIDLE
                TIDLE: u1,
                reserved15: u2,
                ///  TIMOUTEN
                TIMOUTEN: u1,
                ///  TIMEOUTB
                TIMEOUTB: u12,
                reserved31: u3,
                ///  TEXTEN
                TEXTEN: u1,
            }),
            ///  Access: No wait states
            I2C_ISR: mmio.Mmio(packed struct(u32) {
                ///  TXE
                TXE: u1,
                ///  TXIS
                TXIS: u1,
                ///  RXNE
                RXNE: u1,
                ///  ADDR
                ADDR: u1,
                ///  NACKF
                NACKF: u1,
                ///  STOPF
                STOPF: u1,
                ///  TC
                TC: u1,
                ///  TCR
                TCR: u1,
                ///  BERR
                BERR: u1,
                ///  ARLO
                ARLO: u1,
                ///  OVR
                OVR: u1,
                ///  PECERR
                PECERR: u1,
                ///  TIMEOUT
                TIMEOUT: u1,
                ///  ALERT
                ALERT: u1,
                reserved15: u1,
                ///  BUSY
                BUSY: u1,
                ///  DIR
                DIR: u1,
                ///  ADDCODE
                ADDCODE: u7,
                padding: u8,
            }),
            ///  Access: No wait states
            I2C_ICR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  ADDRCF
                ADDRCF: u1,
                ///  NACKCF
                NACKCF: u1,
                ///  STOPCF
                STOPCF: u1,
                reserved8: u2,
                ///  BERRCF
                BERRCF: u1,
                ///  ARLOCF
                ARLOCF: u1,
                ///  OVRCF
                OVRCF: u1,
                ///  PECCF
                PECCF: u1,
                ///  TIMOUTCF
                TIMOUTCF: u1,
                ///  ALERTCF
                ALERTCF: u1,
                padding: u18,
            }),
            ///  Access: No wait states
            I2C_PECR: mmio.Mmio(packed struct(u32) {
                ///  PEC
                PEC: u8,
                padding: u24,
            }),
            ///  Access: No wait states
            I2C_RXDR: mmio.Mmio(packed struct(u32) {
                ///  RXDATA
                RXDATA: u8,
                padding: u24,
            }),
            ///  Access: No wait states
            I2C_TXDR: mmio.Mmio(packed struct(u32) {
                ///  TXDATA
                TXDATA: u8,
                padding: u24,
            }),
            reserved1008: [964]u8,
            ///  I2C hardware configuration register
            I2C_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  SMBUS
                SMBUS: u4,
                ///  ASYN
                ASYN: u4,
                ///  WKP
                WKP: u4,
                padding: u20,
            }),
            ///  I2C version register
            I2C_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  I2C identification register
            I2C_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  I2C size identification register
            I2C_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  TIM1
        pub const TIM1 = extern struct {
            ///  TIM1 control register 1
            TIM1_CR1: mmio.Mmio(packed struct(u16) {
                ///  CEN
                CEN: u1,
                ///  UDIS
                UDIS: u1,
                ///  URS
                URS: u1,
                ///  OPM
                OPM: u1,
                ///  DIR
                DIR: u1,
                ///  CMS
                CMS: u2,
                ///  ARPE
                ARPE: u1,
                ///  CKD
                CKD: u2,
                reserved11: u1,
                ///  UIFREMAP
                UIFREMAP: u1,
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM1 control register 2
            TIM1_CR2: mmio.Mmio(packed struct(u32) {
                ///  CCPC
                CCPC: u1,
                reserved2: u1,
                ///  CCUS
                CCUS: u1,
                ///  CCDS
                CCDS: u1,
                ///  MMS
                MMS: u3,
                ///  TI1S
                TI1S: u1,
                ///  OIS1
                OIS1: u1,
                ///  OIS1N
                OIS1N: u1,
                ///  OIS2
                OIS2: u1,
                ///  OIS2N
                OIS2N: u1,
                ///  OIS3
                OIS3: u1,
                ///  OIS3N
                OIS3N: u1,
                ///  OIS4
                OIS4: u1,
                reserved16: u1,
                ///  OIS5
                OIS5: u1,
                reserved18: u1,
                ///  OIS6
                OIS6: u1,
                reserved20: u1,
                ///  MMS2
                MMS2: u4,
                padding: u8,
            }),
            ///  TIM1 slave mode control register
            TIM1_SMCR: mmio.Mmio(packed struct(u32) {
                ///  SMS
                SMS: u3,
                reserved4: u1,
                ///  TS
                TS: u3,
                ///  MSM
                MSM: u1,
                ///  ETF
                ETF: u4,
                ///  ETPS
                ETPS: u2,
                ///  ECE
                ECE: u1,
                ///  ETP
                ETP: u1,
                ///  SMS3
                SMS3: u1,
                reserved20: u3,
                ///  TS3
                TS3: u1,
                ///  TS4
                TS4: u1,
                padding: u10,
            }),
            ///  TIM1 DMA/interrupt enable register
            TIM1_DIER: mmio.Mmio(packed struct(u16) {
                ///  UIE
                UIE: u1,
                ///  CC1IE
                CC1IE: u1,
                ///  CC2IE
                CC2IE: u1,
                ///  CC3IE
                CC3IE: u1,
                ///  CC4IE
                CC4IE: u1,
                ///  COMIE
                COMIE: u1,
                ///  TIE
                TIE: u1,
                ///  BIE
                BIE: u1,
                ///  UDE
                UDE: u1,
                ///  CC1DE
                CC1DE: u1,
                ///  CC2DE
                CC2DE: u1,
                ///  CC3DE
                CC3DE: u1,
                ///  CC4DE
                CC4DE: u1,
                ///  COMDE
                COMDE: u1,
                ///  TDE
                TDE: u1,
                padding: u1,
            }),
            reserved16: [2]u8,
            ///  TIM1 status register
            TIM1_SR: mmio.Mmio(packed struct(u32) {
                ///  UIF
                UIF: u1,
                ///  CC1IF
                CC1IF: u1,
                ///  CC2IF
                CC2IF: u1,
                ///  CC3IF
                CC3IF: u1,
                ///  CC4IF
                CC4IF: u1,
                ///  COMIF
                COMIF: u1,
                ///  TIF
                TIF: u1,
                ///  BIF
                BIF: u1,
                ///  B2IF
                B2IF: u1,
                ///  CC1OF
                CC1OF: u1,
                ///  CC2OF
                CC2OF: u1,
                ///  CC3OF
                CC3OF: u1,
                ///  CC4OF
                CC4OF: u1,
                ///  SBIF
                SBIF: u1,
                reserved16: u2,
                ///  CC5IF
                CC5IF: u1,
                ///  CC6IF
                CC6IF: u1,
                padding: u14,
            }),
            ///  TIM1 event generation register
            TIM1_EGR: mmio.Mmio(packed struct(u16) {
                ///  UG
                UG: u1,
                ///  CC1G
                CC1G: u1,
                ///  CC2G
                CC2G: u1,
                ///  CC3G
                CC3G: u1,
                ///  CC4G
                CC4G: u1,
                ///  COMG
                COMG: u1,
                ///  TG
                TG: u1,
                ///  BG
                BG: u1,
                ///  B2G
                B2G: u1,
                padding: u7,
            }),
            reserved24: [2]u8,
            ///  The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
            TIM1_CCMR1ALTERNATE1: mmio.Mmio(packed struct(u32) {
                ///  CC1S
                CC1S: u2,
                ///  IC1PSC
                IC1PSC: u2,
                ///  IC1F
                IC1F: u4,
                ///  CC2S
                CC2S: u2,
                ///  IC2PSC
                IC2PSC: u2,
                ///  IC2F
                IC2F: u4,
                padding: u16,
            }),
            ///  The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
            TIM1_CCMR2ALTERNATE17: mmio.Mmio(packed struct(u32) {
                ///  CC3S
                CC3S: u2,
                ///  IC3PSC
                IC3PSC: u2,
                ///  IC3F
                IC3F: u4,
                ///  CC4S
                CC4S: u2,
                ///  IC4PSC
                IC4PSC: u2,
                ///  IC4F
                IC4F: u4,
                padding: u16,
            }),
            ///  TIM1 capture/compare enable register
            TIM1_CCER: mmio.Mmio(packed struct(u32) {
                ///  CC1E
                CC1E: u1,
                ///  CC1P
                CC1P: u1,
                ///  CC1NE
                CC1NE: u1,
                ///  CC1NP
                CC1NP: u1,
                ///  CC2E
                CC2E: u1,
                ///  CC2P
                CC2P: u1,
                ///  CC2NE
                CC2NE: u1,
                ///  CC2NP
                CC2NP: u1,
                ///  CC3E
                CC3E: u1,
                ///  CC3P
                CC3P: u1,
                ///  CC3NE
                CC3NE: u1,
                ///  CC3NP
                CC3NP: u1,
                ///  CC4E
                CC4E: u1,
                ///  CC4P
                CC4P: u1,
                reserved15: u1,
                ///  CC4NP
                CC4NP: u1,
                ///  CC5E
                CC5E: u1,
                ///  CC5P
                CC5P: u1,
                reserved20: u2,
                ///  CC6E
                CC6E: u1,
                ///  CC6P
                CC6P: u1,
                padding: u10,
            }),
            ///  TIM1 counter
            TIM1_CNT: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u16,
                reserved31: u15,
                ///  UIFCPY
                UIFCPY: u1,
            }),
            ///  TIM1 prescaler
            TIM1_PSC: mmio.Mmio(packed struct(u16) {
                ///  PSC
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM1 auto-reload register
            TIM1_ARR: mmio.Mmio(packed struct(u16) {
                ///  ARR
                ARR: u16,
            }),
            reserved48: [2]u8,
            ///  TIM1 repetition counter register
            TIM1_RCR: mmio.Mmio(packed struct(u16) {
                ///  REP
                REP: u16,
            }),
            reserved52: [2]u8,
            ///  TIM1 capture/compare register 1
            TIM1_CCR1: mmio.Mmio(packed struct(u16) {
                ///  CCR1
                CCR1: u16,
            }),
            reserved56: [2]u8,
            ///  TIM1 capture/compare register 2
            TIM1_CCR2: mmio.Mmio(packed struct(u16) {
                ///  CCR2
                CCR2: u16,
            }),
            reserved60: [2]u8,
            ///  TIM1 capture/compare register 3
            TIM1_CCR3: mmio.Mmio(packed struct(u16) {
                ///  CCR3
                CCR3: u16,
            }),
            reserved64: [2]u8,
            ///  TIM1 capture/compare register 4
            TIM1_CCR4: mmio.Mmio(packed struct(u16) {
                ///  CCR4
                CCR4: u16,
            }),
            reserved68: [2]u8,
            ///  As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
            TIM1_BDTR: mmio.Mmio(packed struct(u32) {
                ///  DTG
                DTG: u8,
                ///  LOCK
                LOCK: u2,
                ///  OSSI
                OSSI: u1,
                ///  OSSR
                OSSR: u1,
                ///  BKE
                BKE: u1,
                ///  BKP
                BKP: u1,
                ///  AOE
                AOE: u1,
                ///  MOE
                MOE: u1,
                ///  BKF
                BKF: u4,
                ///  BK2F
                BK2F: u4,
                ///  BK2E
                BK2E: u1,
                ///  BK2P
                BK2P: u1,
                ///  BKDSRM
                BKDSRM: u1,
                ///  BK2DSRM
                BK2DSRM: u1,
                ///  BKBID
                BKBID: u1,
                ///  BK2BID
                BK2BID: u1,
                padding: u2,
            }),
            ///  TIM1 DMA control register
            TIM1_DCR: mmio.Mmio(packed struct(u16) {
                ///  DBA
                DBA: u5,
                reserved8: u3,
                ///  DBL
                DBL: u5,
                padding: u3,
            }),
            reserved76: [2]u8,
            ///  TIM1 DMA address for full transfer
            TIM1_DMAR: mmio.Mmio(packed struct(u32) {
                ///  DMAB
                DMAB: u32,
            }),
            reserved84: [4]u8,
            ///  The channels 5 and 6 can only be configured in output. Output compare mode:
            TIM1_CCMR3: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  OC5FE
                OC5FE: u1,
                ///  OC5PE
                OC5PE: u1,
                ///  OC5M
                OC5M: u3,
                ///  OC5CE
                OC5CE: u1,
                reserved10: u2,
                ///  OC6FE
                OC6FE: u1,
                ///  OC6PE
                OC6PE: u1,
                ///  OC6M
                OC6M: u3,
                ///  OC6CE
                OC6CE: u1,
                ///  OC5M3
                OC5M3: u1,
                reserved24: u7,
                ///  OC6M3
                OC6M3: u1,
                padding: u7,
            }),
            ///  TIM1 capture/compare register 5
            TIM1_CCR5: mmio.Mmio(packed struct(u32) {
                ///  CCR5
                CCR5: u16,
                reserved29: u13,
                ///  GC5C1
                GC5C1: u1,
                ///  GC5C2
                GC5C2: u1,
                ///  GC5C3
                GC5C3: u1,
            }),
            ///  TIM1 capture/compare register 6
            TIM1_CCR6: mmio.Mmio(packed struct(u16) {
                ///  CCR6
                CCR6: u16,
            }),
            reserved96: [2]u8,
            ///  TIM1 alternate function option register 1
            TIM1_AF1: mmio.Mmio(packed struct(u32) {
                ///  BKINE
                BKINE: u1,
                reserved8: u7,
                ///  BKDF1BK0E
                BKDF1BK0E: u1,
                ///  BKINP
                BKINP: u1,
                reserved14: u4,
                ///  ETRSEL
                ETRSEL: u4,
                padding: u14,
            }),
            ///  TIM1 Alternate function register 2
            TIM1_AF2: mmio.Mmio(packed struct(u32) {
                ///  BK2INE
                BK2INE: u1,
                reserved8: u7,
                ///  BK2DF1BK1E
                BK2DF1BK1E: u1,
                ///  BK2INP
                BK2INP: u1,
                padding: u22,
            }),
            ///  TIM1 timer input selection register
            TIM1_TISEL: mmio.Mmio(packed struct(u32) {
                ///  TI1SEL
                TI1SEL: u4,
                reserved8: u4,
                ///  TI2SEL
                TI2SEL: u4,
                reserved16: u4,
                ///  TI3SEL
                TI3SEL: u4,
                reserved24: u4,
                ///  TI4SEL
                TI4SEL: u4,
                padding: u4,
            }),
        };

        ///  TAMP
        pub const TAMP = extern struct {
            ///  This register can be protected against non-secure access. Refer to Section51.3.3: TAMP secure protection modes.
            TAMP_CR1: mmio.Mmio(packed struct(u32) {
                ///  TAMP1E
                TAMP1E: u1,
                ///  TAMP2E
                TAMP2E: u1,
                ///  TAMP3E
                TAMP3E: u1,
                reserved16: u13,
                ///  ITAMP1E
                ITAMP1E: u1,
                ///  ITAMP2E
                ITAMP2E: u1,
                ///  ITAMP3E
                ITAMP3E: u1,
                ///  ITAMP4E
                ITAMP4E: u1,
                ///  ITAMP5E
                ITAMP5E: u1,
                reserved23: u2,
                ///  ITAMP8E
                ITAMP8E: u1,
                padding: u8,
            }),
            ///  This register can be protected against non-secure access. Refer to Section51.3.3: TAMP secure protection modes.
            TAMP_CR2: mmio.Mmio(packed struct(u32) {
                ///  TAMP1NOER
                TAMP1NOER: u1,
                ///  TAMP2NOER
                TAMP2NOER: u1,
                ///  TAMP3NOER
                TAMP3NOER: u1,
                reserved16: u13,
                ///  TAMP1MSK
                TAMP1MSK: u1,
                ///  TAMP2MSK
                TAMP2MSK: u1,
                ///  TAMP3MSK
                TAMP3MSK: u1,
                reserved24: u5,
                ///  TAMP1TRG
                TAMP1TRG: u1,
                ///  TAMP2TRG
                TAMP2TRG: u1,
                ///  TAMP3TRG
                TAMP3TRG: u1,
                padding: u5,
            }),
            reserved12: [4]u8,
            ///  This register can be protected against non-secure access. Refer to Section51.3.3: TAMP secure protection modes.
            TAMP_FLTCR: mmio.Mmio(packed struct(u32) {
                ///  TAMPFREQ
                TAMPFREQ: u3,
                ///  TAMPFLT
                TAMPFLT: u2,
                ///  TAMPPRCH
                TAMPPRCH: u2,
                ///  TAMPPUDIS
                TAMPPUDIS: u1,
                padding: u24,
            }),
            ///  This register can be protected against non-secure access. Refer to Section51.3.3: TAMP secure protection modes.
            TAMP_ATCR1: mmio.Mmio(packed struct(u32) {
                ///  TAMP1AM
                TAMP1AM: u1,
                ///  TAMP2AM
                TAMP2AM: u1,
                ///  TAMP3AM
                TAMP3AM: u1,
                reserved8: u5,
                ///  ATOSEL1
                ATOSEL1: u2,
                ///  ATOSEL2
                ATOSEL2: u2,
                ///  ATOSEL3
                ATOSEL3: u2,
                reserved16: u2,
                ///  ATCKSEL
                ATCKSEL: u3,
                reserved24: u5,
                ///  ATPER
                ATPER: u3,
                reserved30: u3,
                ///  ATOSHARE
                ATOSHARE: u1,
                ///  FLTEN
                FLTEN: u1,
            }),
            ///  This register can be protected against non-secure access. Refer to Section51.3.3: TAMP secure protection modes.
            TAMP_ATSEEDR: mmio.Mmio(packed struct(u32) {
                ///  SEED
                SEED: u32,
            }),
            ///  This register can be protected against non-secure access. Refer to Section51.3.3: TAMP secure protection modes.
            TAMP_ATOR: mmio.Mmio(packed struct(u32) {
                ///  PRNG
                PRNG: u8,
                reserved14: u6,
                ///  SEEDF
                SEEDF: u1,
                ///  INITS
                INITS: u1,
                padding: u16,
            }),
            reserved32: [4]u8,
            ///  This register can be written only when the APB access is secure.
            TAMP_SMCR: mmio.Mmio(packed struct(u32) {
                ///  BKPRWDPROT
                BKPRWDPROT: u8,
                reserved16: u8,
                ///  BKPWDPROT
                BKPWDPROT: u8,
                reserved31: u7,
                ///  TAMPDPROT
                TAMPDPROT: u1,
            }),
            reserved44: [8]u8,
            ///  This register can be protected against non-secure access. Refer to Section51.3.3: TAMP secure protection modes.
            TAMP_IER: mmio.Mmio(packed struct(u32) {
                ///  TAMP1IE
                TAMP1IE: u1,
                ///  TAMP2IE
                TAMP2IE: u1,
                ///  TAMP3IE
                TAMP3IE: u1,
                reserved16: u13,
                ///  ITAMP1IE
                ITAMP1IE: u1,
                ///  ITAMP2IE
                ITAMP2IE: u1,
                ///  ITAMP3IE
                ITAMP3IE: u1,
                ///  ITAMP4IE
                ITAMP4IE: u1,
                ///  ITAMP5IE
                ITAMP5IE: u1,
                reserved23: u2,
                ///  ITAMP8IE
                ITAMP8IE: u1,
                padding: u8,
            }),
            ///  This register can be protected against non-secure access. Refer to Section51.3.3: TAMP secure protection modes.
            TAMP_SR: mmio.Mmio(packed struct(u32) {
                ///  TAMP1F
                TAMP1F: u1,
                ///  TAMP2F
                TAMP2F: u1,
                ///  TAMP3F
                TAMP3F: u1,
                reserved16: u13,
                ///  ITAMP1F
                ITAMP1F: u1,
                ///  ITAMP2F
                ITAMP2F: u1,
                ///  ITAMP3F
                ITAMP3F: u1,
                ///  ITAMP4F
                ITAMP4F: u1,
                ///  ITAMP5F
                ITAMP5F: u1,
                reserved23: u2,
                ///  ITAMP8F
                ITAMP8F: u1,
                padding: u8,
            }),
            ///  TAMP non-secure masked interrupt status register
            TAMP_MISR: mmio.Mmio(packed struct(u32) {
                ///  TAMP1MF
                TAMP1MF: u1,
                ///  TAMP2MF
                TAMP2MF: u1,
                ///  TAMP3MF
                TAMP3MF: u1,
                reserved16: u13,
                ///  ITAMP1MF
                ITAMP1MF: u1,
                ///  ITAMP2MF
                ITAMP2MF: u1,
                ///  ITAMP3MF
                ITAMP3MF: u1,
                ///  ITAMP4MF
                ITAMP4MF: u1,
                ///  ITAMP5MF
                ITAMP5MF: u1,
                reserved23: u2,
                ///  ITAMP8MF
                ITAMP8MF: u1,
                padding: u8,
            }),
            ///  TAMP secure masked interrupt status register
            TAMP_SMISR: mmio.Mmio(packed struct(u32) {
                ///  TAMP1MF
                TAMP1MF: u1,
                ///  TAMP2MF
                TAMP2MF: u1,
                ///  TAMP3MF
                TAMP3MF: u1,
                reserved16: u13,
                ///  ITAMP1MF
                ITAMP1MF: u1,
                ///  ITAMP2MF
                ITAMP2MF: u1,
                ///  ITAMP3MF
                ITAMP3MF: u1,
                ///  ITAMP4MF
                ITAMP4MF: u1,
                ///  ITAMP5MF
                ITAMP5MF: u1,
                reserved23: u2,
                ///  ITAMP8MF
                ITAMP8MF: u1,
                padding: u8,
            }),
            ///  TAMP status clear register
            TAMP_SCR: mmio.Mmio(packed struct(u32) {
                ///  CTAMP1F
                CTAMP1F: u1,
                ///  CTAMP2F
                CTAMP2F: u1,
                ///  CTAMP3F
                CTAMP3F: u1,
                reserved16: u13,
                ///  CITAMP1F
                CITAMP1F: u1,
                ///  CITAMP2F
                CITAMP2F: u1,
                ///  CITAMP3F
                CITAMP3F: u1,
                ///  CITAMP4F
                CITAMP4F: u1,
                ///  CITAMP5F
                CITAMP5F: u1,
                reserved23: u2,
                ///  CITAMP8F
                CITAMP8F: u1,
                padding: u8,
            }),
            ///  TAMP monotonic counter register
            TAMP_COUNTR: mmio.Mmio(packed struct(u32) {
                ///  COUNT
                COUNT: u32,
            }),
            reserved80: [12]u8,
            ///  TAMP configuration register
            TAMP_CFGR: mmio.Mmio(packed struct(u32) {
                ///  OUT3_RMP
                OUT3_RMP: u1,
                padding: u31,
            }),
            reserved256: [172]u8,
            ///  TAMP backup 0 register
            TAMP_BKP0R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 1 register
            TAMP_BKP1R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 2 register
            TAMP_BKP2R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 3 register
            TAMP_BKP3R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 4 register
            TAMP_BKP4R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 5 register
            TAMP_BKP5R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 6 register
            TAMP_BKP6R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 7 register
            TAMP_BKP7R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 8 register
            TAMP_BKP8R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 9 register
            TAMP_BKP9R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 10 register
            TAMP_BKP10R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 11 register
            TAMP_BKP11R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 12 register
            TAMP_BKP12R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 13 register
            TAMP_BKP13R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 14 register
            TAMP_BKP14R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 15 register
            TAMP_BKP15R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 16 register
            TAMP_BKP16R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 17 register
            TAMP_BKP17R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 18 register
            TAMP_BKP18R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 19 register
            TAMP_BKP19R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 20 register
            TAMP_BKP20R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 21 register
            TAMP_BKP21R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 22 register
            TAMP_BKP22R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 23 register
            TAMP_BKP23R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 24 register
            TAMP_BKP24R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 25 register
            TAMP_BKP25R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 26 register
            TAMP_BKP26R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 27 register
            TAMP_BKP27R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 28 register
            TAMP_BKP28R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 29 register
            TAMP_BKP29R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 30 register
            TAMP_BKP30R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            ///  TAMP backup 31 register
            TAMP_BKP31R: mmio.Mmio(packed struct(u32) {
                ///  BKP
                BKP: u32,
            }),
            reserved1004: [620]u8,
            ///  TAMP hardware configuration register 2
            TAMP_HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  OPTIONREG_OUT
                OPTIONREG_OUT: u8,
                ///  TRUST_ZONE
                TRUST_ZONE: u4,
                padding: u20,
            }),
            ///  TAMP hardware configuration register 1
            TAMP_HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  BACKUP_REGS
                BACKUP_REGS: u8,
                ///  TAMPER
                TAMPER: u4,
                ///  ACTIVE_TAMPER
                ACTIVE_TAMPER: u4,
                ///  INT_TAMPER
                INT_TAMPER: u16,
            }),
            ///  TAMP version register
            TAMP_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  TAMP identification register
            TAMP_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  TAMP size identification register
            TAMP_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  STGENC
        pub const STGENC = extern struct {
            ///  STGENC control register
            STGENC_CNTCR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  HLTDBG
                HLTDBG: u1,
                padding: u30,
            }),
            ///  STGENC status register
            STGENC_CNTSR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  HLTDBG
                HLTDBG: u1,
                padding: u30,
            }),
            ///  the control interface must clear the STGENC_CNTCR.EN bit before writing to this register.
            STGENC_CNTCVL: mmio.Mmio(packed struct(u32) {
                ///  CNTCVL_L_32
                CNTCVL_L_32: u32,
            }),
            ///  the control interface must clear the STGENC_CNTCR.EN bit before writing to this register.
            STGENC_CNTCVU: mmio.Mmio(packed struct(u32) {
                ///  CNTCVU_U_32
                CNTCVU_U_32: u32,
            }),
            reserved32: [16]u8,
            ///  the control interface must clear the STGEN_CNTCR.EN bit before writing to this register.
            STGENC_CNTFID0: mmio.Mmio(packed struct(u32) {
                ///  FREQ
                FREQ: u32,
            }),
            reserved4048: [4012]u8,
            ///  STGENC peripheral ID4 register
            STGENC_PIDR4: mmio.Mmio(packed struct(u32) {
                ///  DES_2
                DES_2: u4,
                ///  SIZE
                SIZE: u4,
                padding: u24,
            }),
            ///  STGENC peripheral ID5 register
            STGENC_PIDR5: mmio.Mmio(packed struct(u32) {
                ///  PIDR5
                PIDR5: u32,
            }),
            ///  STGENC peripheral ID6 register
            STGENC_PIDR6: mmio.Mmio(packed struct(u32) {
                ///  PIDR6
                PIDR6: u32,
            }),
            ///  STGENC peripheral ID7 register
            STGENC_PIDR7: mmio.Mmio(packed struct(u32) {
                ///  PIDR7
                PIDR7: u32,
            }),
            ///  STGENC peripheral ID0 register
            STGENC_PIDR0: mmio.Mmio(packed struct(u32) {
                ///  PART_0
                PART_0: u8,
                padding: u24,
            }),
            ///  STGENC peripheral ID1 register
            STGENC_PIDR1: mmio.Mmio(packed struct(u32) {
                ///  PART_1
                PART_1: u4,
                ///  DES_0
                DES_0: u4,
                padding: u24,
            }),
            ///  STGENC peripheral ID2 register
            STGENC_PIDR2: mmio.Mmio(packed struct(u32) {
                ///  DES_1
                DES_1: u3,
                ///  JEDEC
                JEDEC: u1,
                ///  REVISION
                REVISION: u4,
                padding: u24,
            }),
            ///  STGENC peripheral ID3 register
            STGENC_PIDR3: mmio.Mmio(packed struct(u32) {
                ///  CMOD
                CMOD: u4,
                ///  REVAND
                REVAND: u4,
                padding: u24,
            }),
            ///  STGENC component ID0 register
            STGENC_CIDR0: mmio.Mmio(packed struct(u32) {
                ///  PRMBL_0
                PRMBL_0: u8,
                padding: u24,
            }),
            ///  STGENC component ID1 register
            STGENC_CIDR1: mmio.Mmio(packed struct(u32) {
                ///  PRMBL_1
                PRMBL_1: u4,
                ///  CLASS
                CLASS: u4,
                padding: u24,
            }),
            ///  STGENC component ID2 register
            STGENC_CIDR2: mmio.Mmio(packed struct(u32) {
                ///  PRMBL_2
                PRMBL_2: u8,
                padding: u24,
            }),
            ///  STGENC component ID3 register
            STGENC_CIDR3: mmio.Mmio(packed struct(u32) {
                ///  PRMBL_3
                PRMBL_3: u8,
                padding: u24,
            }),
        };

        ///  STGENR
        pub const STGENR = extern struct {
            ///  the control interface must clear the STGEN_CNTCR.EN bit before writing to this register.
            STGENR_CNTCVL: mmio.Mmio(packed struct(u32) {
                ///  CNTCVL_L_32
                CNTCVL_L_32: u32,
            }),
            ///  the control interface must clear the STGEN_CNTCR.EN bit before writing to this register.
            STGENR_CNTCVU: mmio.Mmio(packed struct(u32) {
                ///  CNTCVU_U_32
                CNTCVU_U_32: u32,
            }),
            reserved4048: [4040]u8,
            ///  STGENR peripheral ID4 register
            STGENR_PIDR4: mmio.Mmio(packed struct(u32) {
                ///  DES_2
                DES_2: u4,
                ///  SIZE
                SIZE: u4,
                padding: u24,
            }),
            ///  STGENR peripheral ID5 register
            STGENR_PIDR5: mmio.Mmio(packed struct(u32) {
                ///  PIDR5
                PIDR5: u32,
            }),
            ///  STGENR peripheral ID6 register
            STGENR_PIDR6: mmio.Mmio(packed struct(u32) {
                ///  PIDR6
                PIDR6: u32,
            }),
            ///  STGENR peripheral ID7 register
            STGENR_PIDR7: mmio.Mmio(packed struct(u32) {
                ///  PIDR7
                PIDR7: u32,
            }),
            ///  STGENR peripheral ID0 register
            STGENR_PIDR0: mmio.Mmio(packed struct(u32) {
                ///  PART_0
                PART_0: u8,
                padding: u24,
            }),
            ///  STGENR peripheral ID1 register
            STGENR_PIDR1: mmio.Mmio(packed struct(u32) {
                ///  PART_1
                PART_1: u4,
                ///  DES_0
                DES_0: u4,
                padding: u24,
            }),
            ///  STGENR peripheral ID2 register
            STGENR_PIDR2: mmio.Mmio(packed struct(u32) {
                ///  DES_1
                DES_1: u3,
                ///  JEDEC
                JEDEC: u1,
                ///  REVISION
                REVISION: u4,
                padding: u24,
            }),
            ///  STGENR peripheral ID3 register
            STGENR_PIDR3: mmio.Mmio(packed struct(u32) {
                ///  CMOD
                CMOD: u4,
                ///  REVAND
                REVAND: u4,
                padding: u24,
            }),
            ///  STGENR component ID0 register
            STGENR_CIDR0: mmio.Mmio(packed struct(u32) {
                ///  PRMBL_0
                PRMBL_0: u8,
                padding: u24,
            }),
            ///  STGENR component ID1 register
            STGENR_CIDR1: mmio.Mmio(packed struct(u32) {
                ///  PRMBL_1
                PRMBL_1: u4,
                ///  CLASS
                CLASS: u4,
                padding: u24,
            }),
            ///  STGENR component ID2 register
            STGENR_CIDR2: mmio.Mmio(packed struct(u32) {
                ///  PRMBL_2
                PRMBL_2: u8,
                padding: u24,
            }),
            ///  STGENR component ID3 register
            STGENR_CIDR3: mmio.Mmio(packed struct(u32) {
                ///  PRMBL_3
                PRMBL_3: u8,
                padding: u24,
            }),
        };

        ///  Universal synchronous asynchronous receiver transmitter
        pub const USART1 = extern struct {
            ///  Control register 1
            CR1: mmio.Mmio(packed struct(u32) {
                ///  USART enable
                UE: u1,
                ///  USART enable in Stop mode
                UESM: u1,
                ///  Receiver enable
                RE: u1,
                ///  Transmitter enable
                TE: u1,
                ///  IDLE interrupt enable
                IDLEIE: u1,
                ///  RXNE interrupt enable
                RXNEIE: u1,
                ///  Transmission complete interrupt enable
                TCIE: u1,
                ///  interrupt enable
                TXEIE: u1,
                ///  PE interrupt enable
                PEIE: u1,
                ///  Parity selection
                PS: u1,
                ///  Parity control enable
                PCE: u1,
                ///  Receiver wakeup method
                WAKE: u1,
                ///  Word length
                M0: u1,
                ///  Mute mode enable
                MME: u1,
                ///  Character match interrupt enable
                CMIE: u1,
                ///  Oversampling mode
                OVER8: u1,
                ///  DEDT
                DEDT: u5,
                ///  DEAT
                DEAT: u5,
                ///  Receiver timeout interrupt enable
                RTOIE: u1,
                ///  End of Block interrupt enable
                EOBIE: u1,
                ///  Word length
                M1: u1,
                ///  FIFO mode enable
                FIFOEN: u1,
                ///  TXFIFO empty interrupt enable
                TXFEIE: u1,
                ///  RXFIFO Full interrupt enable
                RXFFIE: u1,
            }),
            ///  Control register 2
            CR2: mmio.Mmio(packed struct(u32) {
                ///  Synchronous Slave mode enable
                SLVEN: u1,
                reserved3: u2,
                ///  When the DSI_NSS bit is set, the NSS pin input will be ignored
                DIS_NSS: u1,
                ///  7-bit Address Detection/4-bit Address Detection
                ADDM7: u1,
                ///  LIN break detection length
                LBDL: u1,
                ///  LIN break detection interrupt enable
                LBDIE: u1,
                reserved8: u1,
                ///  Last bit clock pulse
                LBCL: u1,
                ///  Clock phase
                CPHA: u1,
                ///  Clock polarity
                CPOL: u1,
                ///  Clock enable
                CLKEN: u1,
                ///  STOP bits
                STOP: u2,
                ///  LIN mode enable
                LINEN: u1,
                ///  Swap TX/RX pins
                SWAP: u1,
                ///  RX pin active level inversion
                RXINV: u1,
                ///  TX pin active level inversion
                TXINV: u1,
                ///  Binary data inversion
                TAINV: u1,
                ///  Most significant bit first
                MSBFIRST: u1,
                ///  Auto baud rate enable
                ABREN: u1,
                ///  Auto baud rate mode
                ABRMOD: u2,
                ///  Receiver timeout enable
                RTOEN: u1,
                ///  Address of the USART node
                ADD0_3: u4,
                ///  Address of the USART node
                ADD4_7: u4,
            }),
            ///  Control register 3
            CR3: mmio.Mmio(packed struct(u32) {
                ///  Error interrupt enable
                EIE: u1,
                ///  Ir mode enable
                IREN: u1,
                ///  Ir low-power
                IRLP: u1,
                ///  Half-duplex selection
                HDSEL: u1,
                ///  Smartcard NACK enable
                NACK: u1,
                ///  Smartcard mode enable
                SCEN: u1,
                ///  DMA enable receiver
                DMAR: u1,
                ///  DMA enable transmitter
                DMAT: u1,
                ///  RTS enable
                RTSE: u1,
                ///  CTS enable
                CTSE: u1,
                ///  CTS interrupt enable
                CTSIE: u1,
                ///  One sample bit method enable
                ONEBIT: u1,
                ///  Overrun Disable
                OVRDIS: u1,
                ///  DMA Disable on Reception Error
                DDRE: u1,
                ///  Driver enable mode
                DEM: u1,
                ///  Driver enable polarity selection
                DEP: u1,
                reserved17: u1,
                ///  Smartcard auto-retry count
                SCARCNT: u3,
                ///  Wakeup from Stop mode interrupt flag selection
                WUS: u2,
                ///  Wakeup from Stop mode interrupt enable
                WUFIE: u1,
                ///  threshold interrupt enable
                TXFTIE: u1,
                ///  Tr Complete before guard time, interrupt enable
                TCBGTIE: u1,
                ///  Receive FIFO threshold configuration
                RXFTCFG: u3,
                ///  RXFIFO threshold interrupt enable
                RXFTIE: u1,
                ///  TXFIFO threshold configuration
                TXFTCFG: u3,
            }),
            ///  Baud rate register
            BRR: mmio.Mmio(packed struct(u32) {
                ///  BRR_0_3
                BRR_0_3: u4,
                ///  BRR_4_15
                BRR_4_15: u12,
                padding: u16,
            }),
            ///  Guard time and prescaler register
            GTPR: mmio.Mmio(packed struct(u32) {
                ///  Prescaler value
                PSC: u8,
                ///  Guard time value
                GT: u8,
                padding: u16,
            }),
            ///  Receiver timeout register
            RTOR: mmio.Mmio(packed struct(u32) {
                ///  Receiver timeout value
                RTO: u24,
                ///  Block Length
                BLEN: u8,
            }),
            ///  Request register
            RQR: mmio.Mmio(packed struct(u32) {
                ///  Auto baud rate request
                ABRRQ: u1,
                ///  Send break request
                SBKRQ: u1,
                ///  Mute mode request
                MMRQ: u1,
                ///  Receive data flush request
                RXFRQ: u1,
                ///  Transmit data flush request
                TXFRQ: u1,
                padding: u27,
            }),
            ///  Interrupt & status register
            ISR: mmio.Mmio(packed struct(u32) {
                ///  PE
                PE: u1,
                ///  FE
                FE: u1,
                ///  NF
                NF: u1,
                ///  ORE
                ORE: u1,
                ///  IDLE
                IDLE: u1,
                ///  RXNE
                RXNE: u1,
                ///  TC
                TC: u1,
                ///  TXE
                TXE: u1,
                ///  LBDF
                LBDF: u1,
                ///  CTSIF
                CTSIF: u1,
                ///  CTS
                CTS: u1,
                ///  RTOF
                RTOF: u1,
                ///  EOBF
                EOBF: u1,
                ///  SPI slave underrun error flag
                UDR: u1,
                ///  ABRE
                ABRE: u1,
                ///  ABRF
                ABRF: u1,
                ///  BUSY
                BUSY: u1,
                ///  CMF
                CMF: u1,
                ///  SBKF
                SBKF: u1,
                ///  RWU
                RWU: u1,
                ///  WUF
                WUF: u1,
                ///  TEACK
                TEACK: u1,
                ///  REACK
                REACK: u1,
                ///  TXFIFO Empty
                TXFE: u1,
                ///  RXFIFO Full
                RXFF: u1,
                ///  Transmission complete before guard time flag
                TCBGT: u1,
                ///  RXFIFO threshold flag
                RXFT: u1,
                ///  TXFIFO threshold flag
                TXFT: u1,
                padding: u4,
            }),
            ///  Interrupt flag clear register
            ICR: mmio.Mmio(packed struct(u32) {
                ///  Parity error clear flag
                PECF: u1,
                ///  Framing error clear flag
                FECF: u1,
                ///  Noise detected clear flag
                NCF: u1,
                ///  Overrun error clear flag
                ORECF: u1,
                ///  Idle line detected clear flag
                IDLECF: u1,
                ///  TXFIFO empty clear flag
                TXFECF: u1,
                ///  Transmission complete clear flag
                TCCF: u1,
                ///  Transmission complete before Guard time clear flag
                TCBGTCF: u1,
                ///  LIN break detection clear flag
                LBDCF: u1,
                ///  CTS clear flag
                CTSCF: u1,
                reserved11: u1,
                ///  Receiver timeout clear flag
                RTOCF: u1,
                ///  End of block clear flag
                EOBCF: u1,
                ///  SPI slave underrun clear flag
                UDRCF: u1,
                reserved17: u3,
                ///  Character match clear flag
                CMCF: u1,
                reserved20: u2,
                ///  Wakeup from Stop mode clear flag
                WUCF: u1,
                padding: u11,
            }),
            ///  Receive data register
            RDR: mmio.Mmio(packed struct(u32) {
                ///  Receive data value
                RDR: u9,
                padding: u23,
            }),
            ///  Transmit data register
            TDR: mmio.Mmio(packed struct(u32) {
                ///  Transmit data value
                TDR: u9,
                padding: u23,
            }),
            ///  Prescaler register
            PRESC: mmio.Mmio(packed struct(u32) {
                ///  Clock prescaler
                PRESCALER: u4,
                padding: u28,
            }),
            reserved1004: [956]u8,
            ///  USART Hardware Configuration register 2
            HWCFGR2: mmio.Mmio(packed struct(u32) {
                ///  CFG1
                CFG1: u4,
                ///  CFG2
                CFG2: u4,
                padding: u24,
            }),
            ///  USART Hardware Configuration register 1
            HWCFGR1: mmio.Mmio(packed struct(u32) {
                ///  CFG1
                CFG1: u4,
                ///  CFG2
                CFG2: u4,
                ///  CFG3
                CFG3: u4,
                ///  CFG4
                CFG4: u4,
                ///  CFG5
                CFG5: u4,
                ///  CFG6
                CFG6: u4,
                ///  CFG7
                CFG7: u4,
                ///  CFG8
                CFG8: u4,
            }),
            ///  EXTI IP Version register
            VERR: mmio.Mmio(packed struct(u32) {
                ///  Minor Revision number
                MINREV: u4,
                ///  Major Revision number
                MAJREV: u4,
                padding: u24,
            }),
            ///  EXTI Identification register
            IPIDR: mmio.Mmio(packed struct(u32) {
                ///  IP Identification
                IPID: u32,
            }),
            ///  EXTI Size ID register
            SIDR: mmio.Mmio(packed struct(u32) {
                ///  Size Identification
                SID: u32,
            }),
        };

        ///  IPCC
        pub const IPCC = extern struct {
            ///  IPCC Processor 1 control register
            IPCC_C1CR: mmio.Mmio(packed struct(u32) {
                ///  RXOIE
                RXOIE: u1,
                reserved16: u15,
                ///  TXFIE
                TXFIE: u1,
                padding: u15,
            }),
            ///  IPCC Processor 1 mask register
            IPCC_C1MR: mmio.Mmio(packed struct(u32) {
                ///  CHxOM
                CHxOM: u6,
                reserved16: u10,
                ///  CHxFM
                CHxFM: u6,
                padding: u10,
            }),
            ///  Reading this register will always return 0x0000 0000.
            IPCC_C1SCR: mmio.Mmio(packed struct(u32) {
                ///  CHxC
                CHxC: u6,
                reserved16: u10,
                ///  CHxS
                CHxS: u6,
                padding: u10,
            }),
            ///  IPCC processor 1 to processor 2 status register
            IPCC_C1TOC2SR: mmio.Mmio(packed struct(u32) {
                ///  CHxF
                CHxF: u6,
                padding: u26,
            }),
            ///  IPCC Processor 2 control register
            IPCC_C2CR: mmio.Mmio(packed struct(u32) {
                ///  RXOIE
                RXOIE: u1,
                reserved16: u15,
                ///  TXFIE
                TXFIE: u1,
                padding: u15,
            }),
            ///  IPCC Processor 2 mask register
            IPCC_C2MR: mmio.Mmio(packed struct(u32) {
                ///  CHxOM
                CHxOM: u6,
                reserved16: u10,
                ///  CHxFM
                CHxFM: u6,
                padding: u10,
            }),
            ///  Reading this register will always return 0x0000 0000.
            IPCC_C2SCR: mmio.Mmio(packed struct(u32) {
                ///  CHxC
                CHxC: u6,
                reserved16: u10,
                ///  CHxS
                CHxS: u6,
                padding: u10,
            }),
            ///  IPCC processor 2 to processor 1 status register
            IPCC_C2TOC1SR: mmio.Mmio(packed struct(u32) {
                ///  CHxF
                CHxF: u6,
                padding: u26,
            }),
            reserved1008: [976]u8,
            ///  IPCC Hardware configuration register
            IPCC_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  CHANNELS
                CHANNELS: u8,
                padding: u24,
            }),
            ///  IPCC IP Version register
            IPCC_VER: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  IPCC IP Identification register
            IPCC_ID: mmio.Mmio(packed struct(u32) {
                ///  IPID
                IPID: u32,
            }),
            ///  IPCC Size ID register
            IPCC_SID: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  IWDG1
        pub const IWDG1 = extern struct {
            ///  Key register
            IWDG_KR: mmio.Mmio(packed struct(u32) {
                ///  KEY
                KEY: u16,
                padding: u16,
            }),
            ///  Prescaler register
            IWDG_PR: mmio.Mmio(packed struct(u32) {
                ///  PR
                PR: u3,
                padding: u29,
            }),
            ///  Reload register
            IWDG_RLR: mmio.Mmio(packed struct(u32) {
                ///  RL
                RL: u12,
                padding: u20,
            }),
            ///  Status register
            IWDG_SR: mmio.Mmio(packed struct(u32) {
                ///  PVU
                PVU: u1,
                ///  RVU
                RVU: u1,
                ///  WVU
                WVU: u1,
                padding: u29,
            }),
            ///  Window register
            IWDG_WINR: mmio.Mmio(packed struct(u32) {
                ///  WIN
                WIN: u12,
                padding: u20,
            }),
            reserved1008: [988]u8,
            ///  IWDG hardware configuration register
            IWDG_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  WINDOW
                WINDOW: u4,
                ///  PR_DEFAULT
                PR_DEFAULT: u4,
                padding: u24,
            }),
            ///  IWDG version register
            IWDG_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  IWDG identification register
            IWDG_IDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  IWDG size identification register
            IWDG_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  TZC
        pub const TZC = extern struct {
            ///  Provides information about TZC configuration.
            TZC_BUILD_CONFIG: mmio.Mmio(packed struct(u32) {
                ///  NO_OF_REGIONS
                NO_OF_REGIONS: u5,
                reserved8: u3,
                ///  ADDRESS_WIDTH
                ADDRESS_WIDTH: u6,
                reserved24: u10,
                ///  NO_OF_FILTERS
                NO_OF_FILTERS: u2,
                padding: u6,
            }),
            ///  Controls interrupt and bus error response behavior when regions permission failures occur.
            TZC_ACTION: mmio.Mmio(packed struct(u32) {
                ///  REACTION_VALUE
                REACTION_VALUE: u2,
                padding: u30,
            }),
            ///  Provides control and status for the gate keeper in each filter unit implemented.
            TZC_GATE_KEEPER: mmio.Mmio(packed struct(u32) {
                ///  OPENREQ
                OPENREQ: u2,
                reserved16: u14,
                ///  OPENSTAT
                OPENSTAT: u2,
                padding: u14,
            }),
            ///  Controls read and write access speculation.
            TZC_SPECULATION_CTRL: mmio.Mmio(packed struct(u32) {
                ///  READSPEC_DISABLE
                READSPEC_DISABLE: u1,
                ///  WRITESPEC_DISABLE
                WRITESPEC_DISABLE: u1,
                padding: u30,
            }),
            ///  Contains the status of the interrupt signal, TZCINT, that reports access security violations or region overlap errors.
            TZC_INT_STATUS: mmio.Mmio(packed struct(u32) {
                ///  STATUS
                STATUS: u2,
                reserved8: u6,
                ///  OVERRUN
                OVERRUN: u2,
                reserved16: u6,
                ///  OVERLAP
                OVERLAP: u2,
                padding: u14,
            }),
            ///  Interrupt clear for each filter.
            TZC_INT_CLEAR: mmio.Mmio(packed struct(u32) {
                ///  CLEAR
                CLEAR: u2,
                padding: u30,
            }),
            reserved32: [8]u8,
            ///  Address low bits of the first failed access in the associated filter (0 to 1).
            TZC_FAIL_ADDRESS_LOW0: mmio.Mmio(packed struct(u32) {
                ///  ADDR_STATUS_LOW
                ADDR_STATUS_LOW: u32,
            }),
            ///  Address high bit of the first failed access in the associated filter (0 to 1). Not used with 32bit address.
            TZC_FAIL_ADDRESS_HIGH0: u32,
            ///  Status information about the first access that failed a region permission check in the associated filter (0 to 1).
            TZC_FAIL_CONTROL0: mmio.Mmio(packed struct(u32) {
                reserved20: u20,
                ///  PRIVILEGE
                PRIVILEGE: u1,
                ///  NON_SECURE
                NON_SECURE: u1,
                reserved24: u2,
                ///  DIRECTION
                DIRECTION: u1,
                padding: u7,
            }),
            ///  Contains the master AXI ARID or AWID of the first access that failed a region permission check in the associated filter unit. This occurs even if the ACTION register is set to not drive the interrupt signal. AXI ID mapping is described in Table4: NSAID definition table (TBD).
            TZC_FAIL_ID0: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u11,
                padding: u21,
            }),
            ///  Address low bits of the first failed access in the associated filter (0 to 1).
            TZC_FAIL_ADDRESS_LOW1: mmio.Mmio(packed struct(u32) {
                ///  ADDR_STATUS_LOW
                ADDR_STATUS_LOW: u32,
            }),
            ///  Address high bit of the first failed access in the associated filter (0 to 1). Not used with 32bit address.
            TZC_FAIL_ADDRESS_HIGH1: u32,
            ///  Status information about the first access that failed a region permission check in the associated filter (0 to 1).
            TZC_FAIL_CONTROL1: mmio.Mmio(packed struct(u32) {
                reserved20: u20,
                ///  PRIVILEGE
                PRIVILEGE: u1,
                ///  NON_SECURE
                NON_SECURE: u1,
                reserved24: u2,
                ///  DIRECTION
                DIRECTION: u1,
                padding: u7,
            }),
            ///  Contains the master AXI ARID or AWID of the first access that failed a region permission check in the associated filter unit. This occurs even if the ACTION register is set to not drive the interrupt signal. AXI ID mapping is described in Table4: NSAID definition table (TBD).
            TZC_FAIL_ID1: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u11,
                padding: u21,
            }),
            reserved260: [196]u8,
            ///  Base address high are not used with 32-bit address.
            TZC_REGION_BASE_HIGH0: u32,
            ///  Top address bits [31:12] for region 0.
            TZC_REGION_TOP_LOW0: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  TOP_ADDRESS_LOW
                TOP_ADDRESS_LOW: u20,
            }),
            ///  Top address high of region are not used with 32-bit address.
            TZC_REGION_TOP_HIGH0: u32,
            ///  Region 0 attributes.
            TZC_REGION_ATTRIBUTE0: mmio.Mmio(packed struct(u32) {
                ///  FILTER_EN
                FILTER_EN: u2,
                reserved30: u28,
                ///  S_RD_EN
                S_RD_EN: u1,
                ///  S_WR_EN
                S_WR_EN: u1,
            }),
            ///  Region non-secure access based on NSAID.
            TZC_REGION_ID_ACCESS0: mmio.Mmio(packed struct(u32) {
                ///  NSAID_RD_EN
                NSAID_RD_EN: u16,
                ///  NSAID_WR_EN
                NSAID_WR_EN: u16,
            }),
            reserved288: [8]u8,
            ///  Base address low for regions 1 to 8.
            TZC_REGION_BASE_LOW1: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  BASE_ADDRESS_LOW
                BASE_ADDRESS_LOW: u20,
            }),
            ///  Base address high are not used with 32-bit address.
            TZC_REGION_BASE_HIGH1: u32,
            ///  Top address bits [31:12] for region x.
            TZC_REGION_TOP_LOW1: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  TOP_ADDRESS_LOW
                TOP_ADDRESS_LOW: u20,
            }),
            ///  Top address high of region are not used with 32-bit address.
            TZC_REGION_TOP_HIGH1: u32,
            ///  Region x attributes.
            TZC_REGION_ATTRIBUTE1: mmio.Mmio(packed struct(u32) {
                ///  FILTER_EN
                FILTER_EN: u2,
                reserved30: u28,
                ///  S_RD_EN
                S_RD_EN: u1,
                ///  S_WR_EN
                S_WR_EN: u1,
            }),
            ///  Region non-secure access based on NSAID.
            TZC_REGION_ID_ACCESS1: mmio.Mmio(packed struct(u32) {
                ///  NSAID_RD_EN
                NSAID_RD_EN: u16,
                ///  NSAID_WR_EN
                NSAID_WR_EN: u16,
            }),
            reserved320: [8]u8,
            ///  Base address low for regions 1 to 8.
            TZC_REGION_BASE_LOW2: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  BASE_ADDRESS_LOW
                BASE_ADDRESS_LOW: u20,
            }),
            ///  Base address high are not used with 32-bit address.
            TZC_REGION_BASE_HIGH2: u32,
            ///  Top address bits [31:12] for region x.
            TZC_REGION_TOP_LOW2: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  TOP_ADDRESS_LOW
                TOP_ADDRESS_LOW: u20,
            }),
            ///  Top address high of region are not used with 32-bit address.
            TZC_REGION_TOP_HIGH2: u32,
            ///  Region x attributes.
            TZC_REGION_ATTRIBUTE2: mmio.Mmio(packed struct(u32) {
                ///  FILTER_EN
                FILTER_EN: u2,
                reserved30: u28,
                ///  S_RD_EN
                S_RD_EN: u1,
                ///  S_WR_EN
                S_WR_EN: u1,
            }),
            ///  Region non-secure access based on NSAID.
            TZC_REGION_ID_ACCESS2: mmio.Mmio(packed struct(u32) {
                ///  NSAID_RD_EN
                NSAID_RD_EN: u16,
                ///  NSAID_WR_EN
                NSAID_WR_EN: u16,
            }),
            reserved352: [8]u8,
            ///  Base address low for regions 1 to 8.
            TZC_REGION_BASE_LOW3: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  BASE_ADDRESS_LOW
                BASE_ADDRESS_LOW: u20,
            }),
            ///  Base address high are not used with 32-bit address.
            TZC_REGION_BASE_HIGH3: u32,
            ///  Top address bits [31:12] for region x.
            TZC_REGION_TOP_LOW3: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  TOP_ADDRESS_LOW
                TOP_ADDRESS_LOW: u20,
            }),
            ///  Top address high of region are not used with 32-bit address.
            TZC_REGION_TOP_HIGH3: u32,
            ///  Region x attributes.
            TZC_REGION_ATTRIBUTE3: mmio.Mmio(packed struct(u32) {
                ///  FILTER_EN
                FILTER_EN: u2,
                reserved30: u28,
                ///  S_RD_EN
                S_RD_EN: u1,
                ///  S_WR_EN
                S_WR_EN: u1,
            }),
            ///  Region non-secure access based on NSAID.
            TZC_REGION_ID_ACCESS3: mmio.Mmio(packed struct(u32) {
                ///  NSAID_RD_EN
                NSAID_RD_EN: u16,
                ///  NSAID_WR_EN
                NSAID_WR_EN: u16,
            }),
            reserved384: [8]u8,
            ///  Base address low for regions 1 to 8.
            TZC_REGION_BASE_LOW4: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  BASE_ADDRESS_LOW
                BASE_ADDRESS_LOW: u20,
            }),
            ///  Base address high are not used with 32-bit address.
            TZC_REGION_BASE_HIGH4: u32,
            ///  Top address bits [31:12] for region x.
            TZC_REGION_TOP_LOW4: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  TOP_ADDRESS_LOW
                TOP_ADDRESS_LOW: u20,
            }),
            ///  Top address high of region are not used with 32-bit address.
            TZC_REGION_TOP_HIGH4: u32,
            ///  Region x attributes.
            TZC_REGION_ATTRIBUTE4: mmio.Mmio(packed struct(u32) {
                ///  FILTER_EN
                FILTER_EN: u2,
                reserved30: u28,
                ///  S_RD_EN
                S_RD_EN: u1,
                ///  S_WR_EN
                S_WR_EN: u1,
            }),
            ///  Region non-secure access based on NSAID.
            TZC_REGION_ID_ACCESS4: mmio.Mmio(packed struct(u32) {
                ///  NSAID_RD_EN
                NSAID_RD_EN: u16,
                ///  NSAID_WR_EN
                NSAID_WR_EN: u16,
            }),
            reserved416: [8]u8,
            ///  Base address low for regions 1 to 8.
            TZC_REGION_BASE_LOW5: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  BASE_ADDRESS_LOW
                BASE_ADDRESS_LOW: u20,
            }),
            ///  Base address high are not used with 32-bit address.
            TZC_REGION_BASE_HIGH5: u32,
            ///  Top address bits [31:12] for region x.
            TZC_REGION_TOP_LOW5: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  TOP_ADDRESS_LOW
                TOP_ADDRESS_LOW: u20,
            }),
            ///  Top address high of region are not used with 32-bit address.
            TZC_REGION_TOP_HIGH5: u32,
            ///  Region x attributes.
            TZC_REGION_ATTRIBUTE5: mmio.Mmio(packed struct(u32) {
                ///  FILTER_EN
                FILTER_EN: u2,
                reserved30: u28,
                ///  S_RD_EN
                S_RD_EN: u1,
                ///  S_WR_EN
                S_WR_EN: u1,
            }),
            ///  Region non-secure access based on NSAID.
            TZC_REGION_ID_ACCESS5: mmio.Mmio(packed struct(u32) {
                ///  NSAID_RD_EN
                NSAID_RD_EN: u16,
                ///  NSAID_WR_EN
                NSAID_WR_EN: u16,
            }),
            reserved448: [8]u8,
            ///  Base address low for regions 1 to 8.
            TZC_REGION_BASE_LOW6: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  BASE_ADDRESS_LOW
                BASE_ADDRESS_LOW: u20,
            }),
            ///  Base address high are not used with 32-bit address.
            TZC_REGION_BASE_HIGH6: u32,
            ///  Top address bits [31:12] for region x.
            TZC_REGION_TOP_LOW6: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  TOP_ADDRESS_LOW
                TOP_ADDRESS_LOW: u20,
            }),
            ///  Top address high of region are not used with 32-bit address.
            TZC_REGION_TOP_HIGH6: u32,
            ///  Region x attributes.
            TZC_REGION_ATTRIBUTE6: mmio.Mmio(packed struct(u32) {
                ///  FILTER_EN
                FILTER_EN: u2,
                reserved30: u28,
                ///  S_RD_EN
                S_RD_EN: u1,
                ///  S_WR_EN
                S_WR_EN: u1,
            }),
            ///  Region non-secure access based on NSAID.
            TZC_REGION_ID_ACCESS6: mmio.Mmio(packed struct(u32) {
                ///  NSAID_RD_EN
                NSAID_RD_EN: u16,
                ///  NSAID_WR_EN
                NSAID_WR_EN: u16,
            }),
            reserved488: [16]u8,
            ///  Top address bits [31:12] for region x.
            TZC_REGION_TOP_LOW7: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  TOP_ADDRESS_LOW
                TOP_ADDRESS_LOW: u20,
            }),
            reserved496: [4]u8,
            ///  Region x attributes.
            TZC_REGION_ATTRIBUTE7: mmio.Mmio(packed struct(u32) {
                ///  FILTER_EN
                FILTER_EN: u2,
                reserved30: u28,
                ///  S_RD_EN
                S_RD_EN: u1,
                ///  S_WR_EN
                S_WR_EN: u1,
            }),
            reserved512: [12]u8,
            ///  Base address low for regions 1 to 8.
            TZC_REGION_BASE_LOW8: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  BASE_ADDRESS_LOW
                BASE_ADDRESS_LOW: u20,
            }),
            ///  Base address high are not used with 32-bit address.
            TZC_REGION_BASE_HIGH8: u32,
            reserved528: [8]u8,
            ///  Region x attributes.
            TZC_REGION_ATTRIBUTE8: mmio.Mmio(packed struct(u32) {
                ///  FILTER_EN
                FILTER_EN: u2,
                reserved30: u28,
                ///  S_RD_EN
                S_RD_EN: u1,
                ///  S_WR_EN
                S_WR_EN: u1,
            }),
            reserved736: [204]u8,
            ///  Base address low for regions 1 to 8.
            TZC_REGION_BASE_LOW7: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  BASE_ADDRESS_LOW
                BASE_ADDRESS_LOW: u20,
            }),
            ///  Base address high are not used with 32-bit address.
            TZC_REGION_BASE_HIGH7: u32,
            reserved748: [4]u8,
            ///  Top address high of region are not used with 32-bit address.
            TZC_REGION_TOP_HIGH7: u32,
            reserved756: [4]u8,
            ///  Region non-secure access based on NSAID.
            TZC_REGION_ID_ACCESS7: mmio.Mmio(packed struct(u32) {
                ///  NSAID_RD_EN
                NSAID_RD_EN: u16,
                ///  NSAID_WR_EN
                NSAID_WR_EN: u16,
            }),
            reserved776: [16]u8,
            ///  Top address bits [31:12] for region x.
            TZC_REGION_TOP_LOW8: mmio.Mmio(packed struct(u32) {
                reserved12: u12,
                ///  TOP_ADDRESS_LOW
                TOP_ADDRESS_LOW: u20,
            }),
            ///  Top address high of region are not used with 32-bit address.
            TZC_REGION_TOP_HIGH8: u32,
            reserved788: [4]u8,
            ///  Region non-secure access based on NSAID.
            TZC_REGION_ID_ACCESS8: mmio.Mmio(packed struct(u32) {
                ///  NSAID_RD_EN
                NSAID_RD_EN: u16,
                ///  NSAID_WR_EN
                NSAID_WR_EN: u16,
            }),
            reserved4048: [3256]u8,
            ///  Peripheral ID 4.
            TZC_PID4: mmio.Mmio(packed struct(u32) {
                ///  PER_ID_4
                PER_ID_4: u8,
                padding: u24,
            }),
            ///  Peripheral ID 5.
            TZC_PID5: mmio.Mmio(packed struct(u32) {
                ///  PER_ID_5
                PER_ID_5: u8,
                padding: u24,
            }),
            ///  Peripheral ID 6.
            TZC_PID6: mmio.Mmio(packed struct(u32) {
                ///  PER_ID_6
                PER_ID_6: u8,
                padding: u24,
            }),
            ///  Peripheral ID 7.
            TZC_PID7: mmio.Mmio(packed struct(u32) {
                ///  PER_ID_7
                PER_ID_7: u8,
                padding: u24,
            }),
            ///  Peripheral ID 0.
            TZC_PID0: mmio.Mmio(packed struct(u32) {
                ///  PER_ID_0
                PER_ID_0: u8,
                padding: u24,
            }),
            ///  Peripheral ID 1.
            TZC_PID1: mmio.Mmio(packed struct(u32) {
                ///  PER_ID_1
                PER_ID_1: u8,
                padding: u24,
            }),
            ///  Peripheral ID 2.
            TZC_PID2: mmio.Mmio(packed struct(u32) {
                ///  PER_ID_2
                PER_ID_2: u8,
                padding: u24,
            }),
            ///  Peripheral ID 3.
            TZC_PID3: mmio.Mmio(packed struct(u32) {
                ///  PER_ID_3
                PER_ID_3: u8,
                padding: u24,
            }),
            ///  Component ID 0.
            TZC_CID0: mmio.Mmio(packed struct(u32) {
                ///  COMP_ID_0
                COMP_ID_0: u8,
                padding: u24,
            }),
            ///  Component ID 1.
            TZC_CID1: mmio.Mmio(packed struct(u32) {
                ///  COMP_ID_1
                COMP_ID_1: u8,
                padding: u24,
            }),
            ///  Component ID 2.
            TZC_CID2: mmio.Mmio(packed struct(u32) {
                ///  COMP_ID_2
                COMP_ID_2: u8,
                padding: u24,
            }),
            ///  Component ID 3.
            TZC_CID3: mmio.Mmio(packed struct(u32) {
                ///  COMP_ID_3
                COMP_ID_3: u8,
                padding: u24,
            }),
        };

        ///  LPTIM1
        pub const LPTIM1 = extern struct {
            ///  LPTIM interrupt and status register
            LPTIM_ISR: mmio.Mmio(packed struct(u32) {
                ///  CMPM
                CMPM: u1,
                ///  ARRM
                ARRM: u1,
                ///  EXTTRIG
                EXTTRIG: u1,
                ///  CMPOK
                CMPOK: u1,
                ///  ARROK
                ARROK: u1,
                ///  UP
                UP: u1,
                ///  DOWN
                DOWN: u1,
                padding: u25,
            }),
            ///  LPTIM interrupt clear register
            LPTIM_ICR: mmio.Mmio(packed struct(u32) {
                ///  CMPMCF
                CMPMCF: u1,
                ///  ARRMCF
                ARRMCF: u1,
                ///  EXTTRIGCF
                EXTTRIGCF: u1,
                ///  CMPOKCF
                CMPOKCF: u1,
                ///  ARROKCF
                ARROKCF: u1,
                ///  UPCF
                UPCF: u1,
                ///  DOWNCF
                DOWNCF: u1,
                padding: u25,
            }),
            ///  LPTIM interrupt enable register
            LPTIM_IER: mmio.Mmio(packed struct(u32) {
                ///  CMPMIE
                CMPMIE: u1,
                ///  ARRMIE
                ARRMIE: u1,
                ///  EXTTRIGIE
                EXTTRIGIE: u1,
                ///  CMPOKIE
                CMPOKIE: u1,
                ///  ARROKIE
                ARROKIE: u1,
                ///  UPIE
                UPIE: u1,
                ///  DOWNIE
                DOWNIE: u1,
                padding: u25,
            }),
            ///  LPTIM configuration register
            LPTIM_CFGR: mmio.Mmio(packed struct(u32) {
                ///  CKSEL
                CKSEL: u1,
                ///  CKPOL
                CKPOL: u2,
                ///  CKFLT
                CKFLT: u2,
                reserved6: u1,
                ///  TRGFLT
                TRGFLT: u2,
                reserved9: u1,
                ///  PRESC
                PRESC: u3,
                reserved13: u1,
                ///  TRIGSEL
                TRIGSEL: u3,
                reserved17: u1,
                ///  TRIGEN
                TRIGEN: u2,
                ///  TIMOUT
                TIMOUT: u1,
                ///  WAVE
                WAVE: u1,
                ///  WAVPOL
                WAVPOL: u1,
                ///  PRELOAD
                PRELOAD: u1,
                ///  COUNTMODE
                COUNTMODE: u1,
                ///  ENC
                ENC: u1,
                padding: u7,
            }),
            ///  LPTIM control register
            LPTIM_CR: mmio.Mmio(packed struct(u32) {
                ///  ENABLE
                ENABLE: u1,
                ///  SNGSTRT
                SNGSTRT: u1,
                ///  CNTSTRT
                CNTSTRT: u1,
                ///  COUNTRST
                COUNTRST: u1,
                ///  RSTARE
                RSTARE: u1,
                padding: u27,
            }),
            ///  LPTIM compare register
            LPTIM_CMP: mmio.Mmio(packed struct(u32) {
                ///  CMP
                CMP: u16,
                padding: u16,
            }),
            ///  LPTIM autoreload register
            LPTIM_ARR: mmio.Mmio(packed struct(u32) {
                ///  ARR
                ARR: u16,
                padding: u16,
            }),
            ///  LPTIM counter register
            LPTIM_CNT: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u16,
                padding: u16,
            }),
            reserved36: [4]u8,
            ///  LPTIM configuration register 2
            LPTIM_CFGR2: mmio.Mmio(packed struct(u32) {
                ///  IN1SEL
                IN1SEL: u2,
                reserved4: u2,
                ///  IN2SEL
                IN2SEL: u2,
                padding: u26,
            }),
            reserved1008: [968]u8,
            ///  LPTIM 1 peripheral hardware configuration register
            LPTIM1_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  CFG1
                CFG1: u8,
                ///  CFG2
                CFG2: u8,
                ///  CFG3
                CFG3: u4,
                reserved24: u4,
                ///  CFG4
                CFG4: u8,
            }),
            ///  LPTIM peripheral version identification register
            LPTIM_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  LPTIM peripheral type identification register
            LPTIM_PIDR: mmio.Mmio(packed struct(u32) {
                ///  P_ID
                P_ID: u32,
            }),
            ///  LPTIM registers map size identification register
            LPTIM_SIDR: mmio.Mmio(packed struct(u32) {
                ///  S_ID
                S_ID: u32,
            }),
        };

        ///  SYSCFG
        pub const SYSCFG = extern struct {
            ///  This register is used to know the state of BOOT pins and to control pull-up to reduce the static power consumption on the pin set to high level. )
            SYSCFG_BOOTR: mmio.Mmio(packed struct(u32) {
                ///  BOOT0
                BOOT0: u1,
                ///  BOOT1
                BOOT1: u1,
                ///  BOOT2
                BOOT2: u1,
                reserved4: u1,
                ///  BOOT0_PD
                BOOT0_PD: u1,
                ///  BOOT1_PD
                BOOT1_PD: u1,
                ///  BOOT2_PD
                BOOT2_PD: u1,
                padding: u25,
            }),
            ///  SYSCFG peripheral mode configuration set register
            SYSCFG_PMCSETR: mmio.Mmio(packed struct(u32) {
                ///  I2C1_FMP
                I2C1_FMP: u1,
                ///  I2C2_FMP
                I2C2_FMP: u1,
                ///  I2C3_FMP
                I2C3_FMP: u1,
                ///  I2C4_FMP
                I2C4_FMP: u1,
                ///  I2C5_FMP
                I2C5_FMP: u1,
                ///  I2C6_FMP
                I2C6_FMP: u1,
                reserved8: u2,
                ///  EN_BOOSTER
                EN_BOOSTER: u1,
                ///  ANASWVDD
                ANASWVDD: u1,
                reserved16: u6,
                ///  ETH_CLK_SEL
                ETH_CLK_SEL: u1,
                ///  ETH_REF_CLK_SEL
                ETH_REF_CLK_SEL: u1,
                reserved20: u2,
                ///  ETH_SELMII
                ETH_SELMII: u1,
                ///  ETH_SEL
                ETH_SEL: u3,
                ///  ANA0_SEL
                ANA0_SEL: u1,
                ///  ANA1_SEL
                ANA1_SEL: u1,
                padding: u6,
            }),
            reserved24: [16]u8,
            ///  SYSCFG IO control register
            SYSCFG_IOCTRLSETR: mmio.Mmio(packed struct(u32) {
                ///  HSLVEN_TRACE
                HSLVEN_TRACE: u1,
                ///  HSLVEN_QUADSPI
                HSLVEN_QUADSPI: u1,
                ///  HSLVEN_ETH
                HSLVEN_ETH: u1,
                ///  HSLVEN_SDMMC
                HSLVEN_SDMMC: u1,
                ///  HSLVEN_SPI
                HSLVEN_SPI: u1,
                padding: u27,
            }),
            ///  SYSCFG interconnect control register
            SYSCFG_ICNR: mmio.Mmio(packed struct(u32) {
                ///  AXI_M0
                AXI_M0: u1,
                ///  AXI_M1
                AXI_M1: u1,
                ///  AXI_M2
                AXI_M2: u1,
                ///  AXI_M3
                AXI_M3: u1,
                reserved5: u1,
                ///  AXI_M5
                AXI_M5: u1,
                ///  AXI_M6
                AXI_M6: u1,
                ///  AXI_M7
                AXI_M7: u1,
                ///  AXI_M8
                AXI_M8: u1,
                ///  AXI_M9
                AXI_M9: u1,
                ///  AXI_M10
                AXI_M10: u1,
                padding: u21,
            }),
            ///  SYSCFG compensation cell control register
            SYSCFG_CMPCR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  SW_CTRL
                SW_CTRL: u1,
                reserved8: u6,
                ///  READY
                READY: u1,
                reserved16: u7,
                ///  RANSRC
                RANSRC: u4,
                ///  RAPSRC
                RAPSRC: u4,
                ///  ANSRC
                ANSRC: u4,
                ///  APSRC
                APSRC: u4,
            }),
            ///  SYSCFG compensation cell enable set register
            SYSCFG_CMPENSETR: mmio.Mmio(packed struct(u32) {
                ///  MPU_EN
                MPU_EN: u1,
                ///  MCU_EN
                MCU_EN: u1,
                padding: u30,
            }),
            ///  SYSCFG compensation cell enable set register
            SYSCFG_CMPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  MPU_EN
                MPU_EN: u1,
                ///  MCU_EN
                MCU_EN: u1,
                padding: u30,
            }),
            ///  SYSCFG control timer break register
            SYSCFG_CBR: mmio.Mmio(packed struct(u32) {
                ///  CLL
                CLL: u1,
                reserved2: u1,
                ///  PVDL
                PVDL: u1,
                padding: u29,
            }),
            reserved68: [20]u8,
            ///  SYSCFG peripheral mode configuration clear register
            SYSCFG_PMCCLRR: mmio.Mmio(packed struct(u32) {
                ///  I2C1_FMP
                I2C1_FMP: u1,
                ///  I2C2_FMP
                I2C2_FMP: u1,
                ///  I2C3_FMP
                I2C3_FMP: u1,
                ///  I2C4_FMP
                I2C4_FMP: u1,
                ///  I2C5_FMP
                I2C5_FMP: u1,
                ///  I2C6_FMP
                I2C6_FMP: u1,
                reserved8: u2,
                ///  EN_BOOSTER
                EN_BOOSTER: u1,
                ///  ANASWVDD
                ANASWVDD: u1,
                reserved16: u6,
                ///  ETH_CLK_SEL
                ETH_CLK_SEL: u1,
                ///  ETH_REF_CLK_SEL
                ETH_REF_CLK_SEL: u1,
                reserved20: u2,
                ///  ETH_SELMII
                ETH_SELMII: u1,
                ///  ETH_SEL
                ETH_SEL: u3,
                ///  ANA0_SEL
                ANA0_SEL: u1,
                ///  ANA1_SEL
                ANA1_SEL: u1,
                padding: u6,
            }),
            reserved88: [16]u8,
            ///  SYSCFG IO control register
            SYSCFG_IOCTRLCLRR: mmio.Mmio(packed struct(u32) {
                ///  HSLVEN_TRACE
                HSLVEN_TRACE: u1,
                ///  HSLVEN_QUADSPI
                HSLVEN_QUADSPI: u1,
                ///  HSLVEN_ETH
                HSLVEN_ETH: u1,
                ///  HSLVEN_SDMMC
                HSLVEN_SDMMC: u1,
                ///  HSLVEN_SPI
                HSLVEN_SPI: u1,
                padding: u27,
            }),
            reserved1012: [920]u8,
            ///  SYSCFG version register
            SYSCFG_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  SYSCFG identification register
            SYSCFG_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  SYSCFG size identification register
            SYSCFG_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  TIM16
        pub const TIM16 = extern struct {
            ///  TIM16/TIM17 control register 1
            TIMx_CR1: mmio.Mmio(packed struct(u16) {
                ///  CEN
                CEN: u1,
                ///  UDIS
                UDIS: u1,
                ///  URS
                URS: u1,
                ///  OPM
                OPM: u1,
                reserved7: u3,
                ///  ARPE
                ARPE: u1,
                ///  CKD
                CKD: u2,
                reserved11: u1,
                ///  UIFREMAP
                UIFREMAP: u1,
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM16/TIM17 control register 2
            TIMx_CR2: mmio.Mmio(packed struct(u16) {
                ///  CCPC
                CCPC: u1,
                reserved2: u1,
                ///  CCUS
                CCUS: u1,
                ///  CCDS
                CCDS: u1,
                reserved8: u4,
                ///  OIS1
                OIS1: u1,
                ///  OIS1N
                OIS1N: u1,
                padding: u6,
            }),
            reserved12: [6]u8,
            ///  TIM16/TIM17 DMA/interrupt enable register
            TIMx_DIER: mmio.Mmio(packed struct(u16) {
                ///  UIE
                UIE: u1,
                ///  CC1IE
                CC1IE: u1,
                reserved5: u3,
                ///  COMIE
                COMIE: u1,
                reserved7: u1,
                ///  BIE
                BIE: u1,
                ///  UDE
                UDE: u1,
                ///  CC1DE
                CC1DE: u1,
                reserved13: u3,
                ///  COMDE
                COMDE: u1,
                padding: u2,
            }),
            reserved16: [2]u8,
            ///  TIM16/TIM17 status register
            TIMx_SR: mmio.Mmio(packed struct(u16) {
                ///  UIF
                UIF: u1,
                ///  CC1IF
                CC1IF: u1,
                reserved5: u3,
                ///  COMIF
                COMIF: u1,
                reserved7: u1,
                ///  BIF
                BIF: u1,
                reserved9: u1,
                ///  CC1OF
                CC1OF: u1,
                padding: u6,
            }),
            reserved20: [2]u8,
            ///  event generation register
            TIMx_EGR: mmio.Mmio(packed struct(u32) {
                ///  Update generation
                UG: u1,
                padding: u31,
            }),
            reserved32: [8]u8,
            ///  TIM16/TIM17 capture/compare enable register
            TIMx_CCER: mmio.Mmio(packed struct(u16) {
                ///  CC1E
                CC1E: u1,
                ///  CC1P
                CC1P: u1,
                ///  CC1NE
                CC1NE: u1,
                ///  CC1NP
                CC1NP: u1,
                padding: u12,
            }),
            reserved36: [2]u8,
            ///  TIM16/TIM17 counter
            TIMx_CNT: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u16,
                reserved31: u15,
                ///  UIFCPY
                UIFCPY: u1,
            }),
            ///  TIM16/TIM17 prescaler
            TIMx_PSC: mmio.Mmio(packed struct(u16) {
                ///  PSC
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM16/TIM17 auto-reload register
            TIMx_ARR: mmio.Mmio(packed struct(u16) {
                ///  ARR
                ARR: u16,
            }),
            reserved48: [2]u8,
            ///  TIM16/TIM17 repetition counter register
            TIMx_RCR: mmio.Mmio(packed struct(u16) {
                ///  REP
                REP: u8,
                padding: u8,
            }),
            reserved52: [2]u8,
            ///  TIM16/TIM17 capture/compare register 1
            TIMx_CCR1: mmio.Mmio(packed struct(u16) {
                ///  CCR1
                CCR1: u16,
            }),
            reserved68: [14]u8,
            ///  As the BKBID, BKDSRM, BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] bits may be write-locked depending on the LOCK configuration, it may be necessary to configure all of them during the first write access to the TIMx_BDTR register.
            TIMx_BDTR: mmio.Mmio(packed struct(u32) {
                ///  DTG
                DTG: u8,
                ///  LOCK
                LOCK: u2,
                ///  OSSI
                OSSI: u1,
                ///  OSSR
                OSSR: u1,
                ///  BKE
                BKE: u1,
                ///  BKP
                BKP: u1,
                ///  AOE
                AOE: u1,
                ///  MOE
                MOE: u1,
                ///  BKF
                BKF: u4,
                reserved26: u6,
                ///  BKDSRM
                BKDSRM: u1,
                reserved28: u1,
                ///  BKBID
                BKBID: u1,
                padding: u3,
            }),
            ///  TIM16/TIM17 DMA control register
            TIMx_DCR: mmio.Mmio(packed struct(u16) {
                ///  DBA
                DBA: u5,
                reserved8: u3,
                ///  DBL
                DBL: u5,
                padding: u3,
            }),
            reserved76: [2]u8,
            ///  TIM16/TIM17 DMA address for full transfer
            TIMx_DMAR: mmio.Mmio(packed struct(u16) {
                ///  DMAB
                DMAB: u16,
            }),
            reserved96: [18]u8,
            ///  TIM17 alternate function register 1
            TIMx_AF1: mmio.Mmio(packed struct(u32) {
                ///  BKINE
                BKINE: u1,
                reserved8: u7,
                ///  BKDF1BK2E
                BKDF1BK2E: u1,
                ///  BKINP
                BKINP: u1,
                padding: u22,
            }),
            reserved104: [4]u8,
            ///  TIM17 input selection register
            TIMx_TISEL: mmio.Mmio(packed struct(u32) {
                ///  TI1SEL
                TI1SEL: u4,
                padding: u28,
            }),
        };

        ///  TIM15
        pub const TIM15 = extern struct {
            ///  TIM15 control register 1
            TIM15_CR1: mmio.Mmio(packed struct(u16) {
                ///  CEN
                CEN: u1,
                ///  UDIS
                UDIS: u1,
                ///  URS
                URS: u1,
                ///  OPM
                OPM: u1,
                reserved7: u3,
                ///  ARPE
                ARPE: u1,
                ///  CKD
                CKD: u2,
                reserved11: u1,
                ///  UIFREMAP
                UIFREMAP: u1,
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM15 control register 2
            TIM15_CR2: mmio.Mmio(packed struct(u16) {
                ///  CCPC
                CCPC: u1,
                reserved2: u1,
                ///  CCUS
                CCUS: u1,
                ///  CCDS
                CCDS: u1,
                ///  MMS
                MMS: u3,
                ///  TI1S
                TI1S: u1,
                ///  OIS1
                OIS1: u1,
                ///  OIS1N
                OIS1N: u1,
                ///  OIS2
                OIS2: u1,
                padding: u5,
            }),
            reserved8: [2]u8,
            ///  slave mode control register
            TIMx_SMCR: mmio.Mmio(packed struct(u32) {
                ///  Slave mode selection
                SMS: u3,
                reserved4: u1,
                ///  Trigger selection
                TS: u3,
                ///  Master/Slave mode
                MSM: u1,
                reserved16: u8,
                ///  Slave mode selection - bit 3
                SMS_3: u1,
                reserved20: u3,
                ///  Trigger selection
                TS_4_3: u2,
                padding: u10,
            }),
            ///  TIM15 DMA/interrupt enable register
            TIM15_DIER: mmio.Mmio(packed struct(u16) {
                ///  UIE
                UIE: u1,
                ///  CC1IE
                CC1IE: u1,
                ///  CC2IE
                CC2IE: u1,
                reserved5: u2,
                ///  COMIE
                COMIE: u1,
                ///  TIE
                TIE: u1,
                ///  BIE
                BIE: u1,
                ///  UDE
                UDE: u1,
                ///  CC1DE
                CC1DE: u1,
                ///  CC2DE
                CC2DE: u1,
                reserved13: u2,
                ///  COMDE
                COMDE: u1,
                ///  TDE
                TDE: u1,
                padding: u1,
            }),
            reserved16: [2]u8,
            ///  TIM15 status register
            TIM15_SR: mmio.Mmio(packed struct(u16) {
                ///  UIF
                UIF: u1,
                ///  CC1IF
                CC1IF: u1,
                ///  CC2IF
                CC2IF: u1,
                reserved5: u2,
                ///  COMIF
                COMIF: u1,
                ///  TIF
                TIF: u1,
                ///  BIF
                BIF: u1,
                reserved9: u1,
                ///  CC1OF
                CC1OF: u1,
                ///  CC2OF
                CC2OF: u1,
                padding: u5,
            }),
            reserved20: [2]u8,
            ///  event generation register
            TIMx_EGR: mmio.Mmio(packed struct(u32) {
                ///  Update generation
                UG: u1,
                ///  Capture/compare 1 generation
                CC1G: u1,
                ///  Capture/compare 2 generation
                CC2G: u1,
                reserved5: u2,
                ///  COMG
                COMG: u1,
                ///  Trigger generation
                TG: u1,
                ///  BG
                BG: u1,
                padding: u24,
            }),
            ///  capture/compare mode register 1 (output mode)
            TIMx_CCMR1_Output: mmio.Mmio(packed struct(u32) {
                ///  Capture/Compare 1 selection
                CC1S: u2,
                ///  Output compare 1 fast enable
                OC1FE: u1,
                ///  Output compare 1 preload enable
                OC1PE: u1,
                ///  Output compare 1 mode
                OC1M: u3,
                ///  Output compare 1 clear enable
                OC1CE: u1,
                ///  Capture/Compare 2 selection
                CC2S: u2,
                ///  Output compare 2 fast enable
                OC2FE: u1,
                ///  Output compare 2 preload enable
                OC2PE: u1,
                ///  Output compare 2 mode
                OC2M: u3,
                ///  Output compare 2 clear enable
                OC2CE: u1,
                ///  Output Compare 1 mode - bit 3
                OC1M_3: u1,
                reserved24: u7,
                ///  Output Compare 2 mode - bit 3
                OC2M_3: u1,
                padding: u7,
            }),
            reserved32: [4]u8,
            ///  TIM15 capture/compare enable register
            TIM15_CCER: mmio.Mmio(packed struct(u16) {
                ///  CC1E
                CC1E: u1,
                ///  CC1P
                CC1P: u1,
                ///  CC1NE
                CC1NE: u1,
                ///  CC1NP
                CC1NP: u1,
                ///  CC2E
                CC2E: u1,
                ///  CC2P
                CC2P: u1,
                reserved7: u1,
                ///  CC2NP
                CC2NP: u1,
                padding: u8,
            }),
            reserved36: [2]u8,
            ///  TIM15 counter
            TIM15_CNT: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u16,
                reserved31: u15,
                ///  UIFCPY
                UIFCPY: u1,
            }),
            ///  TIM15 prescaler
            TIM15_PSC: mmio.Mmio(packed struct(u16) {
                ///  PSC
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM15 auto-reload register
            TIM15_ARR: mmio.Mmio(packed struct(u16) {
                ///  ARR
                ARR: u16,
            }),
            reserved48: [2]u8,
            ///  TIM15 repetition counter register
            TIM15_RCR: mmio.Mmio(packed struct(u16) {
                ///  REP
                REP: u8,
                padding: u8,
            }),
            reserved52: [2]u8,
            ///  TIM15 capture/compare register 1
            TIM15_CCR1: mmio.Mmio(packed struct(u16) {
                ///  CCR1
                CCR1: u16,
            }),
            reserved56: [2]u8,
            ///  TIM15 capture/compare register 2
            TIM15_CCR2: mmio.Mmio(packed struct(u16) {
                ///  CCR2
                CCR2: u16,
            }),
            reserved68: [10]u8,
            ///  As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
            TIMx_BDTR: mmio.Mmio(packed struct(u32) {
                ///  DTG
                DTG: u8,
                ///  LOCK
                LOCK: u2,
                ///  OSSI
                OSSI: u1,
                ///  OSSR
                OSSR: u1,
                ///  BKE
                BKE: u1,
                ///  BKP
                BKP: u1,
                ///  AOE
                AOE: u1,
                ///  MOE
                MOE: u1,
                ///  BKF
                BKF: u4,
                reserved26: u6,
                ///  BKDSRM
                BKDSRM: u1,
                reserved28: u1,
                ///  BKBID
                BKBID: u1,
                padding: u3,
            }),
            ///  TIM15 DMA control register
            TIM15_DCR: mmio.Mmio(packed struct(u16) {
                ///  DBA
                DBA: u5,
                reserved8: u3,
                ///  DBL
                DBL: u5,
                padding: u3,
            }),
            reserved76: [2]u8,
            ///  TIM15 DMA address for full transfer
            TIM15_DMAR: mmio.Mmio(packed struct(u16) {
                ///  DMAB
                DMAB: u16,
            }),
            reserved96: [18]u8,
            ///  TIM15 alternate register 1
            TIM15_AF1: mmio.Mmio(packed struct(u32) {
                ///  BKINE
                BKINE: u1,
                reserved8: u7,
                ///  BKDF1BK0E
                BKDF1BK0E: u1,
                ///  BKINP
                BKINP: u1,
                padding: u22,
            }),
            reserved104: [4]u8,
            ///  TIM15 input selection register
            TIM15_TISEL: mmio.Mmio(packed struct(u32) {
                ///  TI1SEL
                TI1SEL: u4,
                reserved8: u4,
                ///  TI2SEL
                TI2SEL: u4,
                padding: u20,
            }),
        };

        ///  TIM14
        pub const TIM14 = extern struct {
            ///  TIM14 control register 1
            TIM14_CR1: mmio.Mmio(packed struct(u16) {
                ///  CEN
                CEN: u1,
                ///  UDIS
                UDIS: u1,
                ///  URS
                URS: u1,
                ///  OPM
                OPM: u1,
                reserved7: u3,
                ///  ARPE
                ARPE: u1,
                ///  CKD
                CKD: u2,
                reserved11: u1,
                ///  UIFREMAP
                UIFREMAP: u1,
                padding: u4,
            }),
            reserved12: [10]u8,
            ///  TIM14 Interrupt enable register
            TIM14_DIER: mmio.Mmio(packed struct(u16) {
                ///  UIE
                UIE: u1,
                ///  CC1IE
                CC1IE: u1,
                padding: u14,
            }),
            reserved16: [2]u8,
            ///  TIM14 status register
            TIM14_SR: mmio.Mmio(packed struct(u16) {
                ///  UIF
                UIF: u1,
                ///  CC1IF
                CC1IF: u1,
                reserved9: u7,
                ///  CC1OF
                CC1OF: u1,
                padding: u6,
            }),
            reserved20: [2]u8,
            ///  TIM14 event generation register
            TIM14_EGR: mmio.Mmio(packed struct(u16) {
                ///  UG
                UG: u1,
                ///  CC1G
                CC1G: u1,
                padding: u14,
            }),
            reserved24: [2]u8,
            ///  The channels can be used in input (capture mode) or in output (compare mode). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function in input and in output mode. For a given bit, OCxx describes its function when the channel is configured in output, ICxx describes its function when the channel is configured in input. So one must take care that the same bit can have a different meaning for the input stage and for the output stage. Output compare mode
            TIM14_CCMR1: mmio.Mmio(packed struct(u32) {
                ///  CC1S
                CC1S: u2,
                ///  OC1FE
                OC1FE: u1,
                ///  OC1PE
                OC1PE: u1,
                ///  OC1M
                OC1M: u3,
                reserved16: u9,
                ///  OC1M3
                OC1M3: u1,
                padding: u15,
            }),
            reserved32: [4]u8,
            ///  TIM14 capture/compare enable register
            TIM14_CCER: mmio.Mmio(packed struct(u16) {
                ///  CC1E
                CC1E: u1,
                ///  CC1P
                CC1P: u1,
                reserved3: u1,
                ///  CC1NP
                CC1NP: u1,
                padding: u12,
            }),
            reserved36: [2]u8,
            ///  TIM14 counter
            TIM14_CNT: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u16,
                reserved31: u15,
                ///  UIFCPY
                UIFCPY: u1,
            }),
            ///  TIM14 prescaler
            TIM14_PSC: mmio.Mmio(packed struct(u16) {
                ///  PSC
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM14 auto-reload register
            TIM14_ARR: mmio.Mmio(packed struct(u16) {
                ///  ARR
                ARR: u16,
            }),
            reserved52: [6]u8,
            ///  TIM14 capture/compare register 1
            TIM14_CCR1: mmio.Mmio(packed struct(u16) {
                ///  CCR1
                CCR1: u16,
            }),
            reserved104: [50]u8,
            ///  TIM14 timer input selection register
            TIM14_TISEL: mmio.Mmio(packed struct(u16) {
                ///  TI1SEL
                TI1SEL: u4,
                padding: u12,
            }),
        };

        ///  LTDC
        pub const LTDC = extern struct {
            ///  LTDC identification register
            LTDC_IDR: mmio.Mmio(packed struct(u32) {
                ///  REV
                REV: u8,
                ///  MINVER
                MINVER: u8,
                ///  MAJVER
                MAJVER: u8,
                padding: u8,
            }),
            ///  LDTC layer count register
            LTDC_LCR: mmio.Mmio(packed struct(u32) {
                ///  LNBR
                LNBR: u8,
                padding: u24,
            }),
            ///  This register defines the number of horizontal synchronization pixels minus 1 and the number of vertical synchronization lines minus 1. Refer to Figure274 and Section36.4: LTDC programmable parameters for an example of configuration.
            LTDC_SSCR: mmio.Mmio(packed struct(u32) {
                ///  VSH
                VSH: u12,
                reserved16: u4,
                ///  HSW
                HSW: u12,
                padding: u4,
            }),
            ///  This register defines the accumulated number of horizontal synchronization and back porch pixels minus 1 (HSYNCwidth+HBP-1) and the accumulated number of vertical synchronization and back porch lines minus 1 (VSYNCheight+VBP-1). Refer to Figure274 and Section36.4: LTDC programmable parameters for an example of configuration.
            LTDC_BPCR: mmio.Mmio(packed struct(u32) {
                ///  AVBP
                AVBP: u12,
                reserved16: u4,
                ///  AHBP
                AHBP: u12,
                padding: u4,
            }),
            ///  This register defines the accumulated number of horizontal synchronization, back porch and active pixels minus 1 (HSYNC width+HBP+activewidth-1) and the accumulated number of vertical synchronization, back porch lines and active lines minus 1 (VSYNCheight+BVBP+activeheight-1). Refer to Figure274 and Section36.4: LTDC programmable parameters for an example of configuration.
            LTDC_AWCR: mmio.Mmio(packed struct(u32) {
                ///  AAH
                AAH: u12,
                reserved16: u4,
                ///  AAW
                AAW: u12,
                padding: u4,
            }),
            ///  This register defines the accumulated number of horizontal synchronization, back porch, active and front porch pixels minus 1 (HSYNCwidth+HBP+activewidth+HFP-1) and the accumulated number of vertical synchronization, back porch lines, active and front lines minus 1 (VSYNCheight+BVBP+activeheight+VFP-1). Refer to Figure274 and Section36.4: LTDC programmable parameters for an example of configuration.
            LTDC_TWCR: mmio.Mmio(packed struct(u32) {
                ///  TOTALH
                TOTALH: u12,
                reserved16: u4,
                ///  TOTALW
                TOTALW: u12,
                padding: u4,
            }),
            ///  This register defines the global configuration of the LCD-TFT controller.
            LTDC_GCR: mmio.Mmio(packed struct(u32) {
                ///  LTDCEN
                LTDCEN: u1,
                reserved4: u3,
                ///  DBW
                DBW: u3,
                reserved8: u1,
                ///  DGW
                DGW: u3,
                reserved12: u1,
                ///  DRW
                DRW: u3,
                reserved16: u1,
                ///  DEN
                DEN: u1,
                reserved28: u11,
                ///  PCPOL
                PCPOL: u1,
                ///  DEPOL
                DEPOL: u1,
                ///  VSPOL
                VSPOL: u1,
                ///  HSPOL
                HSPOL: u1,
            }),
            ///  LTDC global configuration 1 register
            LTDC_GC1R: mmio.Mmio(packed struct(u32) {
                ///  WBCH
                WBCH: u4,
                ///  WGCH
                WGCH: u4,
                ///  WRCH
                WRCH: u4,
                ///  PRBEN
                PRBEN: u1,
                reserved14: u1,
                ///  DT
                DT: u2,
                reserved17: u1,
                ///  GCT
                GCT: u3,
                reserved21: u1,
                ///  SHREN
                SHREN: u1,
                ///  BCP
                BCP: u1,
                ///  BBEN
                BBEN: u1,
                ///  LNIP
                LNIP: u1,
                ///  TP
                TP: u1,
                ///  IPP
                IPP: u1,
                ///  SPP
                SPP: u1,
                ///  DWP
                DWP: u1,
                ///  STREN
                STREN: u1,
                reserved31: u1,
                ///  BMEN
                BMEN: u1,
            }),
            ///  LTDC global configuration 2 register
            LTDC_GC2R: mmio.Mmio(packed struct(u32) {
                ///  EDCEN
                EDCEN: u1,
                ///  STSAEN
                STSAEN: u1,
                ///  DVAEN
                DVAEN: u1,
                ///  DPAEN
                DPAEN: u1,
                ///  BW
                BW: u3,
                ///  EDCA
                EDCA: u1,
                padding: u24,
            }),
            ///  This register allows to reload either immediately or during the vertical blanking period, the shadow registers values to the active registers. The shadow registers are all Layer1 and Layer2 registers except the LTDC_L1CLUTWR and the LTDC_L2CLUTWR.
            LTDC_SRCR: mmio.Mmio(packed struct(u32) {
                ///  IMR
                IMR: u1,
                ///  VBR
                VBR: u1,
                padding: u30,
            }),
            reserved44: [4]u8,
            ///  This register defines the background color (RGB888).
            LTDC_BCCR: mmio.Mmio(packed struct(u32) {
                ///  BCBLUE
                BCBLUE: u8,
                ///  BCGREEN
                BCGREEN: u8,
                ///  BCRED
                BCRED: u8,
                padding: u8,
            }),
            reserved52: [4]u8,
            ///  This register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
            LTDC_IER: mmio.Mmio(packed struct(u32) {
                ///  LIE
                LIE: u1,
                ///  FUIE
                FUIE: u1,
                ///  TERRIE
                TERRIE: u1,
                ///  RRIE
                RRIE: u1,
                padding: u28,
            }),
            ///  This register returns the interrupt status flag.
            LTDC_ISR: mmio.Mmio(packed struct(u32) {
                ///  LIF
                LIF: u1,
                ///  FUIF
                FUIF: u1,
                ///  TERRIF
                TERRIF: u1,
                ///  RRIF
                RRIF: u1,
                padding: u28,
            }),
            ///  LTDC Interrupt Clear Register
            LTDC_ICR: mmio.Mmio(packed struct(u32) {
                ///  CLIF
                CLIF: u1,
                ///  CFUIF
                CFUIF: u1,
                ///  CTERRIF
                CTERRIF: u1,
                ///  CRRIF
                CRRIF: u1,
                padding: u28,
            }),
            ///  This register defines the position of the line interrupt. The line value to be programmed depends on the timings parameters. Refer to Figure274.
            LTDC_LIPCR: mmio.Mmio(packed struct(u32) {
                ///  LIPOS
                LIPOS: u12,
                padding: u20,
            }),
            ///  LTDC current position status register
            LTDC_CPSR: mmio.Mmio(packed struct(u32) {
                ///  CYPOS
                CYPOS: u16,
                ///  CXPOS
                CXPOS: u16,
            }),
            ///  This register returns the status of the current display phase which is controlled by the HSYNC, VSYNC, and horizontal/vertical DE signals. Example: if the current display phase is the vertical synchronization, the VSYNCS bit is set (active high). If the current display phase is the horizontal synchronization, the HSYNCS bit is active high.
            LTDC_CDSR: mmio.Mmio(packed struct(u32) {
                ///  VDES
                VDES: u1,
                ///  HDES
                HDES: u1,
                ///  VSYNCS
                VSYNCS: u1,
                ///  HSYNCS
                HSYNCS: u1,
                padding: u28,
            }),
            reserved132: [56]u8,
            ///  LTDC layer 1 control register
            LTDC_L1CR: mmio.Mmio(packed struct(u32) {
                ///  LEN
                LEN: u1,
                ///  COLKEN
                COLKEN: u1,
                reserved4: u2,
                ///  CLUTEN
                CLUTEN: u1,
                padding: u27,
            }),
            ///  This register defines the horizontal position (first and last pixel) of the layer 1 or 2 window. The first visible pixel of a line is the programmed value of AHBP[11:0] bits + 1 in the LTDC_BPCR register. The last visible pixel of a line is the programmed value of AAW[11:0] bits in the LTDC_AWCR register.
            LTDC_L1WHPCR: mmio.Mmio(packed struct(u32) {
                ///  WHSTPOS
                WHSTPOS: u12,
                reserved16: u4,
                ///  WHSPPOS
                WHSPPOS: u12,
                padding: u4,
            }),
            ///  This register defines the vertical position (first and last line) of the layer1 or 2 window. The first visible line of a frame is the programmed value of AVBP[11:0] bits + 1 in the register LTDC_BPCR register. The last visible line of a frame is the programmed value of AAH[11:0] bits in the LTDC_AWCR register.
            LTDC_L1WVPCR: mmio.Mmio(packed struct(u32) {
                ///  WVSTPOS
                WVSTPOS: u12,
                reserved16: u4,
                ///  WVSPPOS
                WVSPPOS: u12,
                padding: u4,
            }),
            ///  This register defines the color key value (RGB), that is used by the color keying.
            LTDC_L1CKCR: mmio.Mmio(packed struct(u32) {
                ///  CKBLUE
                CKBLUE: u8,
                ///  CKGREEN
                CKGREEN: u8,
                ///  CKRED
                CKRED: u8,
                padding: u8,
            }),
            ///  This register defines the pixel format that is used for the stored data in the frame buffer of a layer. The pixel data is read from the frame buffer and then transformed to the internal format 8888 (ARGB).
            LTDC_L1PFCR: mmio.Mmio(packed struct(u32) {
                ///  PF
                PF: u3,
                padding: u29,
            }),
            ///  This register defines the constant alpha value (divided by 255 by hardware), that is used in the alpha blending. Refer to LTDC_LxBFCR register.
            LTDC_L1CACR: mmio.Mmio(packed struct(u32) {
                ///  CONSTA
                CONSTA: u8,
                padding: u24,
            }),
            ///  This register defines the default color of a layer in the format ARGB. The default color is used outside the defined layer window or when a layer is disabled. The reset value of 0x00000000 defines a transparent black color.
            LTDC_L1DCCR: mmio.Mmio(packed struct(u32) {
                ///  DCBLUE
                DCBLUE: u8,
                ///  DCGREEN
                DCGREEN: u8,
                ///  DCRED
                DCRED: u8,
                ///  DCALPHA
                DCALPHA: u8,
            }),
            ///  This register defines the blending factors F1 and F2. The general blending formula is: BC = BF1 x C + BF2 x Cs BC = blended color BF1 = blend factor 1 C = current layer color BF2 = blend factor 2 Cs = subjacent layers blended color
            LTDC_L1BFCR: mmio.Mmio(packed struct(u32) {
                ///  BF2
                BF2: u3,
                reserved8: u5,
                ///  BF1
                BF1: u3,
                padding: u21,
            }),
            reserved172: [8]u8,
            ///  This register defines the color frame buffer start address which has to point to the address where the pixel data of the top left pixel of a layer is stored in the frame buffer.
            LTDC_L1CFBAR: mmio.Mmio(packed struct(u32) {
                ///  CFBADD
                CFBADD: u32,
            }),
            ///  This register defines the color frame buffer line length and pitch.
            LTDC_L1CFBLR: mmio.Mmio(packed struct(u32) {
                ///  CFBLL
                CFBLL: u14,
                reserved16: u2,
                ///  CFBP
                CFBP: u14,
                padding: u2,
            }),
            ///  This register defines the number of lines in the color frame buffer.
            LTDC_L1CFBLNR: mmio.Mmio(packed struct(u32) {
                ///  CFBLNBR
                CFBLNBR: u12,
                padding: u20,
            }),
            reserved196: [12]u8,
            ///  This register defines the CLUT address and the RGB value.
            LTDC_L1CLUTWR: mmio.Mmio(packed struct(u32) {
                ///  BLUE
                BLUE: u8,
                ///  GREEN
                GREEN: u8,
                ///  RED
                RED: u8,
                ///  CLUTADD
                CLUTADD: u8,
            }),
            reserved260: [60]u8,
            ///  LTDC layer 2 control register
            LTDC_L2CR: mmio.Mmio(packed struct(u32) {
                ///  LEN
                LEN: u1,
                ///  COLKEN
                COLKEN: u1,
                reserved4: u2,
                ///  CLUTEN
                CLUTEN: u1,
                padding: u27,
            }),
            ///  This register defines the horizontal position (first and last pixel) of the layer 1 or 2 window. The first visible pixel of a line is the programmed value of AHBP[11:0] bits + 1 in the LTDC_BPCR register. The last visible pixel of a line is the programmed value of AAW[11:0] bits in the LTDC_AWCR register.
            LTDC_L2WHPCR: mmio.Mmio(packed struct(u32) {
                ///  WHSTPOS
                WHSTPOS: u12,
                reserved16: u4,
                ///  WHSPPOS
                WHSPPOS: u12,
                padding: u4,
            }),
            ///  This register defines the vertical position (first and last line) of the layer1 or 2 window. The first visible line of a frame is the programmed value of AVBP[11:0] bits + 1 in the register LTDC_BPCR register. The last visible line of a frame is the programmed value of AAH[11:0] bits in the LTDC_AWCR register.
            LTDC_L2WVPCR: mmio.Mmio(packed struct(u32) {
                ///  WVSTPOS
                WVSTPOS: u12,
                reserved16: u4,
                ///  WVSPPOS
                WVSPPOS: u12,
                padding: u4,
            }),
            ///  This register defines the color key value (RGB), that is used by the color keying.
            LTDC_L2CKCR: mmio.Mmio(packed struct(u32) {
                ///  CKBLUE
                CKBLUE: u8,
                ///  CKGREEN
                CKGREEN: u8,
                ///  CKRED
                CKRED: u8,
                padding: u8,
            }),
            ///  This register defines the pixel format that is used for the stored data in the frame buffer of a layer. The pixel data is read from the frame buffer and then transformed to the internal format 8888 (ARGB).
            LTDC_L2PFCR: mmio.Mmio(packed struct(u32) {
                ///  PF
                PF: u3,
                padding: u29,
            }),
            ///  This register defines the constant alpha value (divided by 255 by hardware), that is used in the alpha blending. Refer to LTDC_LxBFCR register.
            LTDC_L2CACR: mmio.Mmio(packed struct(u32) {
                ///  CONSTA
                CONSTA: u8,
                padding: u24,
            }),
            ///  This register defines the default color of a layer in the format ARGB. The default color is used outside the defined layer window or when a layer is disabled. The reset value of 0x00000000 defines a transparent black color.
            LTDC_L2DCCR: mmio.Mmio(packed struct(u32) {
                ///  DCBLUE
                DCBLUE: u8,
                ///  DCGREEN
                DCGREEN: u8,
                ///  DCRED
                DCRED: u8,
                ///  DCALPHA
                DCALPHA: u8,
            }),
            ///  This register defines the blending factors F1 and F2. The general blending formula is: BC = BF1 x C + BF2 x Cs BC = blended color BF1 = blend factor 1 C = current layer color BF2 = blend factor 2 Cs = subjacent layers blended color
            LTDC_L2BFCR: mmio.Mmio(packed struct(u32) {
                ///  BF2
                BF2: u3,
                reserved8: u5,
                ///  BF1
                BF1: u3,
                padding: u21,
            }),
            reserved300: [8]u8,
            ///  This register defines the color frame buffer start address which has to point to the address where the pixel data of the top left pixel of a layer is stored in the frame buffer.
            LTDC_L2CFBAR: mmio.Mmio(packed struct(u32) {
                ///  CFBADD
                CFBADD: u32,
            }),
            ///  This register defines the color frame buffer line length and pitch.
            LTDC_L2CFBLR: mmio.Mmio(packed struct(u32) {
                ///  CFBLL
                CFBLL: u14,
                reserved16: u2,
                ///  CFBP
                CFBP: u14,
                padding: u2,
            }),
            ///  This register defines the number of lines in the color frame buffer.
            LTDC_L2CFBLNR: mmio.Mmio(packed struct(u32) {
                ///  CFBLNBR
                CFBLNBR: u12,
                padding: u20,
            }),
            reserved324: [12]u8,
            ///  This register defines the CLUT address and the RGB value.
            LTDC_L2CLUTWR: mmio.Mmio(packed struct(u32) {
                ///  BLUE
                BLUE: u8,
                ///  GREEN
                GREEN: u8,
                ///  RED
                RED: u8,
                ///  CLUTADD
                CLUTADD: u8,
            }),
        };

        ///  MDIOS
        pub const MDIOS = extern struct {
            ///  MDIOS configuration register
            MDIOS_CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  WRIE
                WRIE: u1,
                ///  RDIE
                RDIE: u1,
                ///  EIE
                EIE: u1,
                reserved7: u3,
                ///  DPC
                DPC: u1,
                ///  PORT_ADDRESS
                PORT_ADDRESS: u5,
                padding: u19,
            }),
            ///  MDIOS write flag register
            MDIOS_WRFR: mmio.Mmio(packed struct(u32) {
                ///  WRF
                WRF: u32,
            }),
            ///  MDIOS clear write flag register
            MDIOS_CWRFR: mmio.Mmio(packed struct(u32) {
                ///  CWRF
                CWRF: u32,
            }),
            ///  MDIOS read flag register
            MDIOS_RDFR: mmio.Mmio(packed struct(u32) {
                ///  RDF
                RDF: u32,
            }),
            ///  MDIOS clear read flag register
            MDIOS_CRDFR: mmio.Mmio(packed struct(u32) {
                ///  CRDF
                CRDF: u32,
            }),
            ///  MDIOS status register
            MDIOS_SR: mmio.Mmio(packed struct(u32) {
                ///  PERF
                PERF: u1,
                ///  SERF
                SERF: u1,
                ///  TERF
                TERF: u1,
                padding: u29,
            }),
            ///  MDIOS clear flag register
            MDIOS_CLRFR: mmio.Mmio(packed struct(u32) {
                ///  CPERF
                CPERF: u1,
                ///  CSERF
                CSERF: u1,
                ///  CTERF
                CTERF: u1,
                padding: u29,
            }),
            reserved256: [228]u8,
            ///  MDIOS input data register
            MDIOS_DINR0: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR1: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR2: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR3: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR4: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR5: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR6: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR7: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR8: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR9: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR10: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR11: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR12: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR13: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR14: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR15: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR16: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR17: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR18: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR19: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR20: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR21: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR22: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR23: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR24: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR25: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR26: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR27: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR28: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR29: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR30: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DINR31: mmio.Mmio(packed struct(u32) {
                ///  DIN
                DIN: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DOUTR0: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS input data register
            MDIOS_DOUTR1: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR2: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR3: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR4: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR5: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR6: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR7: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR8: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR9: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR10: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR11: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR12: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR13: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR14: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR15: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR16: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR17: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR18: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR19: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR20: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR21: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR22: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR23: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR24: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR25: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR26: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR27: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR28: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR29: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR30: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            ///  MDIOS output data register
            MDIOS_DOUTR31: mmio.Mmio(packed struct(u32) {
                ///  DOUT
                DOUT: u16,
                padding: u16,
            }),
            reserved1008: [496]u8,
            ///  MDIOS HW configuration register
            MDIOS_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  NBREG
                NBREG: u8,
                padding: u24,
            }),
            ///  MDIOS version register
            MDIOS_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  MDIOS identification register
            MDIOS_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  MDIOS size identification register
            MDIOS_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  MDMA1
        pub const MDMA = extern struct {
            ///  MDMA global interrupt/status register
            MDMA_GISR0: mmio.Mmio(packed struct(u32) {
                ///  GIF0
                GIF0: u1,
                ///  GIF1
                GIF1: u1,
                ///  GIF2
                GIF2: u1,
                ///  GIF3
                GIF3: u1,
                ///  GIF4
                GIF4: u1,
                ///  GIF5
                GIF5: u1,
                ///  GIF6
                GIF6: u1,
                ///  GIF7
                GIF7: u1,
                ///  GIF8
                GIF8: u1,
                ///  GIF9
                GIF9: u1,
                ///  GIF10
                GIF10: u1,
                ///  GIF11
                GIF11: u1,
                ///  GIF12
                GIF12: u1,
                ///  GIF13
                GIF13: u1,
                ///  GIF14
                GIF14: u1,
                ///  GIF15
                GIF15: u1,
                ///  GIF16
                GIF16: u1,
                ///  GIF17
                GIF17: u1,
                ///  GIF18
                GIF18: u1,
                ///  GIF19
                GIF19: u1,
                ///  GIF20
                GIF20: u1,
                ///  GIF21
                GIF21: u1,
                ///  GIF22
                GIF22: u1,
                ///  GIF23
                GIF23: u1,
                ///  GIF24
                GIF24: u1,
                ///  GIF25
                GIF25: u1,
                ///  GIF26
                GIF26: u1,
                ///  GIF27
                GIF27: u1,
                ///  GIF28
                GIF28: u1,
                ///  GIF29
                GIF29: u1,
                ///  GIF30
                GIF30: u1,
                ///  GIF31
                GIF31: u1,
            }),
            reserved8: [4]u8,
            ///  MDMA secure global interrupt/status register
            MDMA_SGISR0: mmio.Mmio(packed struct(u32) {
                ///  GIF0
                GIF0: u1,
                ///  GIF1
                GIF1: u1,
                ///  GIF2
                GIF2: u1,
                ///  GIF3
                GIF3: u1,
                ///  GIF4
                GIF4: u1,
                ///  GIF5
                GIF5: u1,
                ///  GIF6
                GIF6: u1,
                ///  GIF7
                GIF7: u1,
                ///  GIF8
                GIF8: u1,
                ///  GIF9
                GIF9: u1,
                ///  GIF10
                GIF10: u1,
                ///  GIF11
                GIF11: u1,
                ///  GIF12
                GIF12: u1,
                ///  GIF13
                GIF13: u1,
                ///  GIF14
                GIF14: u1,
                ///  GIF15
                GIF15: u1,
                ///  GIF16
                GIF16: u1,
                ///  GIF17
                GIF17: u1,
                ///  GIF18
                GIF18: u1,
                ///  GIF19
                GIF19: u1,
                ///  GIF20
                GIF20: u1,
                ///  GIF21
                GIF21: u1,
                ///  GIF22
                GIF22: u1,
                ///  GIF23
                GIF23: u1,
                ///  GIF24
                GIF24: u1,
                ///  GIF25
                GIF25: u1,
                ///  GIF26
                GIF26: u1,
                ///  GIF27
                GIF27: u1,
                ///  GIF28
                GIF28: u1,
                ///  GIF29
                GIF29: u1,
                ///  GIF30
                GIF30: u1,
                ///  GIF31
                GIF31: u1,
            }),
            reserved64: [52]u8,
            ///  MDMA channel 0 interrupt/status register
            MDMA_C0ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 0 interrupt flag clear register
            MDMA_C0IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 0 error status register
            MDMA_C0ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C0CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C0TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C0BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C0SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C0DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C0BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C0LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C0TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved112: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C0MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C0MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved128: [8]u8,
            ///  MDMA channel 1 interrupt/status register
            MDMA_C1ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 1 interrupt flag clear register
            MDMA_C1IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 1 error status register
            MDMA_C1ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C1CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C1TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C1BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C1SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C1DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C1BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C1LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C1TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved176: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C1MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C1MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved192: [8]u8,
            ///  MDMA channel 2 interrupt/status register
            MDMA_C2ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 2 interrupt flag clear register
            MDMA_C2IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 2 error status register
            MDMA_C2ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C2CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C2TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C2BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C2SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C2DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C2BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C2LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C2TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved240: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C2MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C2MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved256: [8]u8,
            ///  MDMA channel 3 interrupt/status register
            MDMA_C3ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 3 interrupt flag clear register
            MDMA_C3IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 3 error status register
            MDMA_C3ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C3CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C3TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C3BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C3SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C3DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C3BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C3LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C3TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved304: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C3MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C3MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved320: [8]u8,
            ///  MDMA channel 4 interrupt/status register
            MDMA_C4ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 4 interrupt flag clear register
            MDMA_C4IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 4 error status register
            MDMA_C4ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C4CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C4TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C4BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C4SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C4DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C4BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C4LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C4TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved368: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C4MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C4MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved384: [8]u8,
            ///  MDMA channel 5 interrupt/status register
            MDMA_C5ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 5 interrupt flag clear register
            MDMA_C5IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 5 error status register
            MDMA_C5ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C5CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C5TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C5BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C5SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C5DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C5BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C5LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C5TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved432: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C5MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C5MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved448: [8]u8,
            ///  MDMA channel 6 interrupt/status register
            MDMA_C6ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 6 interrupt flag clear register
            MDMA_C6IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 6 error status register
            MDMA_C6ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C6CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C6TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C6BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C6SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C6DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C6BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C6LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C6TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved496: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C6MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C6MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved512: [8]u8,
            ///  MDMA channel 7 interrupt/status register
            MDMA_C7ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 7 interrupt flag clear register
            MDMA_C7IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 7 error status register
            MDMA_C7ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C7CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C7TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C7BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C7SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C7DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C7BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C7LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C7TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved560: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C7MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C7MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved576: [8]u8,
            ///  MDMA channel 8 interrupt/status register
            MDMA_C8ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 8 interrupt flag clear register
            MDMA_C8IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 8 error status register
            MDMA_C8ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C8CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C8TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C8BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C8SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C8DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C8BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C8LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C8TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved624: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C8MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C8MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved640: [8]u8,
            ///  MDMA channel 9 interrupt/status register
            MDMA_C9ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 9 interrupt flag clear register
            MDMA_C9IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 9 error status register
            MDMA_C9ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C9CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C9TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C9BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C9SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C9DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C9BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C9LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C9TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved688: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C9MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C9MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved704: [8]u8,
            ///  MDMA channel 10 interrupt/status register
            MDMA_C10ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 10 interrupt flag clear register
            MDMA_C10IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 10 error status register
            MDMA_C10ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C10CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C10TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C10BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C10SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C10DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C10BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C10LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C10TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved752: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C10MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C10MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved768: [8]u8,
            ///  MDMA channel 11 interrupt/status register
            MDMA_C11ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 11 interrupt flag clear register
            MDMA_C11IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 11 error status register
            MDMA_C11ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C11CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C11TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C11BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C11SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C11DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C11BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C11LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C11TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved816: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C11MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C11MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved832: [8]u8,
            ///  MDMA channel 12 interrupt/status register
            MDMA_C12ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 12 interrupt flag clear register
            MDMA_C12IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 12 error status register
            MDMA_C12ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C12CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C12TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C12BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C12SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C12DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C12BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C12LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C12TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved880: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C12MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C12MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved896: [8]u8,
            ///  MDMA channel 13 interrupt/status register
            MDMA_C13ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 13 interrupt flag clear register
            MDMA_C13IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 13 error status register
            MDMA_C13ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C13CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C13TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C13BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C13SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C13DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C13BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C13LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C13TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved944: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C13MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C13MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved960: [8]u8,
            ///  MDMA channel 14 interrupt/status register
            MDMA_C14ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 14 interrupt flag clear register
            MDMA_C14IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 14 error status register
            MDMA_C14ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C14CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C14TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C14BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C14SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C14DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C14BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C14LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C14TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved1008: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C14MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C14MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved1024: [8]u8,
            ///  MDMA channel 15 interrupt/status register
            MDMA_C15ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 15 interrupt flag clear register
            MDMA_C15IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 15 error status register
            MDMA_C15ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C15CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C15TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C15BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C15SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C15DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C15BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C15LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C15TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved1072: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C15MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C15MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved1088: [8]u8,
            ///  MDMA channel 16 interrupt/status register
            MDMA_C16ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 16 interrupt flag clear register
            MDMA_C16IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 16 error status register
            MDMA_C16ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C16CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C16TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C16BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C16SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C16DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C16BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C16LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C16TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved1136: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C16MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C16MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved1152: [8]u8,
            ///  MDMA channel 17 interrupt/status register
            MDMA_C17ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 17 interrupt flag clear register
            MDMA_C17IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 17 error status register
            MDMA_C17ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C17CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C17TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C17BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C17SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C17DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C17BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C17LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C17TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved1200: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C17MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C17MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved1216: [8]u8,
            ///  MDMA channel 18 interrupt/status register
            MDMA_C18ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 18 interrupt flag clear register
            MDMA_C18IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 18 error status register
            MDMA_C18ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C18CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C18TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C18BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C18SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C18DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C18BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C18LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C18TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved1264: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C18MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C18MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved1280: [8]u8,
            ///  MDMA channel 19 interrupt/status register
            MDMA_C19ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 19 interrupt flag clear register
            MDMA_C19IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 19 error status register
            MDMA_C19ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C19CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C19TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C19BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C19SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C19DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C19BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C19LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C19TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved1328: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C19MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C19MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved1344: [8]u8,
            ///  MDMA channel 20 interrupt/status register
            MDMA_C20ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 20 interrupt flag clear register
            MDMA_C20IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 20 error status register
            MDMA_C20ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C20CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C20TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C20BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C20SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C20DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C20BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C20LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C20TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved1392: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C20MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C20MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved1408: [8]u8,
            ///  MDMA channel 21 interrupt/status register
            MDMA_C21ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 21 interrupt flag clear register
            MDMA_C21IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 21 error status register
            MDMA_C21ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C21CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C21TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C21BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C21SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C21DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C21BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C21LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C21TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved1456: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C21MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C21MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved1472: [8]u8,
            ///  MDMA channel 22 interrupt/status register
            MDMA_C22ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 22 interrupt flag clear register
            MDMA_C22IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 22 error status register
            MDMA_C22ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C22CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C22TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C22BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C22SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C22DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C22BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C22LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C22TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved1520: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C22MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C22MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved1536: [8]u8,
            ///  MDMA channel 23 interrupt/status register
            MDMA_C23ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 23 interrupt flag clear register
            MDMA_C23IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 23 error status register
            MDMA_C23ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C23CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C23TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C23BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C23SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C23DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C23BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C23LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C23TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved1584: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C23MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C23MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved1600: [8]u8,
            ///  MDMA channel 24 interrupt/status register
            MDMA_C24ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 24 interrupt flag clear register
            MDMA_C24IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 24 error status register
            MDMA_C24ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C24CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C24TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C24BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C24SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C24DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C24BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C24LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C24TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved1648: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C24MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C24MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved1664: [8]u8,
            ///  MDMA channel 25 interrupt/status register
            MDMA_C25ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 25 interrupt flag clear register
            MDMA_C25IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 25 error status register
            MDMA_C25ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C25CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C25TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C25BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C25SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C25DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C25BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C25LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C25TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved1712: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C25MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C25MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved1728: [8]u8,
            ///  MDMA channel 26 interrupt/status register
            MDMA_C26ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 26 interrupt flag clear register
            MDMA_C26IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 26 error status register
            MDMA_C26ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C26CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C26TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C26BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C26SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C26DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C26BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C26LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C26TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved1776: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C26MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C26MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved1792: [8]u8,
            ///  MDMA channel 27 interrupt/status register
            MDMA_C27ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 27 interrupt flag clear register
            MDMA_C27IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 27 error status register
            MDMA_C27ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C27CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C27TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C27BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C27SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C27DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C27BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C27LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C27TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved1840: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C27MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C27MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved1856: [8]u8,
            ///  MDMA channel 28 interrupt/status register
            MDMA_C28ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 28 interrupt flag clear register
            MDMA_C28IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 28 error status register
            MDMA_C28ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C28CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C28TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C28BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C28SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C28DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C28BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C28LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C28TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved1904: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C28MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C28MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved1920: [8]u8,
            ///  MDMA channel 29 interrupt/status register
            MDMA_C29ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 29 interrupt flag clear register
            MDMA_C29IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 29 error status register
            MDMA_C29ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C29CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C29TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C29BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C29SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C29DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C29BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C29LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C29TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved1968: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C29MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C29MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved1984: [8]u8,
            ///  MDMA channel 30 interrupt/status register
            MDMA_C30ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 30 interrupt flag clear register
            MDMA_C30IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 30 error status register
            MDMA_C30ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C30CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C30TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C30BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C30SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C30DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C30BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C30LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C30TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved2032: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C30MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C30MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
            reserved2048: [8]u8,
            ///  MDMA channel 31 interrupt/status register
            MDMA_C31ISR: mmio.Mmio(packed struct(u32) {
                ///  TEIF
                TEIF: u1,
                ///  CTCIF
                CTCIF: u1,
                ///  BRTIF
                BRTIF: u1,
                ///  BTIF
                BTIF: u1,
                ///  TCIF
                TCIF: u1,
                reserved16: u11,
                ///  CRQA
                CRQA: u1,
                padding: u15,
            }),
            ///  MDMA channel 31 interrupt flag clear register
            MDMA_C31IFCR: mmio.Mmio(packed struct(u32) {
                ///  CTEIF
                CTEIF: u1,
                ///  CCTCIF
                CCTCIF: u1,
                ///  CBRTIF
                CBRTIF: u1,
                ///  CBTIF
                CBTIF: u1,
                ///  CLTCIF
                CLTCIF: u1,
                padding: u27,
            }),
            ///  MDMA channel 31 error status register
            MDMA_C31ESR: mmio.Mmio(packed struct(u32) {
                ///  TEA
                TEA: u7,
                ///  TED
                TED: u1,
                ///  TELD
                TELD: u1,
                ///  TEMD
                TEMD: u1,
                ///  ASE
                ASE: u1,
                ///  BSE
                BSE: u1,
                padding: u20,
            }),
            ///  This register is used to control the concerned channel.
            MDMA_C31CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  TEIE
                TEIE: u1,
                ///  CTCIE
                CTCIE: u1,
                ///  BRTIE
                BRTIE: u1,
                ///  BTIE
                BTIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  PL
                PL: u2,
                reserved12: u4,
                ///  BEX
                BEX: u1,
                ///  HEX
                HEX: u1,
                ///  WEX
                WEX: u1,
                reserved16: u1,
                ///  SWRQ
                SWRQ: u1,
                padding: u15,
            }),
            ///  This register is used to configure the concerned channel. In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
            MDMA_C31TCR: mmio.Mmio(packed struct(u32) {
                ///  SINC
                SINC: u2,
                ///  DINC
                DINC: u2,
                ///  SSIZE
                SSIZE: u2,
                ///  DSIZE
                DSIZE: u2,
                ///  SINCOS
                SINCOS: u2,
                ///  DINCOS
                DINCOS: u2,
                ///  SBURST
                SBURST: u3,
                ///  DBURST
                DBURST: u3,
                ///  TLEN
                TLEN: u7,
                ///  PKE
                PKE: u1,
                ///  PAM
                PAM: u2,
                ///  TRGM
                TRGM: u2,
                ///  SWRM
                SWRM: u1,
                ///  BWM
                BWM: u1,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x04).
            MDMA_C31BNDTR: mmio.Mmio(packed struct(u32) {
                ///  BNDT
                BNDT: u17,
                reserved18: u1,
                ///  BRSUM
                BRSUM: u1,
                ///  BRDUM
                BRDUM: u1,
                ///  BRC
                BRC: u12,
            }),
            ///  In Linked List mode, at the end of a Block (single or last Block in repeated Block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x08).
            MDMA_C31SAR: mmio.Mmio(packed struct(u32) {
                ///  SAR
                SAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x0C). M
            MDMA_C31DAR: mmio.Mmio(packed struct(u32) {
                ///  DAR
                DAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x10).
            MDMA_C31BRUR: mmio.Mmio(packed struct(u32) {
                ///  SUV
                SUV: u16,
                ///  DUV
                DUV: u16,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x14). The new value is only taken into account after all registers are updated, for the next end of block.
            MDMA_C31LAR: mmio.Mmio(packed struct(u32) {
                ///  LAR
                LAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x18).
            MDMA_C31TBR: mmio.Mmio(packed struct(u32) {
                ///  TSEL
                TSEL: u6,
                reserved16: u10,
                ///  SBUS
                SBUS: u1,
                ///  DBUS
                DBUS: u1,
                padding: u14,
            }),
            reserved2096: [4]u8,
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x20).
            MDMA_C31MAR: mmio.Mmio(packed struct(u32) {
                ///  MAR
                MAR: u32,
            }),
            ///  In Linked List mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x24).
            MDMA_C31MDR: mmio.Mmio(packed struct(u32) {
                ///  MDR
                MDR: u32,
            }),
        };

        ///  Nested Vectored Interrupt Controller
        pub const NVIC = extern struct {
            ///  Interrupt Set-Enable Register
            ISER0: mmio.Mmio(packed struct(u32) {
                ///  SETENA
                SETENA: u32,
            }),
            ///  Interrupt Set-Enable Register
            ISER1: mmio.Mmio(packed struct(u32) {
                ///  SETENA
                SETENA: u32,
            }),
            ///  Interrupt Set-Enable Register
            ISER2: mmio.Mmio(packed struct(u32) {
                ///  SETENA
                SETENA: u32,
            }),
            ///  Interrupt Set-Enable Register
            ISER3: mmio.Mmio(packed struct(u32) {
                ///  SETENA
                SETENA: u32,
            }),
            ///  Interrupt Set-Enable Register
            ISER4: u32,
            reserved128: [108]u8,
            ///  Interrupt Clear-Enable Register
            ICER0: mmio.Mmio(packed struct(u32) {
                ///  CLRENA
                CLRENA: u32,
            }),
            ///  Interrupt Clear-Enable Register
            ICER1: mmio.Mmio(packed struct(u32) {
                ///  CLRENA
                CLRENA: u32,
            }),
            ///  Interrupt Clear-Enable Register
            ICER2: mmio.Mmio(packed struct(u32) {
                ///  CLRENA
                CLRENA: u32,
            }),
            ///  Interrupt Clear-Enable Register
            ICER3: mmio.Mmio(packed struct(u32) {
                ///  CLRENA
                CLRENA: u32,
            }),
            ///  Interrupt Clear-Enable Register
            ICER4: u32,
            reserved256: [108]u8,
            ///  Interrupt Set-Pending Register
            ISPR0: mmio.Mmio(packed struct(u32) {
                ///  SETPEND
                SETPEND: u32,
            }),
            ///  Interrupt Set-Pending Register
            ISPR1: mmio.Mmio(packed struct(u32) {
                ///  SETPEND
                SETPEND: u32,
            }),
            ///  Interrupt Set-Pending Register
            ISPR2: mmio.Mmio(packed struct(u32) {
                ///  SETPEND
                SETPEND: u32,
            }),
            ///  Interrupt Set-Pending Register
            ISPR3: mmio.Mmio(packed struct(u32) {
                ///  SETPEND
                SETPEND: u32,
            }),
            ///  Interrupt Set-Pending Register
            ISPR4: u32,
            reserved384: [108]u8,
            ///  Interrupt Clear-Pending Register
            ICPR0: mmio.Mmio(packed struct(u32) {
                ///  CLRPEND
                CLRPEND: u32,
            }),
            ///  Interrupt Clear-Pending Register
            ICPR1: mmio.Mmio(packed struct(u32) {
                ///  CLRPEND
                CLRPEND: u32,
            }),
            ///  Interrupt Clear-Pending Register
            ICPR2: mmio.Mmio(packed struct(u32) {
                ///  CLRPEND
                CLRPEND: u32,
            }),
            ///  Interrupt Clear-Pending Register
            ICPR3: mmio.Mmio(packed struct(u32) {
                ///  CLRPEND
                CLRPEND: u32,
            }),
            reserved452: [52]u8,
            ///  Interrupt Clear-Pending Register
            ICPR4: u32,
            reserved512: [56]u8,
            ///  Interrupt Active Bit Register
            IABR0: mmio.Mmio(packed struct(u32) {
                ///  ACTIVE
                ACTIVE: u32,
            }),
            ///  Interrupt Active Bit Register
            IABR1: mmio.Mmio(packed struct(u32) {
                ///  ACTIVE
                ACTIVE: u32,
            }),
            ///  Interrupt Active Bit Register
            IABR2: mmio.Mmio(packed struct(u32) {
                ///  ACTIVE
                ACTIVE: u32,
            }),
            ///  Interrupt Active Bit Register
            IABR3: mmio.Mmio(packed struct(u32) {
                ///  ACTIVE
                ACTIVE: u32,
            }),
            ///  Interrupt Active Bit Register
            IABR4: u32,
            reserved768: [236]u8,
            ///  Interrupt Priority Register
            IPR0: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR1: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR2: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR3: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR4: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR5: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR6: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR7: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR8: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR9: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR10: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR11: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR12: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR13: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR14: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR15: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR16: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR17: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR18: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR19: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR20: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR21: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR22: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR23: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR24: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR25: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR26: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR27: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR28: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR29: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR30: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR31: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR32: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR33: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR34: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR35: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR36: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR37: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
            ///  Interrupt Priority Register
            IPR38: mmio.Mmio(packed struct(u32) {
                ///  IPR_N0
                IPR_N0: u8,
                ///  IPR_N1
                IPR_N1: u8,
                ///  IPR_N2
                IPR_N2: u8,
                ///  IPR_N3
                IPR_N3: u8,
            }),
        };

        ///  OTG
        pub const OTG = extern struct {
            ///  The OTG_GOTGCTL register controls the behavior and reflects the status of the OTG function of the core.
            OTG_GOTGCTL: mmio.Mmio(packed struct(u32) {
                ///  SRQSCS
                SRQSCS: u1,
                ///  SRQ
                SRQ: u1,
                ///  VBVALOEN
                VBVALOEN: u1,
                ///  VBVALOVAL
                VBVALOVAL: u1,
                ///  AVALOEN
                AVALOEN: u1,
                ///  AVALOVAL
                AVALOVAL: u1,
                ///  BVALOEN
                BVALOEN: u1,
                ///  BVALOVAL
                BVALOVAL: u1,
                ///  HNGSCS
                HNGSCS: u1,
                ///  HNPRQ
                HNPRQ: u1,
                ///  HSHNPEN
                HSHNPEN: u1,
                ///  DHNPEN
                DHNPEN: u1,
                ///  EHEN
                EHEN: u1,
                reserved16: u3,
                ///  CIDSTS
                CIDSTS: u1,
                ///  DBCT
                DBCT: u1,
                ///  ASVLD
                ASVLD: u1,
                ///  BSVLD
                BSVLD: u1,
                ///  OTGVER
                OTGVER: u1,
                ///  CURMOD
                CURMOD: u1,
                padding: u10,
            }),
            ///  The application reads this register whenever there is an OTG interrupt and clears the bits in this register to clear the OTG interrupt.
            OTG_GOTGINT: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  SEDET
                SEDET: u1,
                reserved8: u5,
                ///  SRSSCHG
                SRSSCHG: u1,
                ///  HNSSCHG
                HNSSCHG: u1,
                reserved17: u7,
                ///  HNGDET
                HNGDET: u1,
                ///  ADTOCHG
                ADTOCHG: u1,
                ///  DBCDNE
                DBCDNE: u1,
                ///  IDCHNG
                IDCHNG: u1,
                padding: u11,
            }),
            ///  This register can be used to configure the core after power-on or a change in mode. This register mainly contains AHB system-related configuration parameters. Do not change this register after the initial programming. The application must program this register before starting any transactions on either the AHB or the USB.
            OTG_GAHBCFG: mmio.Mmio(packed struct(u32) {
                ///  GINTMSK
                GINTMSK: u1,
                ///  HBSTLEN
                HBSTLEN: u4,
                ///  DMAEN
                DMAEN: u1,
                reserved7: u1,
                ///  TXFELVL
                TXFELVL: u1,
                ///  PTXFELVL
                PTXFELVL: u1,
                padding: u23,
            }),
            ///  This register can be used to configure the core after power-on or a changing to host mode or device mode. It contains USB and USB-PHY related configuration parameters. The application must program this register before starting any transactions on either the AHB or the USB. Do not make changes to this register after the initial programming.
            OTG_GUSBCFG: mmio.Mmio(packed struct(u32) {
                ///  TOCAL
                TOCAL: u3,
                reserved6: u3,
                ///  PHYSEL
                PHYSEL: u1,
                reserved8: u1,
                ///  SRPCAP
                SRPCAP: u1,
                ///  HNPCAP
                HNPCAP: u1,
                ///  TRDT
                TRDT: u4,
                reserved15: u1,
                ///  PHYLPC
                PHYLPC: u1,
                reserved22: u6,
                ///  TSDPS
                TSDPS: u1,
                reserved29: u6,
                ///  FHMOD
                FHMOD: u1,
                ///  FDMOD
                FDMOD: u1,
                padding: u1,
            }),
            ///  The application uses this register to reset various hardware features inside the core.
            OTG_GRSTCTL: mmio.Mmio(packed struct(u32) {
                ///  CSRST
                CSRST: u1,
                ///  PSRST
                PSRST: u1,
                reserved4: u2,
                ///  RXFFLSH
                RXFFLSH: u1,
                ///  TXFFLSH
                TXFFLSH: u1,
                ///  TXFNUM
                TXFNUM: u5,
                reserved30: u19,
                ///  DMAREQ
                DMAREQ: u1,
                ///  AHBIDL
                AHBIDL: u1,
            }),
            ///  This register interrupts the application for system-level events in the current mode (device mode or host mode). Some of the bits in this register are valid only in host mode, while others are valid in device mode only. This register also indicates the current mode. To clear the interrupt status bits of the rc_w1 type, the application must write 1 into the bit. The FIFO status interrupts are read-only; once software reads from or writes to the FIFO while servicing these interrupts, FIFO interrupt conditions are cleared automatically. The application must clear the OTG_GINTSTS register at initialization before unmasking the interrupt bit to avoid any interrupts generated prior to initialization.
            OTG_GINTSTS: mmio.Mmio(packed struct(u32) {
                ///  CMOD
                CMOD: u1,
                ///  MMIS
                MMIS: u1,
                ///  OTGINT
                OTGINT: u1,
                ///  SOF
                SOF: u1,
                ///  RXFLVL
                RXFLVL: u1,
                ///  NPTXFE
                NPTXFE: u1,
                ///  GINAKEFF
                GINAKEFF: u1,
                ///  GONAKEFF
                GONAKEFF: u1,
                reserved10: u2,
                ///  ESUSP
                ESUSP: u1,
                ///  USBSUSP
                USBSUSP: u1,
                ///  USBRST
                USBRST: u1,
                ///  ENUMDNE
                ENUMDNE: u1,
                ///  ISOODRP
                ISOODRP: u1,
                ///  EOPF
                EOPF: u1,
                reserved18: u2,
                ///  IEPINT
                IEPINT: u1,
                ///  OEPINT
                OEPINT: u1,
                ///  IISOIXFR
                IISOIXFR: u1,
                ///  IPXFR
                IPXFR: u1,
                ///  DATAFSUSP
                DATAFSUSP: u1,
                reserved24: u1,
                ///  HPRTINT
                HPRTINT: u1,
                ///  HCINT
                HCINT: u1,
                ///  PTXFE
                PTXFE: u1,
                reserved28: u1,
                ///  CIDSCHG
                CIDSCHG: u1,
                ///  DISCINT
                DISCINT: u1,
                ///  SRQINT
                SRQINT: u1,
                ///  WKUPINT
                WKUPINT: u1,
            }),
            ///  This register works with the core interrupt register to interrupt the application. When an interrupt bit is masked, the interrupt associated with that bit is not generated. However, the core interrupt (OTG_GINTSTS) register bit corresponding to that interrupt is still set.
            OTG_GINTMSK: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  MMISM
                MMISM: u1,
                ///  OTGINT
                OTGINT: u1,
                ///  SOFM
                SOFM: u1,
                ///  RXFLVLM
                RXFLVLM: u1,
                ///  NPTXFEM
                NPTXFEM: u1,
                ///  GINAKEFFM
                GINAKEFFM: u1,
                ///  GONAKEFFM
                GONAKEFFM: u1,
                reserved10: u2,
                ///  ESUSPM
                ESUSPM: u1,
                ///  USBSUSPM
                USBSUSPM: u1,
                ///  USBRST
                USBRST: u1,
                ///  ENUMDNEM
                ENUMDNEM: u1,
                ///  ISOODRPM
                ISOODRPM: u1,
                ///  EOPFM
                EOPFM: u1,
                reserved18: u2,
                ///  IEPINT
                IEPINT: u1,
                ///  OEPINT
                OEPINT: u1,
                ///  IISOIXFRM
                IISOIXFRM: u1,
                ///  IPXFRM
                IPXFRM: u1,
                ///  FSUSPM
                FSUSPM: u1,
                ///  RSTDETM
                RSTDETM: u1,
                ///  PRTIM
                PRTIM: u1,
                ///  HCIM
                HCIM: u1,
                ///  PTXFEM
                PTXFEM: u1,
                ///  LPMINTM
                LPMINTM: u1,
                ///  CIDSCHGM
                CIDSCHGM: u1,
                ///  DISCINT
                DISCINT: u1,
                ///  SRQIM
                SRQIM: u1,
                ///  WUIM
                WUIM: u1,
            }),
            ///  This description is for register OTG_GRXSTSR in Device mode. A read to the receive status debug read register returns the contents of the top of the receive FIFO. The core ignores the receive status read when the receive FIFO is empty and returns a value of 0x00000000.
            OTG_GRXSTSR: mmio.Mmio(packed struct(u32) {
                ///  EPNUM
                EPNUM: u4,
                ///  BCNT
                BCNT: u11,
                ///  DPID
                DPID: u2,
                ///  PKTSTS
                PKTSTS: u4,
                ///  FRMNUM
                FRMNUM: u4,
                reserved27: u2,
                ///  STSPHST
                STSPHST: u1,
                padding: u4,
            }),
            ///  This description is for register OTG_GRXSTSP in Device mode. Similarly to OTG_GRXSTSR (receive status debug read register) where a read returns the contents of the top of the receive FIFO, a read to OTG_GRXSTSP (receive status read and pop register) additionally pops the top data entry out of the Rx FIFO. The core ignores the receive status pop/read when the receive FIFO is empty and returns a value of 0x00000000. The application must only pop the receive status FIFO when the receive FIFO non-empty bit of the core interrupt register (RXFLVL bit in OTG_GINTSTS) is asserted.
            OTG_GRXSTSP: mmio.Mmio(packed struct(u32) {
                ///  EPNUM
                EPNUM: u4,
                ///  BCNT
                BCNT: u11,
                ///  DPID
                DPID: u2,
                ///  PKTSTS
                PKTSTS: u4,
                ///  FRMNUM
                FRMNUM: u4,
                reserved27: u2,
                ///  STSPHST
                STSPHST: u1,
                padding: u4,
            }),
            ///  The application can program the RAM size that must be allocated to the Rx FIFO.
            OTG_GRXFSIZ: mmio.Mmio(packed struct(u32) {
                ///  RXFD
                RXFD: u16,
                padding: u16,
            }),
            ///  Host mode
            OTG_HNPTXFSIZ: mmio.Mmio(packed struct(u32) {
                ///  NPTXFSA
                NPTXFSA: u16,
                ///  NPTXFD
                NPTXFD: u16,
            }),
            ///  In device mode, this register is not valid. This read-only register contains the free space information for the non-periodic Tx FIFO and the non-periodic transmit request queue.
            OTG_HNPTXSTS: mmio.Mmio(packed struct(u32) {
                ///  NPTXFSAV
                NPTXFSAV: u16,
                ///  NPTQXSAV
                NPTQXSAV: u8,
                ///  NPTXQTOP
                NPTXQTOP: u7,
                padding: u1,
            }),
            reserved56: [8]u8,
            ///  OTG general core configuration register
            OTG_GCCFG: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  PDET
                PDET: u1,
                ///  SDET
                SDET: u1,
                ///  PS2DET
                PS2DET: u1,
                reserved16: u12,
                ///  PWRDWN
                PWRDWN: u1,
                ///  BCDEN
                BCDEN: u1,
                reserved19: u1,
                ///  PDEN
                PDEN: u1,
                ///  SDEN
                SDEN: u1,
                ///  VBDEN
                VBDEN: u1,
                ///  IDEN
                IDEN: u1,
                padding: u9,
            }),
            ///  This is a register containing the Product ID as reset value.
            OTG_CID: mmio.Mmio(packed struct(u32) {
                ///  PRODUCT_ID
                PRODUCT_ID: u32,
            }),
            reserved84: [20]u8,
            ///  OTG core LPM configuration register
            OTG_GLPMCFG: mmio.Mmio(packed struct(u32) {
                ///  LPMEN
                LPMEN: u1,
                ///  LPMACK
                LPMACK: u1,
                ///  BESL
                BESL: u4,
                ///  REMWAKE
                REMWAKE: u1,
                ///  L1SSEN
                L1SSEN: u1,
                ///  BESLTHRS
                BESLTHRS: u4,
                ///  L1DSEN
                L1DSEN: u1,
                ///  LPMRSP
                LPMRSP: u2,
                ///  SLPSTS
                SLPSTS: u1,
                ///  L1RSMOK
                L1RSMOK: u1,
                ///  LPMCHIDX
                LPMCHIDX: u4,
                ///  LPMRCNT
                LPMRCNT: u3,
                ///  SNDLPM
                SNDLPM: u1,
                ///  LPMRCNTSTS
                LPMRCNTSTS: u3,
                ///  ENBESL
                ENBESL: u1,
                padding: u3,
            }),
            reserved256: [168]u8,
            ///  OTG host periodic transmit FIFO size register
            OTG_HPTXFSIZ: mmio.Mmio(packed struct(u32) {
                ///  PTXSA
                PTXSA: u16,
                ///  PTXFSIZ
                PTXFSIZ: u16,
            }),
            ///  OTG device IN endpoint transmit FIFO 1 size register
            OTG_DIEPTXF1: mmio.Mmio(packed struct(u32) {
                ///  INEPTXSA
                INEPTXSA: u16,
                ///  INEPTXFD
                INEPTXFD: u16,
            }),
            ///  OTG device IN endpoint transmit FIFO 2 size register
            OTG_DIEPTXF2: mmio.Mmio(packed struct(u32) {
                ///  INEPTXSA
                INEPTXSA: u16,
                ///  INEPTXFD
                INEPTXFD: u16,
            }),
            ///  OTG device IN endpoint transmit FIFO 3 size register
            OTG_DIEPTXF3: mmio.Mmio(packed struct(u32) {
                ///  INEPTXSA
                INEPTXSA: u16,
                ///  INEPTXFD
                INEPTXFD: u16,
            }),
            ///  OTG device IN endpoint transmit FIFO 4 size register
            OTG_DIEPTXF4: mmio.Mmio(packed struct(u32) {
                ///  INEPTXSA
                INEPTXSA: u16,
                ///  INEPTXFD
                INEPTXFD: u16,
            }),
            ///  OTG device IN endpoint transmit FIFO 5 size register
            OTG_DIEPTXF5: mmio.Mmio(packed struct(u32) {
                ///  INEPTXSA
                INEPTXSA: u16,
                ///  INEPTXFD
                INEPTXFD: u16,
            }),
            ///  OTG device IN endpoint transmit FIFO 6 size register
            OTG_DIEPTXF6: mmio.Mmio(packed struct(u32) {
                ///  INEPTXSA
                INEPTXSA: u16,
                ///  INEPTXFD
                INEPTXFD: u16,
            }),
            ///  OTG device IN endpoint transmit FIFO 7 size register
            OTG_DIEPTXF7: mmio.Mmio(packed struct(u32) {
                ///  INEPTXSA
                INEPTXSA: u16,
                ///  INEPTXFD
                INEPTXFD: u16,
            }),
            ///  OTG device IN endpoint transmit FIFO 8 size register
            OTG_DIEPTXF8: mmio.Mmio(packed struct(u32) {
                ///  INEPTXSA
                INEPTXSA: u16,
                ///  INEPTXFD
                INEPTXFD: u16,
            }),
            reserved1024: [732]u8,
            ///  This register configures the core after power-on. Do not make changes to this register after initializing the host.
            OTG_HCFG: mmio.Mmio(packed struct(u32) {
                ///  FSLSPCS
                FSLSPCS: u2,
                ///  FSLSS
                FSLSS: u1,
                reserved23: u20,
                ///  DESCDMA
                DESCDMA: u1,
                ///  FRLSTEN
                FRLSTEN: u2,
                ///  PERSSCHEDENA
                PERSSCHEDENA: u1,
                padding: u5,
            }),
            ///  This register stores the frame interval information for the current speed to which the OTG controller has enumerated.
            OTG_HFIR: mmio.Mmio(packed struct(u32) {
                ///  FRIVL
                FRIVL: u16,
                ///  RLDCTRL
                RLDCTRL: u1,
                padding: u15,
            }),
            ///  This register indicates the current frame number. It also indicates the time remaining (in terms of the number of PHY clocks) in the current frame.
            OTG_HFNUM: mmio.Mmio(packed struct(u32) {
                ///  FRNUM
                FRNUM: u16,
                ///  FTREM
                FTREM: u16,
            }),
            reserved1040: [4]u8,
            ///  This read-only register contains the free space information for the periodic Tx FIFO and the periodic transmit request queue.
            OTG_HPTXSTS: mmio.Mmio(packed struct(u32) {
                ///  PTXFSAVL
                PTXFSAVL: u16,
                ///  PTXQSAV
                PTXQSAV: u8,
                ///  PTXQTOP
                PTXQTOP: u8,
            }),
            ///  When a significant event occurs on a channel, the host all channels interrupt register interrupts the application using the host channels interrupt bit of the core interrupt register (HCINT bit in OTG_GINTSTS). This is shown in Figure724. There is one interrupt bit per channel, up to a maximum of 16 bits. Bits in this register are set and cleared when the application sets and clears bits in the corresponding host channel-x interrupt register.
            OTG_HAINT: mmio.Mmio(packed struct(u32) {
                ///  HAINT
                HAINT: u16,
                padding: u16,
            }),
            ///  The host all channel interrupt mask register works with the host all channel interrupt register to interrupt the application when an event occurs on a channel. There is one interrupt mask bit per channel, up to a maximum of 16 bits.
            OTG_HAINTMSK: mmio.Mmio(packed struct(u32) {
                ///  HAINTM
                HAINTM: u16,
                padding: u16,
            }),
            ///  This register holds the starting address of the frame list information (scatter/gather mode).
            OTG_HFLBADDR: mmio.Mmio(packed struct(u32) {
                ///  HFLBADDR
                HFLBADDR: u32,
            }),
            reserved1088: [32]u8,
            ///  This register is available only in host mode. Currently, the OTG host supports only one port. A single register holds USB port-related information such as USB reset, enable, suspend, resume, connect status, and test mode for each port. It is shown in Figure724. The rc_w1 bits in this register can trigger an interrupt to the application through the host port interrupt bit of the core interrupt register (HPRTINT bit in OTG_GINTSTS). On a port interrupt, the application must read this register and clear the bit that caused the interrupt. For the rc_w1 bits, the application must write a 1 to the bit to clear the interrupt.
            OTG_HPRT: mmio.Mmio(packed struct(u32) {
                ///  PCSTS
                PCSTS: u1,
                ///  PCDET
                PCDET: u1,
                ///  PENA
                PENA: u1,
                ///  PENCHNG
                PENCHNG: u1,
                ///  POCA
                POCA: u1,
                ///  POCCHNG
                POCCHNG: u1,
                ///  PRES
                PRES: u1,
                ///  PSUSP
                PSUSP: u1,
                ///  PRST
                PRST: u1,
                reserved10: u1,
                ///  PLSTS
                PLSTS: u2,
                ///  PPWR
                PPWR: u1,
                ///  PTCTL
                PTCTL: u4,
                ///  PSPD
                PSPD: u2,
                padding: u13,
            }),
            reserved1280: [188]u8,
            ///  OTG host channel 0 characteristics register
            OTG_HCCHAR0: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                ///  EPNUM
                EPNUM: u4,
                ///  EPDIR
                EPDIR: u1,
                reserved17: u1,
                ///  LSDEV
                LSDEV: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  MCNT
                MCNT: u2,
                ///  DAD
                DAD: u7,
                reserved30: u1,
                ///  CHDIS
                CHDIS: u1,
                ///  CHENA
                CHENA: u1,
            }),
            ///  OTG host channel 0 split control register
            OTG_HCSPLT0: mmio.Mmio(packed struct(u32) {
                ///  PRTADDR
                PRTADDR: u7,
                ///  HUBADDR
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  COMPLSPLT
                COMPLSPLT: u1,
                reserved31: u14,
                ///  SPLITEN
                SPLITEN: u1,
            }),
            ///  This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
            OTG_HCINT0: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  CHH
                CHH: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STALL
                STALL: u1,
                ///  NAK
                NAK: u1,
                ///  ACK
                ACK: u1,
                ///  NYET
                NYET: u1,
                ///  TXERR
                TXERR: u1,
                ///  BBERR
                BBERR: u1,
                ///  FRMOR
                FRMOR: u1,
                ///  DTERR
                DTERR: u1,
                ///  BNA
                BNA: u1,
                ///  XCSXACTERR
                XCSXACTERR: u1,
                ///  DESCLSTROLL
                DESCLSTROLL: u1,
                padding: u18,
            }),
            ///  This register reflects the mask for each channel status described in the previous section.
            OTG_HCINTMSK0: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  CHHM
                CHHM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STALLM
                STALLM: u1,
                ///  NAKM
                NAKM: u1,
                ///  ACKM
                ACKM: u1,
                ///  NYET
                NYET: u1,
                ///  TXERRM
                TXERRM: u1,
                ///  BBERRM
                BBERRM: u1,
                ///  FRMORM
                FRMORM: u1,
                ///  DTERRM
                DTERRM: u1,
                ///  BNAMSK
                BNAMSK: u1,
                reserved13: u1,
                ///  DESCLSTROLLMSK
                DESCLSTROLLMSK: u1,
                padding: u18,
            }),
            ///  OTG host channel 0 transfer size register
            OTG_HCTSIZ0: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  DPID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG host channel 0 DMA address register in buffer DMA [alternate]
            OTG_HCDMA0: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved1308: [4]u8,
            ///  OTG host channel-n DMA address buffer register
            OTG_HCDMAB0: mmio.Mmio(packed struct(u32) {
                ///  HCDMAB
                HCDMAB: u32,
            }),
            ///  OTG host channel 1 characteristics register
            OTG_HCCHAR1: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                ///  EPNUM
                EPNUM: u4,
                ///  EPDIR
                EPDIR: u1,
                reserved17: u1,
                ///  LSDEV
                LSDEV: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  MCNT
                MCNT: u2,
                ///  DAD
                DAD: u7,
                reserved30: u1,
                ///  CHDIS
                CHDIS: u1,
                ///  CHENA
                CHENA: u1,
            }),
            ///  OTG host channel 1 split control register
            OTG_HCSPLT1: mmio.Mmio(packed struct(u32) {
                ///  PRTADDR
                PRTADDR: u7,
                ///  HUBADDR
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  COMPLSPLT
                COMPLSPLT: u1,
                reserved31: u14,
                ///  SPLITEN
                SPLITEN: u1,
            }),
            ///  This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
            OTG_HCINT1: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  CHH
                CHH: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STALL
                STALL: u1,
                ///  NAK
                NAK: u1,
                ///  ACK
                ACK: u1,
                ///  NYET
                NYET: u1,
                ///  TXERR
                TXERR: u1,
                ///  BBERR
                BBERR: u1,
                ///  FRMOR
                FRMOR: u1,
                ///  DTERR
                DTERR: u1,
                ///  BNA
                BNA: u1,
                ///  XCSXACTERR
                XCSXACTERR: u1,
                ///  DESCLSTROLL
                DESCLSTROLL: u1,
                padding: u18,
            }),
            ///  This register reflects the mask for each channel status described in the previous section.
            OTG_HCINTMSK1: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  CHHM
                CHHM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STALLM
                STALLM: u1,
                ///  NAKM
                NAKM: u1,
                ///  ACKM
                ACKM: u1,
                ///  NYET
                NYET: u1,
                ///  TXERRM
                TXERRM: u1,
                ///  BBERRM
                BBERRM: u1,
                ///  FRMORM
                FRMORM: u1,
                ///  DTERRM
                DTERRM: u1,
                ///  BNAMSK
                BNAMSK: u1,
                reserved13: u1,
                ///  DESCLSTROLLMSK
                DESCLSTROLLMSK: u1,
                padding: u18,
            }),
            ///  OTG host channel 1 transfer size register
            OTG_HCTSIZ1: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  DPID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG host channel 1 DMA address register in buffer DMA [alternate]
            OTG_HCDMA1: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved1340: [4]u8,
            ///  OTG host channel-n DMA address buffer register
            OTG_HCDMAB1: mmio.Mmio(packed struct(u32) {
                ///  HCDMAB
                HCDMAB: u32,
            }),
            ///  OTG host channel 2 characteristics register
            OTG_HCCHAR2: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                ///  EPNUM
                EPNUM: u4,
                ///  EPDIR
                EPDIR: u1,
                reserved17: u1,
                ///  LSDEV
                LSDEV: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  MCNT
                MCNT: u2,
                ///  DAD
                DAD: u7,
                reserved30: u1,
                ///  CHDIS
                CHDIS: u1,
                ///  CHENA
                CHENA: u1,
            }),
            ///  OTG host channel 2 split control register
            OTG_HCSPLT2: mmio.Mmio(packed struct(u32) {
                ///  PRTADDR
                PRTADDR: u7,
                ///  HUBADDR
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  COMPLSPLT
                COMPLSPLT: u1,
                reserved31: u14,
                ///  SPLITEN
                SPLITEN: u1,
            }),
            ///  This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
            OTG_HCINT2: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  CHH
                CHH: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STALL
                STALL: u1,
                ///  NAK
                NAK: u1,
                ///  ACK
                ACK: u1,
                ///  NYET
                NYET: u1,
                ///  TXERR
                TXERR: u1,
                ///  BBERR
                BBERR: u1,
                ///  FRMOR
                FRMOR: u1,
                ///  DTERR
                DTERR: u1,
                ///  BNA
                BNA: u1,
                ///  XCSXACTERR
                XCSXACTERR: u1,
                ///  DESCLSTROLL
                DESCLSTROLL: u1,
                padding: u18,
            }),
            ///  This register reflects the mask for each channel status described in the previous section.
            OTG_HCINTMSK2: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  CHHM
                CHHM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STALLM
                STALLM: u1,
                ///  NAKM
                NAKM: u1,
                ///  ACKM
                ACKM: u1,
                ///  NYET
                NYET: u1,
                ///  TXERRM
                TXERRM: u1,
                ///  BBERRM
                BBERRM: u1,
                ///  FRMORM
                FRMORM: u1,
                ///  DTERRM
                DTERRM: u1,
                ///  BNAMSK
                BNAMSK: u1,
                reserved13: u1,
                ///  DESCLSTROLLMSK
                DESCLSTROLLMSK: u1,
                padding: u18,
            }),
            ///  OTG host channel 2 transfer size register
            OTG_HCTSIZ2: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  DPID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG host channel 2 DMA address register in buffer DMA [alternate]
            OTG_HCDMA2: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved1372: [4]u8,
            ///  OTG host channel-n DMA address buffer register
            OTG_HCDMAB2: mmio.Mmio(packed struct(u32) {
                ///  HCDMAB
                HCDMAB: u32,
            }),
            ///  OTG host channel 3 characteristics register
            OTG_HCCHAR3: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                ///  EPNUM
                EPNUM: u4,
                ///  EPDIR
                EPDIR: u1,
                reserved17: u1,
                ///  LSDEV
                LSDEV: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  MCNT
                MCNT: u2,
                ///  DAD
                DAD: u7,
                reserved30: u1,
                ///  CHDIS
                CHDIS: u1,
                ///  CHENA
                CHENA: u1,
            }),
            ///  OTG host channel 3 split control register
            OTG_HCSPLT3: mmio.Mmio(packed struct(u32) {
                ///  PRTADDR
                PRTADDR: u7,
                ///  HUBADDR
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  COMPLSPLT
                COMPLSPLT: u1,
                reserved31: u14,
                ///  SPLITEN
                SPLITEN: u1,
            }),
            ///  This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
            OTG_HCINT3: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  CHH
                CHH: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STALL
                STALL: u1,
                ///  NAK
                NAK: u1,
                ///  ACK
                ACK: u1,
                ///  NYET
                NYET: u1,
                ///  TXERR
                TXERR: u1,
                ///  BBERR
                BBERR: u1,
                ///  FRMOR
                FRMOR: u1,
                ///  DTERR
                DTERR: u1,
                ///  BNA
                BNA: u1,
                ///  XCSXACTERR
                XCSXACTERR: u1,
                ///  DESCLSTROLL
                DESCLSTROLL: u1,
                padding: u18,
            }),
            ///  This register reflects the mask for each channel status described in the previous section.
            OTG_HCINTMSK3: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  CHHM
                CHHM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STALLM
                STALLM: u1,
                ///  NAKM
                NAKM: u1,
                ///  ACKM
                ACKM: u1,
                ///  NYET
                NYET: u1,
                ///  TXERRM
                TXERRM: u1,
                ///  BBERRM
                BBERRM: u1,
                ///  FRMORM
                FRMORM: u1,
                ///  DTERRM
                DTERRM: u1,
                ///  BNAMSK
                BNAMSK: u1,
                reserved13: u1,
                ///  DESCLSTROLLMSK
                DESCLSTROLLMSK: u1,
                padding: u18,
            }),
            ///  OTG host channel 3 transfer size register
            OTG_HCTSIZ3: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  DPID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG host channel 3 DMA address register in buffer DMA [alternate]
            OTG_HCDMA3: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved1404: [4]u8,
            ///  OTG host channel-n DMA address buffer register
            OTG_HCDMAB3: mmio.Mmio(packed struct(u32) {
                ///  HCDMAB
                HCDMAB: u32,
            }),
            ///  OTG host channel 4 characteristics register
            OTG_HCCHAR4: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                ///  EPNUM
                EPNUM: u4,
                ///  EPDIR
                EPDIR: u1,
                reserved17: u1,
                ///  LSDEV
                LSDEV: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  MCNT
                MCNT: u2,
                ///  DAD
                DAD: u7,
                reserved30: u1,
                ///  CHDIS
                CHDIS: u1,
                ///  CHENA
                CHENA: u1,
            }),
            ///  OTG host channel 4 split control register
            OTG_HCSPLT4: mmio.Mmio(packed struct(u32) {
                ///  PRTADDR
                PRTADDR: u7,
                ///  HUBADDR
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  COMPLSPLT
                COMPLSPLT: u1,
                reserved31: u14,
                ///  SPLITEN
                SPLITEN: u1,
            }),
            ///  This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
            OTG_HCINT4: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  CHH
                CHH: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STALL
                STALL: u1,
                ///  NAK
                NAK: u1,
                ///  ACK
                ACK: u1,
                ///  NYET
                NYET: u1,
                ///  TXERR
                TXERR: u1,
                ///  BBERR
                BBERR: u1,
                ///  FRMOR
                FRMOR: u1,
                ///  DTERR
                DTERR: u1,
                ///  BNA
                BNA: u1,
                ///  XCSXACTERR
                XCSXACTERR: u1,
                ///  DESCLSTROLL
                DESCLSTROLL: u1,
                padding: u18,
            }),
            ///  This register reflects the mask for each channel status described in the previous section.
            OTG_HCINTMSK4: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  CHHM
                CHHM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STALLM
                STALLM: u1,
                ///  NAKM
                NAKM: u1,
                ///  ACKM
                ACKM: u1,
                ///  NYET
                NYET: u1,
                ///  TXERRM
                TXERRM: u1,
                ///  BBERRM
                BBERRM: u1,
                ///  FRMORM
                FRMORM: u1,
                ///  DTERRM
                DTERRM: u1,
                ///  BNAMSK
                BNAMSK: u1,
                reserved13: u1,
                ///  DESCLSTROLLMSK
                DESCLSTROLLMSK: u1,
                padding: u18,
            }),
            ///  OTG host channel 4 transfer size register
            OTG_HCTSIZ4: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  DPID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG host channel 4 DMA address register in buffer DMA [alternate]
            OTG_HCDMA4: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved1436: [4]u8,
            ///  OTG host channel-n DMA address buffer register
            OTG_HCDMAB4: mmio.Mmio(packed struct(u32) {
                ///  HCDMAB
                HCDMAB: u32,
            }),
            ///  OTG host channel 5 characteristics register
            OTG_HCCHAR5: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                ///  EPNUM
                EPNUM: u4,
                ///  EPDIR
                EPDIR: u1,
                reserved17: u1,
                ///  LSDEV
                LSDEV: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  MCNT
                MCNT: u2,
                ///  DAD
                DAD: u7,
                reserved30: u1,
                ///  CHDIS
                CHDIS: u1,
                ///  CHENA
                CHENA: u1,
            }),
            ///  OTG host channel 5 split control register
            OTG_HCSPLT5: mmio.Mmio(packed struct(u32) {
                ///  PRTADDR
                PRTADDR: u7,
                ///  HUBADDR
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  COMPLSPLT
                COMPLSPLT: u1,
                reserved31: u14,
                ///  SPLITEN
                SPLITEN: u1,
            }),
            ///  This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
            OTG_HCINT5: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  CHH
                CHH: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STALL
                STALL: u1,
                ///  NAK
                NAK: u1,
                ///  ACK
                ACK: u1,
                ///  NYET
                NYET: u1,
                ///  TXERR
                TXERR: u1,
                ///  BBERR
                BBERR: u1,
                ///  FRMOR
                FRMOR: u1,
                ///  DTERR
                DTERR: u1,
                ///  BNA
                BNA: u1,
                ///  XCSXACTERR
                XCSXACTERR: u1,
                ///  DESCLSTROLL
                DESCLSTROLL: u1,
                padding: u18,
            }),
            ///  This register reflects the mask for each channel status described in the previous section.
            OTG_HCINTMSK5: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  CHHM
                CHHM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STALLM
                STALLM: u1,
                ///  NAKM
                NAKM: u1,
                ///  ACKM
                ACKM: u1,
                ///  NYET
                NYET: u1,
                ///  TXERRM
                TXERRM: u1,
                ///  BBERRM
                BBERRM: u1,
                ///  FRMORM
                FRMORM: u1,
                ///  DTERRM
                DTERRM: u1,
                ///  BNAMSK
                BNAMSK: u1,
                reserved13: u1,
                ///  DESCLSTROLLMSK
                DESCLSTROLLMSK: u1,
                padding: u18,
            }),
            ///  OTG host channel 5 transfer size register
            OTG_HCTSIZ5: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  DPID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG host channel 5 DMA address register in buffer DMA [alternate]
            OTG_HCDMA5: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved1468: [4]u8,
            ///  OTG host channel-n DMA address buffer register
            OTG_HCDMAB5: mmio.Mmio(packed struct(u32) {
                ///  HCDMAB
                HCDMAB: u32,
            }),
            ///  OTG host channel 6 characteristics register
            OTG_HCCHAR6: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                ///  EPNUM
                EPNUM: u4,
                ///  EPDIR
                EPDIR: u1,
                reserved17: u1,
                ///  LSDEV
                LSDEV: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  MCNT
                MCNT: u2,
                ///  DAD
                DAD: u7,
                reserved30: u1,
                ///  CHDIS
                CHDIS: u1,
                ///  CHENA
                CHENA: u1,
            }),
            ///  OTG host channel 6 split control register
            OTG_HCSPLT6: mmio.Mmio(packed struct(u32) {
                ///  PRTADDR
                PRTADDR: u7,
                ///  HUBADDR
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  COMPLSPLT
                COMPLSPLT: u1,
                reserved31: u14,
                ///  SPLITEN
                SPLITEN: u1,
            }),
            ///  This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
            OTG_HCINT6: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  CHH
                CHH: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STALL
                STALL: u1,
                ///  NAK
                NAK: u1,
                ///  ACK
                ACK: u1,
                ///  NYET
                NYET: u1,
                ///  TXERR
                TXERR: u1,
                ///  BBERR
                BBERR: u1,
                ///  FRMOR
                FRMOR: u1,
                ///  DTERR
                DTERR: u1,
                ///  BNA
                BNA: u1,
                ///  XCSXACTERR
                XCSXACTERR: u1,
                ///  DESCLSTROLL
                DESCLSTROLL: u1,
                padding: u18,
            }),
            ///  This register reflects the mask for each channel status described in the previous section.
            OTG_HCINTMSK6: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  CHHM
                CHHM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STALLM
                STALLM: u1,
                ///  NAKM
                NAKM: u1,
                ///  ACKM
                ACKM: u1,
                ///  NYET
                NYET: u1,
                ///  TXERRM
                TXERRM: u1,
                ///  BBERRM
                BBERRM: u1,
                ///  FRMORM
                FRMORM: u1,
                ///  DTERRM
                DTERRM: u1,
                ///  BNAMSK
                BNAMSK: u1,
                reserved13: u1,
                ///  DESCLSTROLLMSK
                DESCLSTROLLMSK: u1,
                padding: u18,
            }),
            ///  OTG host channel 6 transfer size register
            OTG_HCTSIZ6: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  DPID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG host channel 6 DMA address register in buffer DMA [alternate]
            OTG_HCDMA6: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved1500: [4]u8,
            ///  OTG host channel-n DMA address buffer register
            OTG_HCDMAB6: mmio.Mmio(packed struct(u32) {
                ///  HCDMAB
                HCDMAB: u32,
            }),
            ///  OTG host channel 7 characteristics register
            OTG_HCCHAR7: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                ///  EPNUM
                EPNUM: u4,
                ///  EPDIR
                EPDIR: u1,
                reserved17: u1,
                ///  LSDEV
                LSDEV: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  MCNT
                MCNT: u2,
                ///  DAD
                DAD: u7,
                reserved30: u1,
                ///  CHDIS
                CHDIS: u1,
                ///  CHENA
                CHENA: u1,
            }),
            ///  OTG host channel 7 split control register
            OTG_HCSPLT7: mmio.Mmio(packed struct(u32) {
                ///  PRTADDR
                PRTADDR: u7,
                ///  HUBADDR
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  COMPLSPLT
                COMPLSPLT: u1,
                reserved31: u14,
                ///  SPLITEN
                SPLITEN: u1,
            }),
            ///  This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
            OTG_HCINT7: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  CHH
                CHH: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STALL
                STALL: u1,
                ///  NAK
                NAK: u1,
                ///  ACK
                ACK: u1,
                ///  NYET
                NYET: u1,
                ///  TXERR
                TXERR: u1,
                ///  BBERR
                BBERR: u1,
                ///  FRMOR
                FRMOR: u1,
                ///  DTERR
                DTERR: u1,
                ///  BNA
                BNA: u1,
                ///  XCSXACTERR
                XCSXACTERR: u1,
                ///  DESCLSTROLL
                DESCLSTROLL: u1,
                padding: u18,
            }),
            ///  This register reflects the mask for each channel status described in the previous section.
            OTG_HCINTMSK7: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  CHHM
                CHHM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STALLM
                STALLM: u1,
                ///  NAKM
                NAKM: u1,
                ///  ACKM
                ACKM: u1,
                ///  NYET
                NYET: u1,
                ///  TXERRM
                TXERRM: u1,
                ///  BBERRM
                BBERRM: u1,
                ///  FRMORM
                FRMORM: u1,
                ///  DTERRM
                DTERRM: u1,
                ///  BNAMSK
                BNAMSK: u1,
                reserved13: u1,
                ///  DESCLSTROLLMSK
                DESCLSTROLLMSK: u1,
                padding: u18,
            }),
            ///  OTG host channel 7 transfer size register
            OTG_HCTSIZ7: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  DPID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG host channel 7 DMA address register in buffer DMA [alternate]
            OTG_HCDMA7: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved1532: [4]u8,
            ///  OTG host channel-n DMA address buffer register
            OTG_HCDMAB7: mmio.Mmio(packed struct(u32) {
                ///  HCDMAB
                HCDMAB: u32,
            }),
            ///  OTG host channel 8 characteristics register
            OTG_HCCHAR8: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                ///  EPNUM
                EPNUM: u4,
                ///  EPDIR
                EPDIR: u1,
                reserved17: u1,
                ///  LSDEV
                LSDEV: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  MCNT
                MCNT: u2,
                ///  DAD
                DAD: u7,
                reserved30: u1,
                ///  CHDIS
                CHDIS: u1,
                ///  CHENA
                CHENA: u1,
            }),
            ///  OTG host channel 8 split control register
            OTG_HCSPLT8: mmio.Mmio(packed struct(u32) {
                ///  PRTADDR
                PRTADDR: u7,
                ///  HUBADDR
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  COMPLSPLT
                COMPLSPLT: u1,
                reserved31: u14,
                ///  SPLITEN
                SPLITEN: u1,
            }),
            ///  This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
            OTG_HCINT8: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  CHH
                CHH: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STALL
                STALL: u1,
                ///  NAK
                NAK: u1,
                ///  ACK
                ACK: u1,
                ///  NYET
                NYET: u1,
                ///  TXERR
                TXERR: u1,
                ///  BBERR
                BBERR: u1,
                ///  FRMOR
                FRMOR: u1,
                ///  DTERR
                DTERR: u1,
                ///  BNA
                BNA: u1,
                ///  XCSXACTERR
                XCSXACTERR: u1,
                ///  DESCLSTROLL
                DESCLSTROLL: u1,
                padding: u18,
            }),
            ///  This register reflects the mask for each channel status described in the previous section.
            OTG_HCINTMSK8: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  CHHM
                CHHM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STALLM
                STALLM: u1,
                ///  NAKM
                NAKM: u1,
                ///  ACKM
                ACKM: u1,
                ///  NYET
                NYET: u1,
                ///  TXERRM
                TXERRM: u1,
                ///  BBERRM
                BBERRM: u1,
                ///  FRMORM
                FRMORM: u1,
                ///  DTERRM
                DTERRM: u1,
                ///  BNAMSK
                BNAMSK: u1,
                reserved13: u1,
                ///  DESCLSTROLLMSK
                DESCLSTROLLMSK: u1,
                padding: u18,
            }),
            ///  OTG host channel 8 transfer size register
            OTG_HCTSIZ8: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  DPID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG host channel 8 DMA address register in buffer DMA [alternate]
            OTG_HCDMA8: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved1564: [4]u8,
            ///  OTG host channel-n DMA address buffer register
            OTG_HCDMAB8: mmio.Mmio(packed struct(u32) {
                ///  HCDMAB
                HCDMAB: u32,
            }),
            ///  OTG host channel 9 characteristics register
            OTG_HCCHAR9: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                ///  EPNUM
                EPNUM: u4,
                ///  EPDIR
                EPDIR: u1,
                reserved17: u1,
                ///  LSDEV
                LSDEV: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  MCNT
                MCNT: u2,
                ///  DAD
                DAD: u7,
                reserved30: u1,
                ///  CHDIS
                CHDIS: u1,
                ///  CHENA
                CHENA: u1,
            }),
            ///  OTG host channel 9 split control register
            OTG_HCSPLT9: mmio.Mmio(packed struct(u32) {
                ///  PRTADDR
                PRTADDR: u7,
                ///  HUBADDR
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  COMPLSPLT
                COMPLSPLT: u1,
                reserved31: u14,
                ///  SPLITEN
                SPLITEN: u1,
            }),
            ///  This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
            OTG_HCINT9: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  CHH
                CHH: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STALL
                STALL: u1,
                ///  NAK
                NAK: u1,
                ///  ACK
                ACK: u1,
                ///  NYET
                NYET: u1,
                ///  TXERR
                TXERR: u1,
                ///  BBERR
                BBERR: u1,
                ///  FRMOR
                FRMOR: u1,
                ///  DTERR
                DTERR: u1,
                ///  BNA
                BNA: u1,
                ///  XCSXACTERR
                XCSXACTERR: u1,
                ///  DESCLSTROLL
                DESCLSTROLL: u1,
                padding: u18,
            }),
            ///  This register reflects the mask for each channel status described in the previous section.
            OTG_HCINTMSK9: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  CHHM
                CHHM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STALLM
                STALLM: u1,
                ///  NAKM
                NAKM: u1,
                ///  ACKM
                ACKM: u1,
                ///  NYET
                NYET: u1,
                ///  TXERRM
                TXERRM: u1,
                ///  BBERRM
                BBERRM: u1,
                ///  FRMORM
                FRMORM: u1,
                ///  DTERRM
                DTERRM: u1,
                ///  BNAMSK
                BNAMSK: u1,
                reserved13: u1,
                ///  DESCLSTROLLMSK
                DESCLSTROLLMSK: u1,
                padding: u18,
            }),
            ///  OTG host channel 9 transfer size register
            OTG_HCTSIZ9: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  DPID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG host channel 9 DMA address register in buffer DMA [alternate]
            OTG_HCDMA9: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved1596: [4]u8,
            ///  OTG host channel-n DMA address buffer register
            OTG_HCDMAB9: mmio.Mmio(packed struct(u32) {
                ///  HCDMAB
                HCDMAB: u32,
            }),
            ///  OTG host channel 10 characteristics register
            OTG_HCCHAR10: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                ///  EPNUM
                EPNUM: u4,
                ///  EPDIR
                EPDIR: u1,
                reserved17: u1,
                ///  LSDEV
                LSDEV: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  MCNT
                MCNT: u2,
                ///  DAD
                DAD: u7,
                reserved30: u1,
                ///  CHDIS
                CHDIS: u1,
                ///  CHENA
                CHENA: u1,
            }),
            ///  OTG host channel 10 split control register
            OTG_HCSPLT10: mmio.Mmio(packed struct(u32) {
                ///  PRTADDR
                PRTADDR: u7,
                ///  HUBADDR
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  COMPLSPLT
                COMPLSPLT: u1,
                reserved31: u14,
                ///  SPLITEN
                SPLITEN: u1,
            }),
            ///  This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
            OTG_HCINT10: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  CHH
                CHH: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STALL
                STALL: u1,
                ///  NAK
                NAK: u1,
                ///  ACK
                ACK: u1,
                ///  NYET
                NYET: u1,
                ///  TXERR
                TXERR: u1,
                ///  BBERR
                BBERR: u1,
                ///  FRMOR
                FRMOR: u1,
                ///  DTERR
                DTERR: u1,
                ///  BNA
                BNA: u1,
                ///  XCSXACTERR
                XCSXACTERR: u1,
                ///  DESCLSTROLL
                DESCLSTROLL: u1,
                padding: u18,
            }),
            ///  This register reflects the mask for each channel status described in the previous section.
            OTG_HCINTMSK10: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  CHHM
                CHHM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STALLM
                STALLM: u1,
                ///  NAKM
                NAKM: u1,
                ///  ACKM
                ACKM: u1,
                ///  NYET
                NYET: u1,
                ///  TXERRM
                TXERRM: u1,
                ///  BBERRM
                BBERRM: u1,
                ///  FRMORM
                FRMORM: u1,
                ///  DTERRM
                DTERRM: u1,
                ///  BNAMSK
                BNAMSK: u1,
                reserved13: u1,
                ///  DESCLSTROLLMSK
                DESCLSTROLLMSK: u1,
                padding: u18,
            }),
            ///  OTG host channel 10 transfer size register
            OTG_HCTSIZ10: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  DPID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG host channel 10 DMA address register in buffer DMA [alternate]
            OTG_HCDMA10: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved1628: [4]u8,
            ///  OTG host channel-n DMA address buffer register
            OTG_HCDMAB10: mmio.Mmio(packed struct(u32) {
                ///  HCDMAB
                HCDMAB: u32,
            }),
            ///  OTG host channel 11 characteristics register
            OTG_HCCHAR11: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                ///  EPNUM
                EPNUM: u4,
                ///  EPDIR
                EPDIR: u1,
                reserved17: u1,
                ///  LSDEV
                LSDEV: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  MCNT
                MCNT: u2,
                ///  DAD
                DAD: u7,
                reserved30: u1,
                ///  CHDIS
                CHDIS: u1,
                ///  CHENA
                CHENA: u1,
            }),
            ///  OTG host channel 11 split control register
            OTG_HCSPLT11: mmio.Mmio(packed struct(u32) {
                ///  PRTADDR
                PRTADDR: u7,
                ///  HUBADDR
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  COMPLSPLT
                COMPLSPLT: u1,
                reserved31: u14,
                ///  SPLITEN
                SPLITEN: u1,
            }),
            ///  This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
            OTG_HCINT11: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  CHH
                CHH: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STALL
                STALL: u1,
                ///  NAK
                NAK: u1,
                ///  ACK
                ACK: u1,
                ///  NYET
                NYET: u1,
                ///  TXERR
                TXERR: u1,
                ///  BBERR
                BBERR: u1,
                ///  FRMOR
                FRMOR: u1,
                ///  DTERR
                DTERR: u1,
                ///  BNA
                BNA: u1,
                ///  XCSXACTERR
                XCSXACTERR: u1,
                ///  DESCLSTROLL
                DESCLSTROLL: u1,
                padding: u18,
            }),
            ///  This register reflects the mask for each channel status described in the previous section.
            OTG_HCINTMSK11: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  CHHM
                CHHM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STALLM
                STALLM: u1,
                ///  NAKM
                NAKM: u1,
                ///  ACKM
                ACKM: u1,
                ///  NYET
                NYET: u1,
                ///  TXERRM
                TXERRM: u1,
                ///  BBERRM
                BBERRM: u1,
                ///  FRMORM
                FRMORM: u1,
                ///  DTERRM
                DTERRM: u1,
                ///  BNAMSK
                BNAMSK: u1,
                reserved13: u1,
                ///  DESCLSTROLLMSK
                DESCLSTROLLMSK: u1,
                padding: u18,
            }),
            ///  OTG host channel 11 transfer size register
            OTG_HCTSIZ11: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  DPID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG host channel 11 DMA address register in buffer DMA [alternate]
            OTG_HCDMA11: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved1660: [4]u8,
            ///  OTG host channel-n DMA address buffer register
            OTG_HCDMAB11: mmio.Mmio(packed struct(u32) {
                ///  HCDMAB
                HCDMAB: u32,
            }),
            ///  OTG host channel 12 characteristics register
            OTG_HCCHAR12: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                ///  EPNUM
                EPNUM: u4,
                ///  EPDIR
                EPDIR: u1,
                reserved17: u1,
                ///  LSDEV
                LSDEV: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  MCNT
                MCNT: u2,
                ///  DAD
                DAD: u7,
                reserved30: u1,
                ///  CHDIS
                CHDIS: u1,
                ///  CHENA
                CHENA: u1,
            }),
            ///  OTG host channel 12 split control register
            OTG_HCSPLT12: mmio.Mmio(packed struct(u32) {
                ///  PRTADDR
                PRTADDR: u7,
                ///  HUBADDR
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  COMPLSPLT
                COMPLSPLT: u1,
                reserved31: u14,
                ///  SPLITEN
                SPLITEN: u1,
            }),
            ///  This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
            OTG_HCINT12: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  CHH
                CHH: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STALL
                STALL: u1,
                ///  NAK
                NAK: u1,
                ///  ACK
                ACK: u1,
                ///  NYET
                NYET: u1,
                ///  TXERR
                TXERR: u1,
                ///  BBERR
                BBERR: u1,
                ///  FRMOR
                FRMOR: u1,
                ///  DTERR
                DTERR: u1,
                ///  BNA
                BNA: u1,
                ///  XCSXACTERR
                XCSXACTERR: u1,
                ///  DESCLSTROLL
                DESCLSTROLL: u1,
                padding: u18,
            }),
            ///  This register reflects the mask for each channel status described in the previous section.
            OTG_HCINTMSK12: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  CHHM
                CHHM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STALLM
                STALLM: u1,
                ///  NAKM
                NAKM: u1,
                ///  ACKM
                ACKM: u1,
                ///  NYET
                NYET: u1,
                ///  TXERRM
                TXERRM: u1,
                ///  BBERRM
                BBERRM: u1,
                ///  FRMORM
                FRMORM: u1,
                ///  DTERRM
                DTERRM: u1,
                ///  BNAMSK
                BNAMSK: u1,
                reserved13: u1,
                ///  DESCLSTROLLMSK
                DESCLSTROLLMSK: u1,
                padding: u18,
            }),
            ///  OTG host channel 12 transfer size register
            OTG_HCTSIZ12: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  DPID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG host channel 12 DMA address register in buffer DMA [alternate]
            OTG_HCDMA12: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved1692: [4]u8,
            ///  OTG host channel-n DMA address buffer register
            OTG_HCDMAB12: mmio.Mmio(packed struct(u32) {
                ///  HCDMAB
                HCDMAB: u32,
            }),
            ///  OTG host channel 13 characteristics register
            OTG_HCCHAR13: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                ///  EPNUM
                EPNUM: u4,
                ///  EPDIR
                EPDIR: u1,
                reserved17: u1,
                ///  LSDEV
                LSDEV: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  MCNT
                MCNT: u2,
                ///  DAD
                DAD: u7,
                reserved30: u1,
                ///  CHDIS
                CHDIS: u1,
                ///  CHENA
                CHENA: u1,
            }),
            ///  OTG host channel 13 split control register
            OTG_HCSPLT13: mmio.Mmio(packed struct(u32) {
                ///  PRTADDR
                PRTADDR: u7,
                ///  HUBADDR
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  COMPLSPLT
                COMPLSPLT: u1,
                reserved31: u14,
                ///  SPLITEN
                SPLITEN: u1,
            }),
            ///  This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
            OTG_HCINT13: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  CHH
                CHH: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STALL
                STALL: u1,
                ///  NAK
                NAK: u1,
                ///  ACK
                ACK: u1,
                ///  NYET
                NYET: u1,
                ///  TXERR
                TXERR: u1,
                ///  BBERR
                BBERR: u1,
                ///  FRMOR
                FRMOR: u1,
                ///  DTERR
                DTERR: u1,
                ///  BNA
                BNA: u1,
                ///  XCSXACTERR
                XCSXACTERR: u1,
                ///  DESCLSTROLL
                DESCLSTROLL: u1,
                padding: u18,
            }),
            ///  This register reflects the mask for each channel status described in the previous section.
            OTG_HCINTMSK13: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  CHHM
                CHHM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STALLM
                STALLM: u1,
                ///  NAKM
                NAKM: u1,
                ///  ACKM
                ACKM: u1,
                ///  NYET
                NYET: u1,
                ///  TXERRM
                TXERRM: u1,
                ///  BBERRM
                BBERRM: u1,
                ///  FRMORM
                FRMORM: u1,
                ///  DTERRM
                DTERRM: u1,
                ///  BNAMSK
                BNAMSK: u1,
                reserved13: u1,
                ///  DESCLSTROLLMSK
                DESCLSTROLLMSK: u1,
                padding: u18,
            }),
            ///  OTG host channel 13 transfer size register
            OTG_HCTSIZ13: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  DPID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG host channel 13 DMA address register in buffer DMA [alternate]
            OTG_HCDMA13: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved1724: [4]u8,
            ///  OTG host channel-n DMA address buffer register
            OTG_HCDMAB13: mmio.Mmio(packed struct(u32) {
                ///  HCDMAB
                HCDMAB: u32,
            }),
            ///  OTG host channel 14 characteristics register
            OTG_HCCHAR14: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                ///  EPNUM
                EPNUM: u4,
                ///  EPDIR
                EPDIR: u1,
                reserved17: u1,
                ///  LSDEV
                LSDEV: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  MCNT
                MCNT: u2,
                ///  DAD
                DAD: u7,
                reserved30: u1,
                ///  CHDIS
                CHDIS: u1,
                ///  CHENA
                CHENA: u1,
            }),
            ///  OTG host channel 14 split control register
            OTG_HCSPLT14: mmio.Mmio(packed struct(u32) {
                ///  PRTADDR
                PRTADDR: u7,
                ///  HUBADDR
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  COMPLSPLT
                COMPLSPLT: u1,
                reserved31: u14,
                ///  SPLITEN
                SPLITEN: u1,
            }),
            ///  This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
            OTG_HCINT14: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  CHH
                CHH: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STALL
                STALL: u1,
                ///  NAK
                NAK: u1,
                ///  ACK
                ACK: u1,
                ///  NYET
                NYET: u1,
                ///  TXERR
                TXERR: u1,
                ///  BBERR
                BBERR: u1,
                ///  FRMOR
                FRMOR: u1,
                ///  DTERR
                DTERR: u1,
                ///  BNA
                BNA: u1,
                ///  XCSXACTERR
                XCSXACTERR: u1,
                ///  DESCLSTROLL
                DESCLSTROLL: u1,
                padding: u18,
            }),
            ///  This register reflects the mask for each channel status described in the previous section.
            OTG_HCINTMSK14: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  CHHM
                CHHM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STALLM
                STALLM: u1,
                ///  NAKM
                NAKM: u1,
                ///  ACKM
                ACKM: u1,
                ///  NYET
                NYET: u1,
                ///  TXERRM
                TXERRM: u1,
                ///  BBERRM
                BBERRM: u1,
                ///  FRMORM
                FRMORM: u1,
                ///  DTERRM
                DTERRM: u1,
                ///  BNAMSK
                BNAMSK: u1,
                reserved13: u1,
                ///  DESCLSTROLLMSK
                DESCLSTROLLMSK: u1,
                padding: u18,
            }),
            ///  OTG host channel 14 transfer size register
            OTG_HCTSIZ14: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  DPID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG host channel 14 DMA address register in buffer DMA [alternate]
            OTG_HCDMA14: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved1756: [4]u8,
            ///  OTG host channel-n DMA address buffer register
            OTG_HCDMAB14: mmio.Mmio(packed struct(u32) {
                ///  HCDMAB
                HCDMAB: u32,
            }),
            ///  OTG host channel 15 characteristics register
            OTG_HCCHAR15: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                ///  EPNUM
                EPNUM: u4,
                ///  EPDIR
                EPDIR: u1,
                reserved17: u1,
                ///  LSDEV
                LSDEV: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  MCNT
                MCNT: u2,
                ///  DAD
                DAD: u7,
                reserved30: u1,
                ///  CHDIS
                CHDIS: u1,
                ///  CHENA
                CHENA: u1,
            }),
            ///  OTG host channel 15 split control register
            OTG_HCSPLT15: mmio.Mmio(packed struct(u32) {
                ///  PRTADDR
                PRTADDR: u7,
                ///  HUBADDR
                HUBADDR: u7,
                ///  XACTPOS
                XACTPOS: u2,
                ///  COMPLSPLT
                COMPLSPLT: u1,
                reserved31: u14,
                ///  SPLITEN
                SPLITEN: u1,
            }),
            ///  This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_HAINT and OTG_GINTSTS registers.
            OTG_HCINT15: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  CHH
                CHH: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STALL
                STALL: u1,
                ///  NAK
                NAK: u1,
                ///  ACK
                ACK: u1,
                ///  NYET
                NYET: u1,
                ///  TXERR
                TXERR: u1,
                ///  BBERR
                BBERR: u1,
                ///  FRMOR
                FRMOR: u1,
                ///  DTERR
                DTERR: u1,
                ///  BNA
                BNA: u1,
                ///  XCSXACTERR
                XCSXACTERR: u1,
                ///  DESCLSTROLL
                DESCLSTROLL: u1,
                padding: u18,
            }),
            ///  This register reflects the mask for each channel status described in the previous section.
            OTG_HCINTMSK15: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  CHHM
                CHHM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STALLM
                STALLM: u1,
                ///  NAKM
                NAKM: u1,
                ///  ACKM
                ACKM: u1,
                ///  NYET
                NYET: u1,
                ///  TXERRM
                TXERRM: u1,
                ///  BBERRM
                BBERRM: u1,
                ///  FRMORM
                FRMORM: u1,
                ///  DTERRM
                DTERRM: u1,
                ///  BNAMSK
                BNAMSK: u1,
                reserved13: u1,
                ///  DESCLSTROLLMSK
                DESCLSTROLLMSK: u1,
                padding: u18,
            }),
            ///  OTG host channel 15 transfer size register
            OTG_HCTSIZ15: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  DPID
                DPID: u2,
                padding: u1,
            }),
            ///  OTG host channel 15 DMA address register in buffer DMA [alternate]
            OTG_HCDMA15: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved1788: [4]u8,
            ///  OTG host channel-n DMA address buffer register
            OTG_HCDMAB15: mmio.Mmio(packed struct(u32) {
                ///  HCDMAB
                HCDMAB: u32,
            }),
            reserved2048: [256]u8,
            ///  This register configures the core in device mode after power-on or after certain control commands or enumeration. Do not make changes to this register after initial programming.
            OTG_DCFG: mmio.Mmio(packed struct(u32) {
                ///  DSPD
                DSPD: u2,
                ///  NZLSOHSK
                NZLSOHSK: u1,
                reserved4: u1,
                ///  DAD
                DAD: u7,
                ///  PFIVL
                PFIVL: u2,
                reserved14: u1,
                ///  XCVRDLY
                XCVRDLY: u1,
                ///  ERRATIM
                ERRATIM: u1,
                reserved24: u8,
                ///  PERSCHIVL
                PERSCHIVL: u2,
                padding: u6,
            }),
            ///  OTG device control register
            OTG_DCTL: mmio.Mmio(packed struct(u32) {
                ///  RWUSIG
                RWUSIG: u1,
                ///  SDIS
                SDIS: u1,
                ///  GINSTS
                GINSTS: u1,
                ///  GONSTS
                GONSTS: u1,
                ///  TCTL
                TCTL: u3,
                ///  SGINAK
                SGINAK: u1,
                ///  CGINAK
                CGINAK: u1,
                ///  SGONAK
                SGONAK: u1,
                ///  CGONAK
                CGONAK: u1,
                ///  POPRGDNE
                POPRGDNE: u1,
                reserved18: u6,
                ///  DSBESLRJCT
                DSBESLRJCT: u1,
                padding: u13,
            }),
            ///  This register indicates the status of the core with respect to USB-related events. It must be read on interrupts from the device all interrupts (OTG_DAINT) register.
            OTG_DSTS: mmio.Mmio(packed struct(u32) {
                ///  SUSPSTS
                SUSPSTS: u1,
                ///  ENUMSPD
                ENUMSPD: u2,
                ///  EERR
                EERR: u1,
                reserved8: u4,
                ///  FNSOF
                FNSOF: u14,
                ///  DEVLNSTS
                DEVLNSTS: u2,
                padding: u8,
            }),
            reserved2064: [4]u8,
            ///  This register works with each of the OTG_DIEPINTx registers for all endpoints to generate an interrupt per IN endpoint. The IN endpoint interrupt for a specific status in the OTG_DIEPINTx register can be masked by writing to the corresponding bit in this register. Status bits are masked by default.
            OTG_DIEPMSK: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  EPDM
                EPDM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  TOM
                TOM: u1,
                ///  ITTXFEMSK
                ITTXFEMSK: u1,
                ///  INEPNMM
                INEPNMM: u1,
                ///  INEPNEM
                INEPNEM: u1,
                reserved8: u1,
                ///  TXFURM
                TXFURM: u1,
                ///  BNAM
                BNAM: u1,
                reserved13: u3,
                ///  NAKM
                NAKM: u1,
                padding: u18,
            }),
            ///  This register works with each of the OTG_DOEPINTx registers for all endpoints to generate an interrupt per OUT endpoint. The OUT endpoint interrupt for a specific status in the OTG_DOEPINTx register can be masked by writing into the corresponding bit in this register. Status bits are masked by default.
            OTG_DOEPMSK: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  EPDM
                EPDM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STUPM
                STUPM: u1,
                ///  OTEPDM
                OTEPDM: u1,
                ///  STSPHSRXM
                STSPHSRXM: u1,
                ///  B2BSTUPM
                B2BSTUPM: u1,
                reserved8: u1,
                ///  OUTPKTERRM
                OUTPKTERRM: u1,
                ///  BNAM
                BNAM: u1,
                reserved12: u2,
                ///  BERRM
                BERRM: u1,
                ///  NAKMSK
                NAKMSK: u1,
                ///  NYETMSK
                NYETMSK: u1,
                padding: u17,
            }),
            ///  When a significant event occurs on an endpoint, a OTG_DAINT register interrupts the application using the device OUT endpoints interrupt bit or device IN endpoints interrupt bit of the OTG_GINTSTS register (OEPINT or IEPINT in OTG_GINTSTS, respectively). There is one interrupt bit per endpoint, up to a maximum of 16 bits for OUT endpoints and 16 bits for IN endpoints. For a bidirectional endpoint, the corresponding IN and OUT interrupt bits are used. Bits in this register are set and cleared when the application sets and clears bits in the corresponding device endpoint-x interrupt register (OTG_DIEPINTx/OTG_DOEPINTx).
            OTG_DAINT: mmio.Mmio(packed struct(u32) {
                ///  IEPINT
                IEPINT: u16,
                ///  OEPINT
                OEPINT: u16,
            }),
            ///  The OTG_DAINTMSK register works with the device endpoint interrupt register to interrupt the application when an event occurs on a device endpoint. However, the OTG_DAINT register bit corresponding to that interrupt is still set.
            OTG_DAINTMSK: mmio.Mmio(packed struct(u32) {
                ///  IEPM
                IEPM: u16,
                ///  OEPM
                OEPM: u16,
            }),
            reserved2088: [8]u8,
            ///  This register specifies the VBUS discharge time after VBUS pulsing during SRP.
            OTG_DVBUSDIS: mmio.Mmio(packed struct(u32) {
                ///  VBUSDT
                VBUSDT: u16,
                padding: u16,
            }),
            ///  This register specifies the VBUS pulsing time during SRP.
            OTG_DVBUSPULSE: mmio.Mmio(packed struct(u32) {
                ///  DVBUSP
                DVBUSP: u16,
                padding: u16,
            }),
            ///  OTG device threshold control register
            OTG_DTHRCTL: mmio.Mmio(packed struct(u32) {
                ///  NONISOTHREN
                NONISOTHREN: u1,
                ///  ISOTHREN
                ISOTHREN: u1,
                ///  TXTHRLEN
                TXTHRLEN: u9,
                reserved16: u5,
                ///  RXTHREN
                RXTHREN: u1,
                ///  RXTHRLEN
                RXTHRLEN: u9,
                reserved27: u1,
                ///  ARPEN
                ARPEN: u1,
                padding: u4,
            }),
            ///  This register is used to control the IN endpoint FIFO empty interrupt generation (TXFE_OTG_DIEPINTx).
            OTG_DIEPEMPMSK: mmio.Mmio(packed struct(u32) {
                ///  INEPTXFEM
                INEPTXFEM: u16,
                padding: u16,
            }),
            ///  OTG device each endpoint interrupt register
            OTG_DEACHINT: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  IEP1INT
                IEP1INT: u1,
                reserved17: u15,
                ///  OEP1INT
                OEP1INT: u1,
                padding: u14,
            }),
            ///  There is one interrupt bit for endpoint 1 IN and one interrupt bit for endpoint 1 OUT.
            OTG_DEACHINTMSK: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  IEP1INTM
                IEP1INTM: u1,
                reserved17: u15,
                ///  OEP1INTM
                OEP1INTM: u1,
                padding: u14,
            }),
            reserved2116: [4]u8,
            ///  This register works with the OTG_DIEPINT1 register to generate a dedicated interrupt OTG_HS_EP1_IN for endpoint #1. The IN endpoint interrupt for a specific status in the OTG_DOEPINT1 register can be masked by writing into the corresponding bit in this register. Status bits are masked by default.
            OTG_HS_DIEPEACHMSK1: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  EPDM
                EPDM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  TOM
                TOM: u1,
                ///  ITTXFEMSK
                ITTXFEMSK: u1,
                reserved6: u1,
                ///  INEPNEM
                INEPNEM: u1,
                reserved8: u1,
                ///  TXFURM
                TXFURM: u1,
                ///  BNAM
                BNAM: u1,
                reserved13: u3,
                ///  NAKM
                NAKM: u1,
                padding: u18,
            }),
            reserved2180: [60]u8,
            ///  This register works with the OTG_DOEPINT1 register to generate a dedicated interrupt OTG_HS_EP1_OUT for endpoint #1. The OUT endpoint interrupt for a specific status in the OTG_DOEPINT1 register can be masked by writing into the corresponding bit in this register. Status bits are masked by default.
            OTG_HS_DOEPEACHMSK1: mmio.Mmio(packed struct(u32) {
                ///  XFRCM
                XFRCM: u1,
                ///  EPDM
                EPDM: u1,
                ///  AHBERRM
                AHBERRM: u1,
                ///  STUPM
                STUPM: u1,
                ///  OTEPDM
                OTEPDM: u1,
                reserved6: u1,
                ///  B2BSTUPM
                B2BSTUPM: u1,
                reserved8: u1,
                ///  OUTPKTERRM
                OUTPKTERRM: u1,
                ///  BNAM
                BNAM: u1,
                reserved12: u2,
                ///  BERRM
                BERRM: u1,
                ///  NAKMSK
                NAKMSK: u1,
                ///  NYETMSK
                NYETMSK: u1,
                padding: u17,
            }),
            reserved2304: [120]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DIEPCTL0: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                reserved21: u1,
                ///  STALL
                STALL: u1,
                ///  TXFNUM
                TXFNUM: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SODDFRM
                SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved2312: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DIEPINT0: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  TOC
                TOC: u1,
                ///  ITTXFE
                ITTXFE: u1,
                ///  INEPNM
                INEPNM: u1,
                ///  INEPNE
                INEPNE: u1,
                ///  TXFE
                TXFE: u1,
                ///  TXFIFOUDRN
                TXFIFOUDRN: u1,
                ///  BNA
                BNA: u1,
                reserved11: u1,
                ///  PKTDRPSTS
                PKTDRPSTS: u1,
                reserved13: u1,
                ///  NAK
                NAK: u1,
                padding: u18,
            }),
            reserved2320: [4]u8,
            ///  The application must modify this register before enabling endpoint 0.
            OTG_DIEPTSIZ0: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u7,
                reserved19: u12,
                ///  PKTCNT
                PKTCNT: u2,
                padding: u11,
            }),
            ///  OTG device IN endpoint 0 DMA address register
            OTG_DIEPDMA0: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            ///  This read-only register contains the free space information for the device IN endpoint Tx FIFO.
            OTG_DTXFSTS0: mmio.Mmio(packed struct(u32) {
                ///  INEPTFSAV
                INEPTFSAV: u16,
                padding: u16,
            }),
            reserved2336: [4]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DIEPCTL1: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                reserved21: u1,
                ///  STALL
                STALL: u1,
                ///  TXFNUM
                TXFNUM: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SODDFRM
                SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved2344: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DIEPINT1: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  TOC
                TOC: u1,
                ///  ITTXFE
                ITTXFE: u1,
                ///  INEPNM
                INEPNM: u1,
                ///  INEPNE
                INEPNE: u1,
                ///  TXFE
                TXFE: u1,
                ///  TXFIFOUDRN
                TXFIFOUDRN: u1,
                ///  BNA
                BNA: u1,
                reserved11: u1,
                ///  PKTDRPSTS
                PKTDRPSTS: u1,
                reserved13: u1,
                ///  NAK
                NAK: u1,
                padding: u18,
            }),
            reserved2352: [4]u8,
            ///  The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the endpoint enable bit in the OTG_DIEPCTLx registers (EPENA bit in OTG_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
            OTG_DIEPTSIZ1: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  MCNT
                MCNT: u2,
                padding: u1,
            }),
            ///  OTG device IN endpoint 1 DMA address register
            OTG_DIEPDMA1: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            ///  This read-only register contains the free space information for the device IN endpoint Tx FIFO.
            OTG_DTXFSTS1: mmio.Mmio(packed struct(u32) {
                ///  INEPTFSAV
                INEPTFSAV: u16,
                padding: u16,
            }),
            reserved2368: [4]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DIEPCTL2: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                reserved21: u1,
                ///  STALL
                STALL: u1,
                ///  TXFNUM
                TXFNUM: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SODDFRM
                SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved2376: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DIEPINT2: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  TOC
                TOC: u1,
                ///  ITTXFE
                ITTXFE: u1,
                ///  INEPNM
                INEPNM: u1,
                ///  INEPNE
                INEPNE: u1,
                ///  TXFE
                TXFE: u1,
                ///  TXFIFOUDRN
                TXFIFOUDRN: u1,
                ///  BNA
                BNA: u1,
                reserved11: u1,
                ///  PKTDRPSTS
                PKTDRPSTS: u1,
                reserved13: u1,
                ///  NAK
                NAK: u1,
                padding: u18,
            }),
            reserved2384: [4]u8,
            ///  The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the endpoint enable bit in the OTG_DIEPCTLx registers (EPENA bit in OTG_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
            OTG_DIEPTSIZ2: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  MCNT
                MCNT: u2,
                padding: u1,
            }),
            ///  OTG device IN endpoint 2 DMA address register
            OTG_DIEPDMA2: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            ///  This read-only register contains the free space information for the device IN endpoint Tx FIFO.
            OTG_DTXFSTS2: mmio.Mmio(packed struct(u32) {
                ///  INEPTFSAV
                INEPTFSAV: u16,
                padding: u16,
            }),
            reserved2400: [4]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DIEPCTL3: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                reserved21: u1,
                ///  STALL
                STALL: u1,
                ///  TXFNUM
                TXFNUM: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SODDFRM
                SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved2408: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DIEPINT3: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  TOC
                TOC: u1,
                ///  ITTXFE
                ITTXFE: u1,
                ///  INEPNM
                INEPNM: u1,
                ///  INEPNE
                INEPNE: u1,
                ///  TXFE
                TXFE: u1,
                ///  TXFIFOUDRN
                TXFIFOUDRN: u1,
                ///  BNA
                BNA: u1,
                reserved11: u1,
                ///  PKTDRPSTS
                PKTDRPSTS: u1,
                reserved13: u1,
                ///  NAK
                NAK: u1,
                padding: u18,
            }),
            reserved2416: [4]u8,
            ///  The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the endpoint enable bit in the OTG_DIEPCTLx registers (EPENA bit in OTG_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
            OTG_DIEPTSIZ3: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  MCNT
                MCNT: u2,
                padding: u1,
            }),
            ///  OTG device IN endpoint 3 DMA address register
            OTG_DIEPDMA3: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            ///  This read-only register contains the free space information for the device IN endpoint Tx FIFO.
            OTG_DTXFSTS3: mmio.Mmio(packed struct(u32) {
                ///  INEPTFSAV
                INEPTFSAV: u16,
                padding: u16,
            }),
            reserved2432: [4]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DIEPCTL4: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                reserved21: u1,
                ///  STALL
                STALL: u1,
                ///  TXFNUM
                TXFNUM: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SODDFRM
                SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved2440: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DIEPINT4: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  TOC
                TOC: u1,
                ///  ITTXFE
                ITTXFE: u1,
                ///  INEPNM
                INEPNM: u1,
                ///  INEPNE
                INEPNE: u1,
                ///  TXFE
                TXFE: u1,
                ///  TXFIFOUDRN
                TXFIFOUDRN: u1,
                ///  BNA
                BNA: u1,
                reserved11: u1,
                ///  PKTDRPSTS
                PKTDRPSTS: u1,
                reserved13: u1,
                ///  NAK
                NAK: u1,
                padding: u18,
            }),
            reserved2448: [4]u8,
            ///  The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the endpoint enable bit in the OTG_DIEPCTLx registers (EPENA bit in OTG_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
            OTG_DIEPTSIZ4: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  MCNT
                MCNT: u2,
                padding: u1,
            }),
            ///  OTG device IN endpoint 4 DMA address register
            OTG_DIEPDMA4: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            ///  This read-only register contains the free space information for the device IN endpoint Tx FIFO.
            OTG_DTXFSTS4: mmio.Mmio(packed struct(u32) {
                ///  INEPTFSAV
                INEPTFSAV: u16,
                padding: u16,
            }),
            reserved2464: [4]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DIEPCTL5: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                reserved21: u1,
                ///  STALL
                STALL: u1,
                ///  TXFNUM
                TXFNUM: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SODDFRM
                SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved2472: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DIEPINT5: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  TOC
                TOC: u1,
                ///  ITTXFE
                ITTXFE: u1,
                ///  INEPNM
                INEPNM: u1,
                ///  INEPNE
                INEPNE: u1,
                ///  TXFE
                TXFE: u1,
                ///  TXFIFOUDRN
                TXFIFOUDRN: u1,
                ///  BNA
                BNA: u1,
                reserved11: u1,
                ///  PKTDRPSTS
                PKTDRPSTS: u1,
                reserved13: u1,
                ///  NAK
                NAK: u1,
                padding: u18,
            }),
            reserved2480: [4]u8,
            ///  The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the endpoint enable bit in the OTG_DIEPCTLx registers (EPENA bit in OTG_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
            OTG_DIEPTSIZ5: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  MCNT
                MCNT: u2,
                padding: u1,
            }),
            ///  OTG device IN endpoint 5 DMA address register
            OTG_DIEPDMA5: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            ///  This read-only register contains the free space information for the device IN endpoint Tx FIFO.
            OTG_DTXFSTS5: mmio.Mmio(packed struct(u32) {
                ///  INEPTFSAV
                INEPTFSAV: u16,
                padding: u16,
            }),
            reserved2496: [4]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DIEPCTL6: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                reserved21: u1,
                ///  STALL
                STALL: u1,
                ///  TXFNUM
                TXFNUM: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SODDFRM
                SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved2504: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DIEPINT6: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  TOC
                TOC: u1,
                ///  ITTXFE
                ITTXFE: u1,
                ///  INEPNM
                INEPNM: u1,
                ///  INEPNE
                INEPNE: u1,
                ///  TXFE
                TXFE: u1,
                ///  TXFIFOUDRN
                TXFIFOUDRN: u1,
                ///  BNA
                BNA: u1,
                reserved11: u1,
                ///  PKTDRPSTS
                PKTDRPSTS: u1,
                reserved13: u1,
                ///  NAK
                NAK: u1,
                padding: u18,
            }),
            reserved2512: [4]u8,
            ///  The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the endpoint enable bit in the OTG_DIEPCTLx registers (EPENA bit in OTG_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
            OTG_DIEPTSIZ6: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  MCNT
                MCNT: u2,
                padding: u1,
            }),
            ///  OTG device IN endpoint 6 DMA address register
            OTG_DIEPDMA6: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            ///  This read-only register contains the free space information for the device IN endpoint Tx FIFO.
            OTG_DTXFSTS6: mmio.Mmio(packed struct(u32) {
                ///  INEPTFSAV
                INEPTFSAV: u16,
                padding: u16,
            }),
            reserved2528: [4]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DIEPCTL7: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                reserved21: u1,
                ///  STALL
                STALL: u1,
                ///  TXFNUM
                TXFNUM: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SODDFRM
                SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved2536: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DIEPINT7: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  TOC
                TOC: u1,
                ///  ITTXFE
                ITTXFE: u1,
                ///  INEPNM
                INEPNM: u1,
                ///  INEPNE
                INEPNE: u1,
                ///  TXFE
                TXFE: u1,
                ///  TXFIFOUDRN
                TXFIFOUDRN: u1,
                ///  BNA
                BNA: u1,
                reserved11: u1,
                ///  PKTDRPSTS
                PKTDRPSTS: u1,
                reserved13: u1,
                ///  NAK
                NAK: u1,
                padding: u18,
            }),
            reserved2544: [4]u8,
            ///  The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the endpoint enable bit in the OTG_DIEPCTLx registers (EPENA bit in OTG_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
            OTG_DIEPTSIZ7: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  MCNT
                MCNT: u2,
                padding: u1,
            }),
            ///  OTG device IN endpoint 7 DMA address register
            OTG_DIEPDMA7: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            ///  This read-only register contains the free space information for the device IN endpoint Tx FIFO.
            OTG_DTXFSTS7: mmio.Mmio(packed struct(u32) {
                ///  INEPTFSAV
                INEPTFSAV: u16,
                padding: u16,
            }),
            reserved2560: [4]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DIEPCTL8: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                reserved21: u1,
                ///  STALL
                STALL: u1,
                ///  TXFNUM
                TXFNUM: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SODDFRM
                SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved2568: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the IN endpoints interrupt bit of the core interrupt register (IEPINT in OTG_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DIEPINT8: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  TOC
                TOC: u1,
                ///  ITTXFE
                ITTXFE: u1,
                ///  INEPNM
                INEPNM: u1,
                ///  INEPNE
                INEPNE: u1,
                ///  TXFE
                TXFE: u1,
                ///  TXFIFOUDRN
                TXFIFOUDRN: u1,
                ///  BNA
                BNA: u1,
                reserved11: u1,
                ///  PKTDRPSTS
                PKTDRPSTS: u1,
                reserved13: u1,
                ///  NAK
                NAK: u1,
                padding: u18,
            }),
            reserved2576: [4]u8,
            ///  The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the endpoint enable bit in the OTG_DIEPCTLx registers (EPENA bit in OTG_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
            OTG_DIEPTSIZ8: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  MCNT
                MCNT: u2,
                padding: u1,
            }),
            ///  OTG device IN endpoint 8 DMA address register
            OTG_DIEPDMA8: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            ///  This read-only register contains the free space information for the device IN endpoint Tx FIFO.
            OTG_DTXFSTS8: mmio.Mmio(packed struct(u32) {
                ///  INEPTFSAV
                INEPTFSAV: u16,
                padding: u16,
            }),
            reserved2816: [228]u8,
            ///  This section describes the OTG_DOEPCTL0 register.
            OTG_DOEPCTL0: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u2,
                reserved15: u13,
                ///  USBAEP
                USBAEP: u1,
                reserved17: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  SNPM
                SNPM: u1,
                ///  STALL
                STALL: u1,
                reserved26: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                reserved30: u2,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved2824: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DOEPINT0: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STUP
                STUP: u1,
                ///  OTEPDIS
                OTEPDIS: u1,
                ///  STSPHSRX
                STSPHSRX: u1,
                ///  B2BSTUP
                B2BSTUP: u1,
                reserved8: u1,
                ///  OUTPKTERR
                OUTPKTERR: u1,
                ///  BNA
                BNA: u1,
                reserved12: u2,
                ///  BERR
                BERR: u1,
                ///  NAK
                NAK: u1,
                ///  NYET
                NYET: u1,
                ///  STPKTRX
                STPKTRX: u1,
                padding: u16,
            }),
            reserved2832: [4]u8,
            ///  The application must modify this register before enabling endpoint 0.
            OTG_DOEPTSIZ0: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u7,
                reserved19: u12,
                ///  PKTCNT
                PKTCNT: u1,
                reserved29: u9,
                ///  STUPCNT
                STUPCNT: u2,
                padding: u1,
            }),
            ///  OTG device OUT endpoint 0 DMA address register
            OTG_DOEPDMA0: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved2848: [8]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DOEPCTL1: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  SNPM
                SNPM: u1,
                ///  STALL
                STALL: u1,
                reserved26: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SD1PID_SODDFRM
                SD1PID_SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved2856: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DOEPINT1: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STUP
                STUP: u1,
                ///  OTEPDIS
                OTEPDIS: u1,
                ///  STSPHSRX
                STSPHSRX: u1,
                ///  B2BSTUP
                B2BSTUP: u1,
                reserved8: u1,
                ///  OUTPKTERR
                OUTPKTERR: u1,
                ///  BNA
                BNA: u1,
                reserved12: u2,
                ///  BERR
                BERR: u1,
                ///  NAK
                NAK: u1,
                ///  NYET
                NYET: u1,
                ///  STPKTRX
                STPKTRX: u1,
                padding: u16,
            }),
            reserved2864: [4]u8,
            ///  The application must modify this register before enabling the endpoint. Once the endpoint is enabled using endpoint enable bit of the OTG_DOEPCTLx registers (EPENA bit in OTG_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
            OTG_DOEPTSIZ1: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  RXDPID_STUPCNT
                RXDPID_STUPCNT: u2,
                padding: u1,
            }),
            ///  OTG device OUT endpoint 1 DMA address register
            OTG_DOEPDMA1: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved2880: [8]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DOEPCTL2: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  SNPM
                SNPM: u1,
                ///  STALL
                STALL: u1,
                reserved26: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SD1PID_SODDFRM
                SD1PID_SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved2888: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DOEPINT2: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STUP
                STUP: u1,
                ///  OTEPDIS
                OTEPDIS: u1,
                ///  STSPHSRX
                STSPHSRX: u1,
                ///  B2BSTUP
                B2BSTUP: u1,
                reserved8: u1,
                ///  OUTPKTERR
                OUTPKTERR: u1,
                ///  BNA
                BNA: u1,
                reserved12: u2,
                ///  BERR
                BERR: u1,
                ///  NAK
                NAK: u1,
                ///  NYET
                NYET: u1,
                ///  STPKTRX
                STPKTRX: u1,
                padding: u16,
            }),
            reserved2896: [4]u8,
            ///  The application must modify this register before enabling the endpoint. Once the endpoint is enabled using endpoint enable bit of the OTG_DOEPCTLx registers (EPENA bit in OTG_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
            OTG_DOEPTSIZ2: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  RXDPID_STUPCNT
                RXDPID_STUPCNT: u2,
                padding: u1,
            }),
            ///  OTG device OUT endpoint 2 DMA address register
            OTG_DOEPDMA2: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved2912: [8]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DOEPCTL3: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  SNPM
                SNPM: u1,
                ///  STALL
                STALL: u1,
                reserved26: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SD1PID_SODDFRM
                SD1PID_SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved2920: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DOEPINT3: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STUP
                STUP: u1,
                ///  OTEPDIS
                OTEPDIS: u1,
                ///  STSPHSRX
                STSPHSRX: u1,
                ///  B2BSTUP
                B2BSTUP: u1,
                reserved8: u1,
                ///  OUTPKTERR
                OUTPKTERR: u1,
                ///  BNA
                BNA: u1,
                reserved12: u2,
                ///  BERR
                BERR: u1,
                ///  NAK
                NAK: u1,
                ///  NYET
                NYET: u1,
                ///  STPKTRX
                STPKTRX: u1,
                padding: u16,
            }),
            reserved2928: [4]u8,
            ///  The application must modify this register before enabling the endpoint. Once the endpoint is enabled using endpoint enable bit of the OTG_DOEPCTLx registers (EPENA bit in OTG_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
            OTG_DOEPTSIZ3: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  RXDPID_STUPCNT
                RXDPID_STUPCNT: u2,
                padding: u1,
            }),
            ///  OTG device OUT endpoint 3 DMA address register
            OTG_DOEPDMA3: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved2944: [8]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DOEPCTL4: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  SNPM
                SNPM: u1,
                ///  STALL
                STALL: u1,
                reserved26: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SD1PID_SODDFRM
                SD1PID_SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved2952: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DOEPINT4: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STUP
                STUP: u1,
                ///  OTEPDIS
                OTEPDIS: u1,
                ///  STSPHSRX
                STSPHSRX: u1,
                ///  B2BSTUP
                B2BSTUP: u1,
                reserved8: u1,
                ///  OUTPKTERR
                OUTPKTERR: u1,
                ///  BNA
                BNA: u1,
                reserved12: u2,
                ///  BERR
                BERR: u1,
                ///  NAK
                NAK: u1,
                ///  NYET
                NYET: u1,
                ///  STPKTRX
                STPKTRX: u1,
                padding: u16,
            }),
            reserved2960: [4]u8,
            ///  The application must modify this register before enabling the endpoint. Once the endpoint is enabled using endpoint enable bit of the OTG_DOEPCTLx registers (EPENA bit in OTG_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
            OTG_DOEPTSIZ4: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  RXDPID_STUPCNT
                RXDPID_STUPCNT: u2,
                padding: u1,
            }),
            ///  OTG device OUT endpoint 4 DMA address register
            OTG_DOEPDMA4: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved2976: [8]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DOEPCTL5: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  SNPM
                SNPM: u1,
                ///  STALL
                STALL: u1,
                reserved26: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SD1PID_SODDFRM
                SD1PID_SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved2984: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DOEPINT5: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STUP
                STUP: u1,
                ///  OTEPDIS
                OTEPDIS: u1,
                ///  STSPHSRX
                STSPHSRX: u1,
                ///  B2BSTUP
                B2BSTUP: u1,
                reserved8: u1,
                ///  OUTPKTERR
                OUTPKTERR: u1,
                ///  BNA
                BNA: u1,
                reserved12: u2,
                ///  BERR
                BERR: u1,
                ///  NAK
                NAK: u1,
                ///  NYET
                NYET: u1,
                ///  STPKTRX
                STPKTRX: u1,
                padding: u16,
            }),
            reserved2992: [4]u8,
            ///  The application must modify this register before enabling the endpoint. Once the endpoint is enabled using endpoint enable bit of the OTG_DOEPCTLx registers (EPENA bit in OTG_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
            OTG_DOEPTSIZ5: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  RXDPID_STUPCNT
                RXDPID_STUPCNT: u2,
                padding: u1,
            }),
            ///  OTG device OUT endpoint 5 DMA address register
            OTG_DOEPDMA5: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved3008: [8]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DOEPCTL6: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  SNPM
                SNPM: u1,
                ///  STALL
                STALL: u1,
                reserved26: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SD1PID_SODDFRM
                SD1PID_SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved3016: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DOEPINT6: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STUP
                STUP: u1,
                ///  OTEPDIS
                OTEPDIS: u1,
                ///  STSPHSRX
                STSPHSRX: u1,
                ///  B2BSTUP
                B2BSTUP: u1,
                reserved8: u1,
                ///  OUTPKTERR
                OUTPKTERR: u1,
                ///  BNA
                BNA: u1,
                reserved12: u2,
                ///  BERR
                BERR: u1,
                ///  NAK
                NAK: u1,
                ///  NYET
                NYET: u1,
                ///  STPKTRX
                STPKTRX: u1,
                padding: u16,
            }),
            reserved3024: [4]u8,
            ///  The application must modify this register before enabling the endpoint. Once the endpoint is enabled using endpoint enable bit of the OTG_DOEPCTLx registers (EPENA bit in OTG_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
            OTG_DOEPTSIZ6: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  RXDPID_STUPCNT
                RXDPID_STUPCNT: u2,
                padding: u1,
            }),
            ///  OTG device OUT endpoint 6 DMA address register
            OTG_DOEPDMA6: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved3040: [8]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DOEPCTL7: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  SNPM
                SNPM: u1,
                ///  STALL
                STALL: u1,
                reserved26: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SD1PID_SODDFRM
                SD1PID_SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved3048: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DOEPINT7: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STUP
                STUP: u1,
                ///  OTEPDIS
                OTEPDIS: u1,
                ///  STSPHSRX
                STSPHSRX: u1,
                ///  B2BSTUP
                B2BSTUP: u1,
                reserved8: u1,
                ///  OUTPKTERR
                OUTPKTERR: u1,
                ///  BNA
                BNA: u1,
                reserved12: u2,
                ///  BERR
                BERR: u1,
                ///  NAK
                NAK: u1,
                ///  NYET
                NYET: u1,
                ///  STPKTRX
                STPKTRX: u1,
                padding: u16,
            }),
            reserved3056: [4]u8,
            ///  The application must modify this register before enabling the endpoint. Once the endpoint is enabled using endpoint enable bit of the OTG_DOEPCTLx registers (EPENA bit in OTG_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
            OTG_DOEPTSIZ7: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  RXDPID_STUPCNT
                RXDPID_STUPCNT: u2,
                padding: u1,
            }),
            ///  OTG device OUT endpoint 7 DMA address register
            OTG_DOEPDMA7: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved3072: [8]u8,
            ///  The application uses this register to control the behavior of each logical endpoint other than endpoint 0.
            OTG_DOEPCTL8: mmio.Mmio(packed struct(u32) {
                ///  MPSIZ
                MPSIZ: u11,
                reserved15: u4,
                ///  USBAEP
                USBAEP: u1,
                ///  EONUM_DPIP
                EONUM_DPIP: u1,
                ///  NAKSTS
                NAKSTS: u1,
                ///  EPTYP
                EPTYP: u2,
                ///  SNPM
                SNPM: u1,
                ///  STALL
                STALL: u1,
                reserved26: u4,
                ///  CNAK
                CNAK: u1,
                ///  SNAK
                SNAK: u1,
                ///  SD0PID_SEVNFRM
                SD0PID_SEVNFRM: u1,
                ///  SD1PID_SODDFRM
                SD1PID_SODDFRM: u1,
                ///  EPDIS
                EPDIS: u1,
                ///  EPENA
                EPENA: u1,
            }),
            reserved3080: [4]u8,
            ///  This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure724. The application must read this register when the OUT endpoints interrupt bit of the OTG_GINTSTS register (OEPINT bit in OTG_GINTSTS) is set. Before the application can read this register, it must first read the OTG_DAINT register to get the exact endpoint number for the OTG_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_DAINT and OTG_GINTSTS registers.
            OTG_DOEPINT8: mmio.Mmio(packed struct(u32) {
                ///  XFRC
                XFRC: u1,
                ///  EPDISD
                EPDISD: u1,
                ///  AHBERR
                AHBERR: u1,
                ///  STUP
                STUP: u1,
                ///  OTEPDIS
                OTEPDIS: u1,
                ///  STSPHSRX
                STSPHSRX: u1,
                ///  B2BSTUP
                B2BSTUP: u1,
                reserved8: u1,
                ///  OUTPKTERR
                OUTPKTERR: u1,
                ///  BNA
                BNA: u1,
                reserved12: u2,
                ///  BERR
                BERR: u1,
                ///  NAK
                NAK: u1,
                ///  NYET
                NYET: u1,
                ///  STPKTRX
                STPKTRX: u1,
                padding: u16,
            }),
            reserved3088: [4]u8,
            ///  The application must modify this register before enabling the endpoint. Once the endpoint is enabled using endpoint enable bit of the OTG_DOEPCTLx registers (EPENA bit in OTG_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the endpoint enable bit.
            OTG_DOEPTSIZ8: mmio.Mmio(packed struct(u32) {
                ///  XFRSIZ
                XFRSIZ: u19,
                ///  PKTCNT
                PKTCNT: u10,
                ///  RXDPID_STUPCNT
                RXDPID_STUPCNT: u2,
                padding: u1,
            }),
            ///  OTG device OUT endpoint 8 DMA address register
            OTG_DOEPDMA8: mmio.Mmio(packed struct(u32) {
                ///  DMAADDR
                DMAADDR: u32,
            }),
            reserved3584: [488]u8,
            ///  This register is available in host and device modes.
            OTG_PCGCCTL: mmio.Mmio(packed struct(u32) {
                ///  STPPCLK
                STPPCLK: u1,
                ///  GATEHCLK
                GATEHCLK: u1,
                reserved4: u2,
                ///  PHYSUSP
                PHYSUSP: u1,
                ///  ENL1GTG
                ENL1GTG: u1,
                ///  PHYSLEEP
                PHYSLEEP: u1,
                ///  SUSP
                SUSP: u1,
                padding: u24,
            }),
        };

        ///  PWR
        pub const PWR = extern struct {
            ///  Reset on any system reset. This register provides write access security when enabled by TZEN register bit in Section10: Reset and clock control (RCC). When security is enabled a non-secure write access generates a bus error. Secure and non-secure read accesses are granted and return the register value.
            PWR_CR1: mmio.Mmio(packed struct(u32) {
                ///  LPDS
                LPDS: u1,
                ///  LPCFG
                LPCFG: u1,
                ///  LVDS
                LVDS: u1,
                reserved4: u1,
                ///  PVDEN
                PVDEN: u1,
                ///  PLS
                PLS: u3,
                ///  DBP
                DBP: u1,
                reserved16: u7,
                ///  AVDEN
                AVDEN: u1,
                ///  ALS
                ALS: u2,
                padding: u13,
            }),
            ///  Reset on any system reset.
            PWR_CSR1: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  PVDO
                PVDO: u1,
                reserved16: u11,
                ///  AVDO
                AVDO: u1,
                padding: u15,
            }),
            ///  Not reset by wakeup from Standby mode, Application reset (NRST, IWDG, ...) and VDD POR, but reset only by VSW POR and VSWRST. Access 6 wait states when writing this register. After reset the register is write-protected and the DBP bit in the PWR control register 1 (PWR_CR1) has to be set before it can be written. When DBP is cleared, there is no bus errors generated when writing this register. This register shall not be accessed when the RCC VSWRST register bit in Section10.7.89: RCC Backup Domain Control Register (RCC_BDCR) resets the VSW domain. This register provides Write access security when enabled by TZEN register bit in Section10.7.2: RCC TrustZone Control Register (RCC_TZCR). When security is enabled a non-secure write access generates a bus error. Secure and non-secure read accesses are granted and return the register value. When a system reset occurs during the register write cycle the written data is not guaranteed.
            PWR_CR2: mmio.Mmio(packed struct(u32) {
                ///  BREN
                BREN: u1,
                ///  RREN
                RREN: u1,
                reserved4: u2,
                ///  MONEN
                MONEN: u1,
                reserved16: u11,
                ///  BRRDY
                BRRDY: u1,
                ///  RRRDY
                RRRDY: u1,
                reserved20: u2,
                ///  VBATL
                VBATL: u1,
                ///  VBATH
                VBATH: u1,
                ///  TEMPL
                TEMPL: u1,
                ///  TEMPH
                TEMPH: u1,
                padding: u8,
            }),
            ///  Not reset by wakeup from Standby mode and Application reset (such as NRST, IWDG) but only reset by VDD POR. Access 6 wait states when writing this register. This register provides Write access security when enabled by TZEN register bit in Section10: Reset and clock control (RCC). When security is enabled a non-secure write access generates a bus error. Secure and non-secure read accesses are granted and return the register value. When a system reset occurs during the register write cycle the written data is not guaranteed.
            PWR_CR3: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                ///  VBE
                VBE: u1,
                ///  VBRS
                VBRS: u1,
                ///  DDRSREN
                DDRSREN: u1,
                ///  DDRSRDIS
                DDRSRDIS: u1,
                ///  DDRRETEN
                DDRRETEN: u1,
                reserved17: u4,
                ///  POPL
                POPL: u5,
                reserved24: u2,
                ///  USB33DEN
                USB33DEN: u1,
                reserved26: u1,
                ///  USB33RDY
                USB33RDY: u1,
                reserved28: u1,
                ///  REG18EN
                REG18EN: u1,
                ///  REG18RDY
                REG18RDY: u1,
                ///  REG11EN
                REG11EN: u1,
                ///  REG11RDY
                REG11RDY: u1,
            }),
            ///  See individual bits for reset condition. Access 6 wait states when writing this register. This register provides Write access security when enabled by TZEN register bit in Section10: Reset and clock control (RCC). When security is enabled a non-secure write access generates a bus error. Secure and non-secure read accesses are granted and return the register value. When a system reset occurs during the register write cycle the written data is not guaranteed.
            PWR_MPUCR: mmio.Mmio(packed struct(u32) {
                ///  PDDS
                PDDS: u1,
                reserved3: u2,
                ///  CSTBYDIS
                CSTBYDIS: u1,
                reserved5: u1,
                ///  STOPF
                STOPF: u1,
                ///  SBF
                SBF: u1,
                ///  SBFMPU
                SBFMPU: u1,
                reserved9: u1,
                ///  CSSF
                CSSF: u1,
                reserved15: u5,
                ///  STANDBYWFIL2
                STANDBYWFIL2: u1,
                padding: u16,
            }),
            ///  See individual bits for reset condition. Access 6 wait states when writing this register. This register is always non-secure. When a system reset occurs during the register write cycle the written data is not guaranteed.
            PWR_MCUCR: mmio.Mmio(packed struct(u32) {
                ///  PDDS
                PDDS: u1,
                reserved5: u4,
                ///  STOPF
                STOPF: u1,
                ///  SBF
                SBF: u1,
                reserved9: u2,
                ///  CSSF
                CSSF: u1,
                reserved15: u5,
                ///  DEEPSLEEP
                DEEPSLEEP: u1,
                padding: u16,
            }),
            reserved32: [8]u8,
            ///  Not reset by wakeup from Standby mode, but by any application reset (such as NRST, IWDG). Access 6 wait states when writing this register (when clearing a WKUPF, the AHB write access completes after the WKUPF has cleared). This register provides Write access security when enabled by TZEN register bit in Section10: Reset and clock control (RCC). When security is enabled a non-secure write access on individual WKUPC[6:1], WKUPP[6:1] bits and WKUPPUPD[6:1] bit pairs are discarded when the corresponding WKUPEN[6:1] bit in PWR MPU wakeup enable register (PWR_MPUWKUPENR) is set. No bus error is generated. Secure and non-secure read accesses are granted and return the register value. When a system reset occurs during the register write cycle the written data is not guaranteed.
            PWR_WKUPCR: mmio.Mmio(packed struct(u32) {
                ///  WKUPC1
                WKUPC1: u1,
                ///  WKUPC2
                WKUPC2: u1,
                ///  WKUPC3
                WKUPC3: u1,
                ///  WKUPC4
                WKUPC4: u1,
                ///  WKUPC5
                WKUPC5: u1,
                ///  WKUPC6
                WKUPC6: u1,
                reserved8: u2,
                ///  WKUPP1
                WKUPP1: u1,
                ///  WKUPP2
                WKUPP2: u1,
                ///  WKUPP3
                WKUPP3: u1,
                ///  WKUPP4
                WKUPP4: u1,
                ///  WKUPP5
                WKUPP5: u1,
                ///  WKUPP6
                WKUPP6: u1,
                reserved16: u2,
                ///  WKUPPUPD1
                WKUPPUPD1: u2,
                ///  WKUPPUPD2
                WKUPPUPD2: u2,
                ///  WKUPPUPD3
                WKUPPUPD3: u2,
                ///  WKUPPUPD4
                WKUPPUPD4: u2,
                ///  WKUPPUPD5
                WKUPPUPD5: u2,
                ///  WKUPPUPD6
                WKUPPUPD6: u2,
                padding: u4,
            }),
            ///  Not reset by wakeup from Standby mode but by any Application reset (NRST, IWDG, ...)
            PWR_WKUPFR: mmio.Mmio(packed struct(u32) {
                ///  WKUPF1
                WKUPF1: u1,
                ///  WKUPF2
                WKUPF2: u1,
                ///  WKUPF3
                WKUPF3: u1,
                ///  WKUPF4
                WKUPF4: u1,
                ///  WKUPF5
                WKUPF5: u1,
                ///  WKUPF6
                WKUPF6: u1,
                padding: u26,
            }),
            ///  Not reset by wakeup from Standby mode but by any Application reset (NRST, IWDG, ...). Access 6 wait states when writing this register. This register provides Write access security when enabled by TZEN register bit in Section10: Reset and clock control (RCC). When security is enabled a non-secure write access is discarded and a bus error is generated. Secure and non-secure read accesses are granted and return the register value. When a system reset occurs during the register write cycle the written data is not guaranteed.
            PWR_MPUWKUPENR: mmio.Mmio(packed struct(u32) {
                ///  WKUPEN1
                WKUPEN1: u1,
                ///  WKUPEN2
                WKUPEN2: u1,
                ///  WKUPEN3
                WKUPEN3: u1,
                ///  WKUPEN4
                WKUPEN4: u1,
                ///  WKUPEN5
                WKUPEN5: u1,
                ///  WKUPEN6
                WKUPEN6: u1,
                padding: u26,
            }),
            ///  Not reset by wakeup from Standby mode but by any Application reset (NRST, IWDG, ...) Access 6 wait states when writing this register. When a system reset occurs during the register write cycle the written data is not guaranteed.
            PWR_MCUWKUPENR: mmio.Mmio(packed struct(u32) {
                ///  WKUPEN1
                WKUPEN1: u1,
                ///  WKUPEN2
                WKUPEN2: u1,
                ///  WKUPEN3
                WKUPEN3: u1,
                ///  WKUPEN4
                WKUPEN4: u1,
                ///  WKUPEN5
                WKUPEN5: u1,
                ///  WKUPEN6
                WKUPEN6: u1,
                padding: u26,
            }),
            reserved1012: [964]u8,
            ///  PWR IP version register
            PWR_VER: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  PWR IP identification register
            PWR_ID: mmio.Mmio(packed struct(u32) {
                ///  IPID
                IPID: u32,
            }),
            ///  PWR size ID register
            PWR_SID: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  QUADSPI1
        pub const QUADSPI = extern struct {
            ///  QUADSPI control register
            QUADSPI_CR: mmio.Mmio(packed struct(u32) {
                ///  EN
                EN: u1,
                ///  ABORT
                ABORT: u1,
                ///  DMAEN
                DMAEN: u1,
                ///  TCEN
                TCEN: u1,
                ///  SSHIFT
                SSHIFT: u1,
                reserved6: u1,
                ///  DFM
                DFM: u1,
                ///  FSEL
                FSEL: u1,
                ///  FTHRES
                FTHRES: u4,
                reserved16: u4,
                ///  TEIE
                TEIE: u1,
                ///  TCIE
                TCIE: u1,
                ///  FTIE
                FTIE: u1,
                ///  SMIE
                SMIE: u1,
                ///  TOIE
                TOIE: u1,
                reserved22: u1,
                ///  APMS
                APMS: u1,
                ///  PMM
                PMM: u1,
                ///  PRESCALER
                PRESCALER: u8,
            }),
            ///  QUADSPI device configuration register
            QUADSPI_DCR: mmio.Mmio(packed struct(u32) {
                ///  CKMODE
                CKMODE: u1,
                reserved8: u7,
                ///  CSHT
                CSHT: u3,
                reserved16: u5,
                ///  FSIZE
                FSIZE: u5,
                padding: u11,
            }),
            ///  QUADSPI status register
            QUADSPI_SR: mmio.Mmio(packed struct(u32) {
                ///  TEF
                TEF: u1,
                ///  TCF
                TCF: u1,
                ///  FTF
                FTF: u1,
                ///  SMF
                SMF: u1,
                ///  TOF
                TOF: u1,
                ///  BUSY
                BUSY: u1,
                reserved8: u2,
                ///  FLEVEL
                FLEVEL: u5,
                padding: u19,
            }),
            ///  QUADSPI flag clear register
            QUADSPI_FCR: mmio.Mmio(packed struct(u32) {
                ///  CTEF
                CTEF: u1,
                ///  CTCF
                CTCF: u1,
                reserved3: u1,
                ///  CSMF
                CSMF: u1,
                ///  CTOF
                CTOF: u1,
                padding: u27,
            }),
            ///  QUADSPI data length register
            QUADSPI_DLR: mmio.Mmio(packed struct(u32) {
                ///  DL
                DL: u32,
            }),
            ///  QUADSPI communication configuration register
            QUADSPI_CCR: mmio.Mmio(packed struct(u32) {
                ///  INSTRUCTION
                INSTRUCTION: u8,
                ///  IMODE
                IMODE: u2,
                ///  ADMODE
                ADMODE: u2,
                ///  ADSIZE
                ADSIZE: u2,
                ///  ABMODE
                ABMODE: u2,
                ///  ABSIZE
                ABSIZE: u2,
                ///  DCYC
                DCYC: u5,
                reserved24: u1,
                ///  DMODE
                DMODE: u2,
                ///  FMODE
                FMODE: u2,
                ///  SIOO
                SIOO: u1,
                ///  FRCM
                FRCM: u1,
                ///  DHHC
                DHHC: u1,
                ///  DDRM
                DDRM: u1,
            }),
            ///  QUADSPI address register
            QUADSPI_AR: mmio.Mmio(packed struct(u32) {
                ///  ADDRESS
                ADDRESS: u32,
            }),
            ///  QUADSPI alternate bytes registers
            QUADSPI_ABR: mmio.Mmio(packed struct(u32) {
                ///  ALTERNATE
                ALTERNATE: u32,
            }),
            ///  QUADSPI data register
            QUADSPI_DR: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  QUADSPI polling status mask register
            QUADSPI_PSMKR: mmio.Mmio(packed struct(u32) {
                ///  MASK
                MASK: u32,
            }),
            ///  QUADSPI polling status match register
            QUADSPI_PSMAR: mmio.Mmio(packed struct(u32) {
                ///  MATCH
                MATCH: u32,
            }),
            ///  QUADSPI polling interval register
            QUADSPI_PIR: mmio.Mmio(packed struct(u32) {
                ///  INTERVAL
                INTERVAL: u16,
                padding: u16,
            }),
            ///  QUADSPI low-power timeout register
            QUADSPI_LPTR: mmio.Mmio(packed struct(u32) {
                ///  TIMEOUT
                TIMEOUT: u16,
                padding: u16,
            }),
            reserved1008: [956]u8,
            ///  QUADSPI HW configuration register
            QUADSPI_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  FIFOSIZE
                FIFOSIZE: u4,
                ///  FIFOPTR
                FIFOPTR: u4,
                ///  PRESCVAL
                PRESCVAL: u4,
                ///  IDLENGTH
                IDLENGTH: u4,
                padding: u16,
            }),
            ///  QUADSPI version register
            QUADSPI_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  QUADSPI identification register
            QUADSPI_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  QUADSPI size identification register
            QUADSPI_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  RCC
        pub const RCC = extern struct {
            ///  This register is used to switch the RCC into secure mode. This register can only be accessed in secure mode.
            RCC_TZCR: mmio.Mmio(packed struct(u32) {
                ///  TZEN
                TZEN: u1,
                ///  MCKPROT
                MCKPROT: u1,
                padding: u30,
            }),
            reserved12: [8]u8,
            ///  This register is used to control the oscillators.Writing to this register has no effect, writing will set the corresponding bits. Reading will give the effective values of each bit.If TZEN = MCKPROT = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_OCENSETR: mmio.Mmio(packed struct(u32) {
                ///  HSION
                HSION: u1,
                ///  HSIKERON
                HSIKERON: u1,
                reserved4: u2,
                ///  CSION
                CSION: u1,
                ///  CSIKERON
                CSIKERON: u1,
                reserved7: u1,
                ///  DIGBYP
                DIGBYP: u1,
                ///  HSEON
                HSEON: u1,
                ///  HSEKERON
                HSEKERON: u1,
                ///  HSEBYP
                HSEBYP: u1,
                ///  HSECSSON
                HSECSSON: u1,
                padding: u20,
            }),
            ///  This register is used to control the oscillators.Writing to this register has no effect, writing will clear the corresponding bits. Reading will give the effective values of the enable bits.If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_OCENCLRR: mmio.Mmio(packed struct(u32) {
                ///  HSION
                HSION: u1,
                ///  HSIKERON
                HSIKERON: u1,
                reserved4: u2,
                ///  CSION
                CSION: u1,
                ///  CSIKERON
                CSIKERON: u1,
                reserved7: u1,
                ///  DIGBYP
                DIGBYP: u1,
                ///  HSEON
                HSEON: u1,
                ///  HSEKERON
                HSEKERON: u1,
                ///  HSEBYP
                HSEBYP: u1,
                padding: u21,
            }),
            reserved24: [4]u8,
            ///  This register is used to configure the HSI. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_HSICFGR: mmio.Mmio(packed struct(u32) {
                ///  HSIDIV
                HSIDIV: u2,
                reserved8: u6,
                ///  HSITRIM
                HSITRIM: u7,
                reserved16: u1,
                ///  HSICAL
                HSICAL: u12,
                padding: u4,
            }),
            ///  This register is used to fine-tune the CSI frequency. If TZEN = MCKPROT = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See The clock restore sequence description for details.
            RCC_CSICFGR: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                ///  CSITRIM
                CSITRIM: u5,
                reserved16: u3,
                ///  CSICAL
                CSICAL: u8,
                padding: u8,
            }),
            ///  This register is used to select the clock source for the MPU. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_MPCKSELR: mmio.Mmio(packed struct(u32) {
                ///  MPUSRC
                MPUSRC: u2,
                reserved31: u29,
                ///  MPUSRCRDY
                MPUSRCRDY: u1,
            }),
            ///  This register is used to select the clock source for the AXI sub-system. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_ASSCKSELR: mmio.Mmio(packed struct(u32) {
                ///  AXISSRC
                AXISSRC: u3,
                reserved31: u28,
                ///  AXISSRCRDY
                AXISSRCRDY: u1,
            }),
            ///  This register is used to select the reference clock for PLL1 and PLL2. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_RCK12SELR: mmio.Mmio(packed struct(u32) {
                ///  PLL12SRC
                PLL12SRC: u2,
                reserved31: u29,
                ///  PLL12SRCRDY
                PLL12SRCRDY: u1,
            }),
            ///  This register is used to control the MPU clock prescaler. Refer to Section: Sub-system clock generation for additional information. If TZEN = , this register can only be modified in secure mode.
            RCC_MPCKDIVR: mmio.Mmio(packed struct(u32) {
                ///  MPUDIV
                MPUDIV: u3,
                reserved31: u28,
                ///  MPUDIVRDY
                MPUDIVRDY: u1,
            }),
            ///  This register is used to control the AXI Matrix clock prescaler. Refer to Section: Sub-system clock generation for additional information. If TZEN = , this register can only be modified in secure mode.
            RCC_AXIDIVR: mmio.Mmio(packed struct(u32) {
                ///  AXIDIV
                AXIDIV: u3,
                reserved31: u28,
                ///  AXIDIVRDY
                AXIDIVRDY: u1,
            }),
            reserved60: [8]u8,
            ///  This register is used to control the APB4 clock divider. Refer to Section: Sub-system clock generation for additional information. If TZEN = , this register can only be modified in secure mode.
            RCC_APB4DIVR: mmio.Mmio(packed struct(u32) {
                ///  APB4DIV
                APB4DIV: u3,
                reserved31: u28,
                ///  APB4DIVRDY
                APB4DIVRDY: u1,
            }),
            ///  This register is used to control the APB5 clock divider. Refer to Section: Sub-system clock generation for additional information. If TZEN = , this register can only be modified in secure mode.
            RCC_APB5DIVR: mmio.Mmio(packed struct(u32) {
                ///  APB5DIV
                APB5DIV: u3,
                reserved31: u28,
                ///  APB5DIVRDY
                APB5DIVRDY: u1,
            }),
            ///  This register is used to divide the HSE clock for RTC. If TZEN = , this register can only be modified in secure mode.
            RCC_RTCDIVR: mmio.Mmio(packed struct(u32) {
                ///  RTCDIV
                RTCDIV: u6,
                padding: u26,
            }),
            ///  This register is used to select the clock source for the MCU sub-system, including the MCU itself. If TZEN = MCKPROT = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_MSSCKSELR: mmio.Mmio(packed struct(u32) {
                ///  MCUSSRC
                MCUSSRC: u2,
                reserved31: u29,
                ///  MCUSSRCRDY
                MCUSSRCRDY: u1,
            }),
            reserved128: [52]u8,
            ///  This register is used to control the PLL1. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_PLL1CR: mmio.Mmio(packed struct(u32) {
                ///  PLLON
                PLLON: u1,
                ///  PLL1RDY
                PLL1RDY: u1,
                ///  SSCG_CTRL
                SSCG_CTRL: u1,
                reserved4: u1,
                ///  DIVPEN
                DIVPEN: u1,
                ///  DIVQEN
                DIVQEN: u1,
                ///  DIVREN
                DIVREN: u1,
                padding: u25,
            }),
            ///  This register is used to configure the PLL1. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_PLL1CFGR1: mmio.Mmio(packed struct(u32) {
                ///  DIVN
                DIVN: u9,
                reserved16: u7,
                ///  DIVM1
                DIVM1: u6,
                padding: u10,
            }),
            ///  This register is used to configure the PLL1. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_PLL1CFGR2: mmio.Mmio(packed struct(u32) {
                ///  DIVP
                DIVP: u7,
                reserved8: u1,
                ///  DIVQ
                DIVQ: u7,
                reserved16: u1,
                ///  DIVR
                DIVR: u7,
                padding: u9,
            }),
            ///  This register is used to fine-tune the frequency of the PLL1 VCO. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_PLL1FRACR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  FRACV
                FRACV: u13,
                ///  FRACLE
                FRACLE: u1,
                padding: u15,
            }),
            ///  This register is used to configure the PLL1.It is not recommended to change the content of this register when the PLL1 is enabled (PLLON = ). Refer to Section: Using the PLLs in spread spectrum mode for details. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_PLL1CSGR: mmio.Mmio(packed struct(u32) {
                ///  MOD_PER
                MOD_PER: u13,
                ///  TPDFN_DIS
                TPDFN_DIS: u1,
                ///  RPDFN_DIS
                RPDFN_DIS: u1,
                ///  SSCG_MODE
                SSCG_MODE: u1,
                ///  INC_STEP
                INC_STEP: u15,
                padding: u1,
            }),
            ///  This register is used to control the PLL2. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_PLL2CR: mmio.Mmio(packed struct(u32) {
                ///  PLLON
                PLLON: u1,
                ///  PLL2RDY
                PLL2RDY: u1,
                ///  SSCG_CTRL
                SSCG_CTRL: u1,
                reserved4: u1,
                ///  DIVPEN
                DIVPEN: u1,
                ///  DIVQEN
                DIVQEN: u1,
                ///  DIVREN
                DIVREN: u1,
                padding: u25,
            }),
            ///  This register is used to configure the PLL2. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_PLL2CFGR1: mmio.Mmio(packed struct(u32) {
                ///  DIVN
                DIVN: u9,
                reserved16: u7,
                ///  DIVM2
                DIVM2: u6,
                padding: u10,
            }),
            ///  This register is used to configure the PLL2. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_PLL2CFGR2: mmio.Mmio(packed struct(u32) {
                ///  DIVP
                DIVP: u7,
                reserved8: u1,
                ///  DIVQ
                DIVQ: u7,
                reserved16: u1,
                ///  DIVR
                DIVR: u7,
                padding: u9,
            }),
            ///  This register is used to fine-tune the frequency of the PLL2 VCO. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_PLL2FRACR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  FRACV
                FRACV: u13,
                ///  FRACLE
                FRACLE: u1,
                padding: u15,
            }),
            ///  This register is used to configure the PLL2. It is not recommended to change the content of this register when the PLL2 is enabled (PLLON = ). Refer to Section: Using the PLLs in spread spectrum mode for details. If TZEN = , this register can only be modified in secure mode. Write access to this register is not allowed during the clock restore sequence. See Section: The clock restore sequence description for details.
            RCC_PLL2CSGR: mmio.Mmio(packed struct(u32) {
                ///  MOD_PER
                MOD_PER: u13,
                ///  TPDFN_DIS
                TPDFN_DIS: u1,
                ///  RPDFN_DIS
                RPDFN_DIS: u1,
                ///  SSCG_MODE
                SSCG_MODE: u1,
                ///  INC_STEP
                INC_STEP: u15,
                padding: u1,
            }),
            reserved192: [24]u8,
            ///  This register is used to control the selection of the kernel clock for the I2C4 and I2C6. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays. If TZEN = , this register can only be modified in secure mode.
            RCC_I2C46CKSELR: mmio.Mmio(packed struct(u32) {
                ///  I2C46SRC
                I2C46SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the SPI6. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays. If TZEN = , this register can only be modified in secure mode.
            RCC_SPI6CKSELR: mmio.Mmio(packed struct(u32) {
                ///  SPI6SRC
                SPI6SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the USART1. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays. If TZEN = , this register can only be modified in secure mode.
            RCC_UART1CKSELR: mmio.Mmio(packed struct(u32) {
                ///  UART1SRC
                UART1SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the RNG1. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays. If TZEN = , this register can only be modified in secure mode.
            RCC_RNG1CKSELR: mmio.Mmio(packed struct(u32) {
                ///  RNG1SRC
                RNG1SRC: u2,
                padding: u30,
            }),
            ///  This register is used to select an oscillator source as kernel clock for the per_ck clock. The per_ck clock is distributed to several peripherals. Refer to Section: Clock enabling delays.
            RCC_CPERCKSELR: mmio.Mmio(packed struct(u32) {
                ///  CKPERSRC
                CKPERSRC: u2,
                padding: u30,
            }),
            ///  This register is used to select the peripheral clock for the STGEN block. Note that this clock is used to provide a time reference for the application. Refer to Section: Clock enabling delays. If TZEN = , this register can only be modified in secure mode.
            RCC_STGENCKSELR: mmio.Mmio(packed struct(u32) {
                ///  STGENSRC
                STGENSRC: u2,
                padding: u30,
            }),
            ///  This register is used to control the DDR interface, including the DDRC and DDRPHYC. If TZEN = , this register can only be modified in secure mode.
            RCC_DDRITFCR: mmio.Mmio(packed struct(u32) {
                ///  DDRC1EN
                DDRC1EN: u1,
                ///  DDRC1LPEN
                DDRC1LPEN: u1,
                ///  DDRC2EN
                DDRC2EN: u1,
                ///  DDRC2LPEN
                DDRC2LPEN: u1,
                ///  DDRPHYCEN
                DDRPHYCEN: u1,
                ///  DDRPHYCLPEN
                DDRPHYCLPEN: u1,
                ///  DDRCAPBEN
                DDRCAPBEN: u1,
                ///  DDRCAPBLPEN
                DDRCAPBLPEN: u1,
                ///  AXIDCGEN
                AXIDCGEN: u1,
                ///  DDRPHYCAPBEN
                DDRPHYCAPBEN: u1,
                ///  DDRPHYCAPBLPEN
                DDRPHYCAPBLPEN: u1,
                ///  KERDCG_DLY
                KERDCG_DLY: u3,
                ///  DDRCAPBRST
                DDRCAPBRST: u1,
                ///  DDRCAXIRST
                DDRCAXIRST: u1,
                ///  DDRCORERST
                DDRCORERST: u1,
                ///  DPHYAPBRST
                DPHYAPBRST: u1,
                ///  DPHYRST
                DPHYRST: u1,
                ///  DPHYCTLRST
                DPHYCTLRST: u1,
                ///  DDRCKMOD
                DDRCKMOD: u3,
                ///  GSKPMOD
                GSKPMOD: u1,
                ///  GSKPCTRL
                GSKPCTRL: u1,
                ///  DFILP_WIDTH
                DFILP_WIDTH: u3,
                ///  GSKP_DUR
                GSKP_DUR: u4,
            }),
            reserved256: [36]u8,
            ///  This register is used to control the HOLD boot function when the system exits from Standby. Refer to Section: MCU HOLD_BOOT after processor reset. This register is reset when a system reset occurs, but not when the circuit exits from Standby (app_rst reset).If TZEN = , this register can only be modified in secure mode. This register can only be accessed by the MPU.
            RCC_MP_BOOTCR: mmio.Mmio(packed struct(u32) {
                ///  MCU_BEN
                MCU_BEN: u1,
                ///  MPU_BEN
                MPU_BEN: u1,
                padding: u30,
            }),
            ///  Writing has no effect, reading will return the values of the bits. Writing a sets the corresponding bit to . The MCU cannot access to this register. If TZEN = , this register can only be modified in secure mode.
            RCC_MP_SREQSETR: mmio.Mmio(packed struct(u32) {
                ///  STPREQ_P0
                STPREQ_P0: u1,
                ///  STPREQ_P1
                STPREQ_P1: u1,
                padding: u30,
            }),
            ///  Writing has no effect, reading will return the effective values of the bits. Writing a sets the corresponding bit to . The MCU cannot access to this register. If TZEN = , this register can only be modified in secure mode.
            RCC_MP_SREQCLRR: mmio.Mmio(packed struct(u32) {
                ///  STPREQ_P0
                STPREQ_P0: u1,
                ///  STPREQ_P1
                STPREQ_P1: u1,
                padding: u30,
            }),
            ///  The register contains global control bits. If TZEN = , this register can only be modified in secure mode.
            RCC_MP_GCR: mmio.Mmio(packed struct(u32) {
                ///  BOOT_MCU
                BOOT_MCU: u1,
                padding: u31,
            }),
            ///  This register is used to control the behavior of the warm reset. If TZEN = , this register can only be modified in secure mode.
            RCC_MP_APRSTCR: mmio.Mmio(packed struct(u32) {
                ///  RDCTLEN
                RDCTLEN: u1,
                reserved8: u7,
                ///  RSTTO
                RSTTO: u7,
                padding: u17,
            }),
            ///  This register provides a status of the RDCTL. If TZEN = , this register can only be modified in secure mode.
            RCC_MP_APRSTSR: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                ///  RSTTOV
                RSTTOV: u7,
                padding: u17,
            }),
            reserved320: [40]u8,
            ///  This register is used to control the LSE function. Wait states are inserted in case of successive write accesses to this register. The number of wait states may be up to 7 cycles of AHB4 clock.After a system reset, the register RCC_BDCR is write-protected. In order to modify this register, the DBP bit in the PWR control register 1 (PWR_CR1) has to be set to . Bits of RCC_BDCR register are only reset after a backup domain reset: nreset_vsw (see Section10.3.6: Backup domain reset). Any other internal or external reset will not have any effect on these bits.This register is located into the VSW domain. If TZEN = , this register can only be modified in secure mode.
            RCC_BDCR: mmio.Mmio(packed struct(u32) {
                ///  LSEON
                LSEON: u1,
                ///  LSEBYP
                LSEBYP: u1,
                ///  LSERDY
                LSERDY: u1,
                ///  DIGBYP
                DIGBYP: u1,
                ///  LSEDRV
                LSEDRV: u2,
                reserved8: u2,
                ///  LSECSSON
                LSECSSON: u1,
                ///  LSECSSD
                LSECSSD: u1,
                reserved16: u6,
                ///  RTCSRC
                RTCSRC: u2,
                reserved20: u2,
                ///  RTCCKEN
                RTCCKEN: u1,
                reserved31: u10,
                ///  VSWRST
                VSWRST: u1,
            }),
            ///  This register is used to control the minimum NRST active duration and LSI function.0 to 7 wait states are inserted for word, half-word and byte accesses. Wait states are inserted in case of successive accesses to this register.This register is reset by the por_rst reset, and it is located into the VDD domain. If TZEN = , this register can only be modified in secure mode.
            RCC_RDLSICR: mmio.Mmio(packed struct(u32) {
                ///  LSION
                LSION: u1,
                ///  LSIRDY
                LSIRDY: u1,
                reserved16: u14,
                ///  MRD
                MRD: u5,
                reserved24: u3,
                ///  EADLY
                EADLY: u3,
                ///  SPARE
                SPARE: u5,
            }),
            reserved384: [56]u8,
            ///  This register is used to activate the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a activates the reset of the corresponding peripheral.
            RCC_APB4RSTSETR: mmio.Mmio(packed struct(u32) {
                ///  LTDCRST
                LTDCRST: u1,
                reserved4: u3,
                ///  DSIRST
                DSIRST: u1,
                reserved8: u3,
                ///  DDRPERFMRST
                DDRPERFMRST: u1,
                reserved16: u7,
                ///  USBPHYRST
                USBPHYRST: u1,
                padding: u15,
            }),
            ///  This register is used to release the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a releases the reset of the corresponding peripheral.
            RCC_APB4RSTCLRR: mmio.Mmio(packed struct(u32) {
                ///  LTDCRST
                LTDCRST: u1,
                reserved4: u3,
                ///  DSIRST
                DSIRST: u1,
                reserved8: u3,
                ///  DDRPERFMRST
                DDRPERFMRST: u1,
                reserved16: u7,
                ///  USBPHYRST
                USBPHYRST: u1,
                padding: u15,
            }),
            ///  This register is used to activate the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a activates the reset of the corresponding peripheral. If TZEN = , this register can only be modified in secure mode.
            RCC_APB5RSTSETR: mmio.Mmio(packed struct(u32) {
                ///  SPI6RST
                SPI6RST: u1,
                reserved2: u1,
                ///  I2C4RST
                I2C4RST: u1,
                ///  I2C6RST
                I2C6RST: u1,
                ///  USART1RST
                USART1RST: u1,
                reserved20: u15,
                ///  STGENRST
                STGENRST: u1,
                padding: u11,
            }),
            ///  This register is used to release the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a releases the reset of the corresponding peripheral. If TZEN = , this register can only be modified in secure mode.
            RCC_APB5RSTCLRR: mmio.Mmio(packed struct(u32) {
                ///  SPI6RST
                SPI6RST: u1,
                reserved2: u1,
                ///  I2C4RST
                I2C4RST: u1,
                ///  I2C6RST
                I2C6RST: u1,
                ///  USART1RST
                USART1RST: u1,
                reserved20: u15,
                ///  STGENRST
                STGENRST: u1,
                padding: u11,
            }),
            ///  This register is used to activate the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a activates the reset of the corresponding peripheral. If TZEN = , this register can only be modified in secure mode.
            RCC_AHB5RSTSETR: mmio.Mmio(packed struct(u32) {
                ///  GPIOZRST
                GPIOZRST: u1,
                reserved4: u3,
                ///  CRYP1RST
                CRYP1RST: u1,
                ///  HASH1RST
                HASH1RST: u1,
                ///  RNG1RST
                RNG1RST: u1,
                reserved16: u9,
                ///  AXIMCRST
                AXIMCRST: u1,
                padding: u15,
            }),
            ///  This register is used to release the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a releases the reset of the corresponding peripheral. If TZEN = , this register can only be modified in secure mode.
            RCC_AHB5RSTCLRR: mmio.Mmio(packed struct(u32) {
                ///  GPIOZRST
                GPIOZRST: u1,
                reserved4: u3,
                ///  CRYP1RST
                CRYP1RST: u1,
                ///  HASH1RST
                HASH1RST: u1,
                ///  RNG1RST
                RNG1RST: u1,
                reserved16: u9,
                ///  AXIMCRST
                AXIMCRST: u1,
                padding: u15,
            }),
            ///  This register is used to activate the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a activates the reset of the corresponding peripheral.
            RCC_AHB6RSTSETR: mmio.Mmio(packed struct(u32) {
                reserved5: u5,
                ///  GPURST
                GPURST: u1,
                reserved10: u4,
                ///  ETHMACRST
                ETHMACRST: u1,
                reserved12: u1,
                ///  FMCRST
                FMCRST: u1,
                reserved14: u1,
                ///  QSPIRST
                QSPIRST: u1,
                reserved16: u1,
                ///  SDMMC1RST
                SDMMC1RST: u1,
                ///  SDMMC2RST
                SDMMC2RST: u1,
                reserved20: u2,
                ///  CRC1RST
                CRC1RST: u1,
                reserved24: u3,
                ///  USBHRST
                USBHRST: u1,
                padding: u7,
            }),
            ///  This register is used to release the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a releases the reset of the corresponding peripheral.
            RCC_AHB6RSTCLRR: mmio.Mmio(packed struct(u32) {
                reserved10: u10,
                ///  ETHMACRST
                ETHMACRST: u1,
                reserved12: u1,
                ///  FMCRST
                FMCRST: u1,
                reserved14: u1,
                ///  QSPIRST
                QSPIRST: u1,
                reserved16: u1,
                ///  SDMMC1RST
                SDMMC1RST: u1,
                ///  SDMMC2RST
                SDMMC2RST: u1,
                reserved20: u2,
                ///  CRC1RST
                CRC1RST: u1,
                reserved24: u3,
                ///  USBHRST
                USBHRST: u1,
                padding: u7,
            }),
            ///  This register is used to activate the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a activates the reset of the corresponding peripheral. If TZEN = , this register can only be modified in secure mode.
            RCC_TZAHB6RSTSETR: mmio.Mmio(packed struct(u32) {
                ///  MDMARST
                MDMARST: u1,
                padding: u31,
            }),
            ///  This register is used to release the reset of the corresponding peripheral. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a releases the reset of the corresponding peripheral. If TZEN = , this register can only be modified in secure mode.
            RCC_TZAHB6RSTCLRR: mmio.Mmio(packed struct(u32) {
                ///  MDMARST
                MDMARST: u1,
                padding: u31,
            }),
            reserved512: [88]u8,
            ///  This register is used to set the peripheral clock enable bit of the corresponding peripheral to . It shall be used to allocate a peripheral to the MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to .
            RCC_MP_APB4ENSETR: mmio.Mmio(packed struct(u32) {
                ///  LTDCEN
                LTDCEN: u1,
                reserved4: u3,
                ///  DSIEN
                DSIEN: u1,
                reserved8: u3,
                ///  DDRPERFMEN
                DDRPERFMEN: u1,
                reserved15: u6,
                ///  IWDG2APBEN
                IWDG2APBEN: u1,
                ///  USBPHYEN
                USBPHYEN: u1,
                reserved20: u3,
                ///  STGENROEN
                STGENROEN: u1,
                padding: u11,
            }),
            ///  This register is used to clear the peripheral clock enable bit of the corresponding peripheral. It shall be used to deallocate a peripheral from MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to .
            RCC_MP_APB4ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  LTDCEN
                LTDCEN: u1,
                reserved4: u3,
                ///  DSIEN
                DSIEN: u1,
                reserved8: u3,
                ///  DDRPERFMEN
                DDRPERFMEN: u1,
                reserved15: u6,
                ///  IWDG2APBEN
                IWDG2APBEN: u1,
                ///  USBPHYEN
                USBPHYEN: u1,
                reserved20: u3,
                ///  STGENROEN
                STGENROEN: u1,
                padding: u11,
            }),
            ///  This register is used to set the peripheral clock enable bit of the corresponding peripheral to . It shall be used to allocate a peripheral to the MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to .
            RCC_MP_APB5ENSETR: mmio.Mmio(packed struct(u32) {
                ///  SPI6EN
                SPI6EN: u1,
                reserved2: u1,
                ///  I2C4EN
                I2C4EN: u1,
                ///  I2C6EN
                I2C6EN: u1,
                ///  USART1EN
                USART1EN: u1,
                reserved8: u3,
                ///  RTCAPBEN
                RTCAPBEN: u1,
                reserved11: u2,
                ///  TZC1EN
                TZC1EN: u1,
                ///  TZC2EN
                TZC2EN: u1,
                ///  TZPCEN
                TZPCEN: u1,
                reserved15: u1,
                ///  IWDG1APBEN
                IWDG1APBEN: u1,
                ///  BSECEN
                BSECEN: u1,
                reserved20: u3,
                ///  STGENEN
                STGENEN: u1,
                padding: u11,
            }),
            ///  This register is used to clear the peripheral clock enable bit of the corresponding peripheral. It shall be used to deallocate a peripheral from MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to .
            RCC_MP_APB5ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  SPI6EN
                SPI6EN: u1,
                reserved2: u1,
                ///  I2C4EN
                I2C4EN: u1,
                ///  I2C6EN
                I2C6EN: u1,
                ///  USART1EN
                USART1EN: u1,
                reserved8: u3,
                ///  RTCAPBEN
                RTCAPBEN: u1,
                reserved11: u2,
                ///  TZC1EN
                TZC1EN: u1,
                ///  TZC2EN
                TZC2EN: u1,
                ///  TZPCEN
                TZPCEN: u1,
                reserved15: u1,
                ///  IWDG1APBEN
                IWDG1APBEN: u1,
                ///  BSECEN
                BSECEN: u1,
                reserved20: u3,
                ///  STGENEN
                STGENEN: u1,
                padding: u11,
            }),
            ///  This register is used to set the peripheral clock enable bit of the corresponding peripheral to . It shall be used to allocate a peripheral to the MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to . If TZEN = , this register can only be modified in secure mode.
            RCC_MP_AHB5ENSETR: mmio.Mmio(packed struct(u32) {
                ///  GPIOZEN
                GPIOZEN: u1,
                reserved4: u3,
                ///  CRYP1EN
                CRYP1EN: u1,
                ///  HASH1EN
                HASH1EN: u1,
                ///  RNG1EN
                RNG1EN: u1,
                reserved8: u1,
                ///  BKPSRAMEN
                BKPSRAMEN: u1,
                reserved16: u7,
                ///  AXIMCEN
                AXIMCEN: u1,
                padding: u15,
            }),
            ///  This register is used to clear the peripheral clock enable bit of the corresponding peripheral. It shall be used to deallocate a peripheral from MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to . If TZEN = , this register can only be modified in secure mode.
            RCC_MP_AHB5ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  GPIOZEN
                GPIOZEN: u1,
                reserved4: u3,
                ///  CRYP1EN
                CRYP1EN: u1,
                ///  HASH1EN
                HASH1EN: u1,
                ///  RNG1EN
                RNG1EN: u1,
                reserved8: u1,
                ///  BKPSRAMEN
                BKPSRAMEN: u1,
                reserved16: u7,
                ///  AXIMCEN
                AXIMCEN: u1,
                padding: u15,
            }),
            ///  This register is used to set the peripheral clock enable bit of the corresponding peripheral to . It shall be used to allocate a peripheral to the MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to .
            RCC_MP_AHB6ENSETR: mmio.Mmio(packed struct(u32) {
                ///  MDMAEN
                MDMAEN: u1,
                reserved5: u4,
                ///  GPUEN
                GPUEN: u1,
                reserved7: u1,
                ///  ETHCKEN
                ETHCKEN: u1,
                ///  ETHTXEN
                ETHTXEN: u1,
                ///  ETHRXEN
                ETHRXEN: u1,
                ///  ETHMACEN
                ETHMACEN: u1,
                reserved12: u1,
                ///  FMCEN
                FMCEN: u1,
                reserved14: u1,
                ///  QSPIEN
                QSPIEN: u1,
                reserved16: u1,
                ///  SDMMC1EN
                SDMMC1EN: u1,
                ///  SDMMC2EN
                SDMMC2EN: u1,
                reserved20: u2,
                ///  CRC1EN
                CRC1EN: u1,
                reserved24: u3,
                ///  USBHEN
                USBHEN: u1,
                padding: u7,
            }),
            ///  This register is used to clear the peripheral clock enable bit of the corresponding peripheral. It shall be used to deallocate a peripheral from MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to .
            RCC_MP_AHB6ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  MDMAEN
                MDMAEN: u1,
                reserved5: u4,
                ///  GPUEN
                GPUEN: u1,
                reserved7: u1,
                ///  ETHCKEN
                ETHCKEN: u1,
                ///  ETHTXEN
                ETHTXEN: u1,
                ///  ETHRXEN
                ETHRXEN: u1,
                ///  ETHMACEN
                ETHMACEN: u1,
                reserved12: u1,
                ///  FMCEN
                FMCEN: u1,
                reserved14: u1,
                ///  QSPIEN
                QSPIEN: u1,
                reserved16: u1,
                ///  SDMMC1EN
                SDMMC1EN: u1,
                ///  SDMMC2EN
                SDMMC2EN: u1,
                reserved20: u2,
                ///  CRC1EN
                CRC1EN: u1,
                reserved24: u3,
                ///  USBHEN
                USBHEN: u1,
                padding: u7,
            }),
            ///  This register is used to set the peripheral clock enable bit of the corresponding peripheral to . It shall be used to allocate a peripheral to the MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to . If TZEN = , this register can only be modified in secure mode.
            RCC_MP_TZAHB6ENSETR: mmio.Mmio(packed struct(u32) {
                ///  MDMAEN
                MDMAEN: u1,
                padding: u31,
            }),
            ///  This register is used to clear the peripheral clock enable bit of the corresponding peripheral. It shall be used to deallocate a peripheral from MPU. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to . If TZEN = , this register can only be modified in secure mode.
            RCC_MP_TZAHB6ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  MDMAEN
                MDMAEN: u1,
                padding: u31,
            }),
            reserved640: [88]u8,
            ///  This register is used to set the peripheral clock enable bit
            RCC_MC_APB4ENSETR: mmio.Mmio(packed struct(u32) {
                ///  LTDCEN
                LTDCEN: u1,
                reserved4: u3,
                ///  DSIEN
                DSIEN: u1,
                reserved8: u3,
                ///  DDRPERFMEN
                DDRPERFMEN: u1,
                reserved16: u7,
                ///  USBPHYEN
                USBPHYEN: u1,
                reserved20: u3,
                ///  STGENROEN
                STGENROEN: u1,
                padding: u11,
            }),
            ///  This register is used to clear the peripheral clock enable bit
            RCC_MC_APB4ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  LTDCEN
                LTDCEN: u1,
                reserved4: u3,
                ///  DSIEN
                DSIEN: u1,
                reserved8: u3,
                ///  DDRPERFMEN
                DDRPERFMEN: u1,
                reserved16: u7,
                ///  USBPHYEN
                USBPHYEN: u1,
                reserved20: u3,
                ///  STGENROEN
                STGENROEN: u1,
                padding: u11,
            }),
            ///  This register is used to set the peripheral clock enable bit
            RCC_MC_APB5ENSETR: mmio.Mmio(packed struct(u32) {
                ///  SPI6EN
                SPI6EN: u1,
                reserved2: u1,
                ///  I2C4EN
                I2C4EN: u1,
                ///  I2C6EN
                I2C6EN: u1,
                ///  USART1EN
                USART1EN: u1,
                reserved8: u3,
                ///  RTCAPBEN
                RTCAPBEN: u1,
                reserved11: u2,
                ///  TZC1EN
                TZC1EN: u1,
                ///  TZC2EN
                TZC2EN: u1,
                ///  TZPCEN
                TZPCEN: u1,
                reserved16: u2,
                ///  BSECEN
                BSECEN: u1,
                reserved20: u3,
                ///  STGENEN
                STGENEN: u1,
                padding: u11,
            }),
            ///  This register is used to clear the peripheral clock enable bit
            RCC_MC_APB5ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  SPI6EN
                SPI6EN: u1,
                reserved2: u1,
                ///  I2C4EN
                I2C4EN: u1,
                ///  I2C6EN
                I2C6EN: u1,
                ///  USART1EN
                USART1EN: u1,
                reserved8: u3,
                ///  RTCAPBEN
                RTCAPBEN: u1,
                reserved11: u2,
                ///  TZC1EN
                TZC1EN: u1,
                ///  TZC2EN
                TZC2EN: u1,
                ///  TZPCEN
                TZPCEN: u1,
                reserved16: u2,
                ///  BSECEN
                BSECEN: u1,
                reserved20: u3,
                ///  STGENEN
                STGENEN: u1,
                padding: u11,
            }),
            ///  This register is used to set the peripheral clock enable bit If TZEN = , this register can only be modified in secure mode.
            RCC_MC_AHB5ENSETR: mmio.Mmio(packed struct(u32) {
                ///  GPIOZEN
                GPIOZEN: u1,
                reserved4: u3,
                ///  CRYP1EN
                CRYP1EN: u1,
                ///  HASH1EN
                HASH1EN: u1,
                ///  RNG1EN
                RNG1EN: u1,
                reserved8: u1,
                ///  BKPSRAMEN
                BKPSRAMEN: u1,
                padding: u23,
            }),
            ///  This register is used to clear the peripheral clock enable bit If TZEN = , this register can only be modified in secure mode.
            RCC_MC_AHB5ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  GPIOZEN
                GPIOZEN: u1,
                reserved4: u3,
                ///  CRYP1EN
                CRYP1EN: u1,
                ///  HASH1EN
                HASH1EN: u1,
                ///  RNG1EN
                RNG1EN: u1,
                reserved8: u1,
                ///  BKPSRAMEN
                BKPSRAMEN: u1,
                padding: u23,
            }),
            ///  This register is used to set the peripheral clock enable bit
            RCC_MC_AHB6ENSETR: mmio.Mmio(packed struct(u32) {
                ///  MDMAEN
                MDMAEN: u1,
                reserved5: u4,
                ///  GPUEN
                GPUEN: u1,
                reserved7: u1,
                ///  ETHCKEN
                ETHCKEN: u1,
                ///  ETHTXEN
                ETHTXEN: u1,
                ///  ETHRXEN
                ETHRXEN: u1,
                ///  ETHMACEN
                ETHMACEN: u1,
                reserved12: u1,
                ///  FMCEN
                FMCEN: u1,
                reserved14: u1,
                ///  QSPIEN
                QSPIEN: u1,
                reserved16: u1,
                ///  SDMMC1EN
                SDMMC1EN: u1,
                ///  SDMMC2EN
                SDMMC2EN: u1,
                reserved20: u2,
                ///  CRC1EN
                CRC1EN: u1,
                reserved24: u3,
                ///  USBHEN
                USBHEN: u1,
                padding: u7,
            }),
            ///  This register is used to clear the peripheral clock enable bit
            RCC_MC_AHB6ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  MDMAEN
                MDMAEN: u1,
                reserved5: u4,
                ///  GPUEN
                GPUEN: u1,
                reserved7: u1,
                ///  ETHCKEN
                ETHCKEN: u1,
                ///  ETHTXEN
                ETHTXEN: u1,
                ///  ETHRXEN
                ETHRXEN: u1,
                ///  ETHMACEN
                ETHMACEN: u1,
                reserved12: u1,
                ///  FMCEN
                FMCEN: u1,
                reserved14: u1,
                ///  QSPIEN
                QSPIEN: u1,
                reserved16: u1,
                ///  SDMMC1EN
                SDMMC1EN: u1,
                ///  SDMMC2EN
                SDMMC2EN: u1,
                reserved20: u2,
                ///  CRC1EN
                CRC1EN: u1,
                reserved24: u3,
                ///  USBHEN
                USBHEN: u1,
                padding: u7,
            }),
            reserved768: [96]u8,
            ///  This register is used by the MCU in order to clear the PERxLPEN bits
            RCC_MP_APB4LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  LTDCLPEN
                LTDCLPEN: u1,
                reserved4: u3,
                ///  DSILPEN
                DSILPEN: u1,
                reserved8: u3,
                ///  DDRPERFMLPEN
                DDRPERFMLPEN: u1,
                reserved15: u6,
                ///  IWDG2APBLPEN
                IWDG2APBLPEN: u1,
                ///  USBPHYLPEN
                USBPHYLPEN: u1,
                reserved20: u3,
                ///  STGENROLPEN
                STGENROLPEN: u1,
                ///  STGENROSTPEN
                STGENROSTPEN: u1,
                padding: u10,
            }),
            ///  This register is used by the MCU
            RCC_MP_APB4LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  LTDCLPEN
                LTDCLPEN: u1,
                reserved4: u3,
                ///  DSILPEN
                DSILPEN: u1,
                reserved8: u3,
                ///  DDRPERFMLPEN
                DDRPERFMLPEN: u1,
                reserved15: u6,
                ///  IWDG2APBLPEN
                IWDG2APBLPEN: u1,
                ///  USBPHYLPEN
                USBPHYLPEN: u1,
                reserved20: u3,
                ///  STGENROLPEN
                STGENROLPEN: u1,
                ///  STGENROSTPEN
                STGENROSTPEN: u1,
                padding: u10,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bits If TZEN = , this register can only be modified in secure mode.
            RCC_MP_APB5LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  SPI6LPEN
                SPI6LPEN: u1,
                reserved2: u1,
                ///  I2C4LPEN
                I2C4LPEN: u1,
                ///  I2C6LPEN
                I2C6LPEN: u1,
                ///  USART1LPEN
                USART1LPEN: u1,
                reserved8: u3,
                ///  RTCAPBLPEN
                RTCAPBLPEN: u1,
                reserved11: u2,
                ///  TZC1LPEN
                TZC1LPEN: u1,
                ///  TZC2LPEN
                TZC2LPEN: u1,
                ///  TZPCLPEN
                TZPCLPEN: u1,
                reserved15: u1,
                ///  IWDG1APBLPEN
                IWDG1APBLPEN: u1,
                ///  BSECLPEN
                BSECLPEN: u1,
                reserved20: u3,
                ///  STGENLPEN
                STGENLPEN: u1,
                ///  STGENSTPEN
                STGENSTPEN: u1,
                padding: u10,
            }),
            ///  This register is used by the Mpu.
            RCC_MP_APB5LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  SPI6LPEN
                SPI6LPEN: u1,
                reserved2: u1,
                ///  I2C4LPEN
                I2C4LPEN: u1,
                ///  I2C6LPEN
                I2C6LPEN: u1,
                ///  USART1LPEN
                USART1LPEN: u1,
                reserved8: u3,
                ///  RTCAPBLPEN
                RTCAPBLPEN: u1,
                reserved11: u2,
                ///  TZC1LPEN
                TZC1LPEN: u1,
                ///  TZC2LPEN
                TZC2LPEN: u1,
                ///  TZPCLPEN
                TZPCLPEN: u1,
                reserved15: u1,
                ///  IWDG1APBLPEN
                IWDG1APBLPEN: u1,
                ///  BSECLPEN
                BSECLPEN: u1,
                reserved20: u3,
                ///  STGENLPEN
                STGENLPEN: u1,
                ///  STGENSTPEN
                STGENSTPEN: u1,
                padding: u10,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bits If TZEN = , this register can only be modified in secure mode.
            RCC_MP_AHB5LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  GPIOZLPEN
                GPIOZLPEN: u1,
                reserved4: u3,
                ///  CRYP1LPEN
                CRYP1LPEN: u1,
                ///  HASH1LPEN
                HASH1LPEN: u1,
                ///  RNG1LPEN
                RNG1LPEN: u1,
                reserved8: u1,
                ///  BKPSRAMLPEN
                BKPSRAMLPEN: u1,
                padding: u23,
            }),
            ///  This register is used by the MCU
            RCC_MP_AHB5LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  GPIOZLPEN
                GPIOZLPEN: u1,
                reserved4: u3,
                ///  CRYP1LPEN
                CRYP1LPEN: u1,
                ///  HASH1LPEN
                HASH1LPEN: u1,
                ///  RNG1LPEN
                RNG1LPEN: u1,
                reserved8: u1,
                ///  BKPSRAMLPEN
                BKPSRAMLPEN: u1,
                padding: u23,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bits
            RCC_MP_AHB6LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  MDMALPEN
                MDMALPEN: u1,
                reserved5: u4,
                ///  GPULPEN
                GPULPEN: u1,
                reserved7: u1,
                ///  ETHCKLPEN
                ETHCKLPEN: u1,
                ///  ETHTXLPEN
                ETHTXLPEN: u1,
                ///  ETHRXLPEN
                ETHRXLPEN: u1,
                ///  ETHMACLPEN
                ETHMACLPEN: u1,
                ///  ETHSTPEN
                ETHSTPEN: u1,
                ///  FMCLPEN
                FMCLPEN: u1,
                reserved14: u1,
                ///  QSPILPEN
                QSPILPEN: u1,
                reserved16: u1,
                ///  SDMMC1LPEN
                SDMMC1LPEN: u1,
                ///  SDMMC2LPEN
                SDMMC2LPEN: u1,
                reserved20: u2,
                ///  CRC1LPEN
                CRC1LPEN: u1,
                reserved24: u3,
                ///  USBHLPEN
                USBHLPEN: u1,
                padding: u7,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bits
            RCC_MP_AHB6LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  MDMALPEN
                MDMALPEN: u1,
                reserved5: u4,
                ///  GPULPEN
                GPULPEN: u1,
                reserved7: u1,
                ///  ETHCKLPEN
                ETHCKLPEN: u1,
                ///  ETHTXLPEN
                ETHTXLPEN: u1,
                ///  ETHRXLPEN
                ETHRXLPEN: u1,
                ///  ETHMACLPEN
                ETHMACLPEN: u1,
                ///  ETHSTPEN
                ETHSTPEN: u1,
                ///  FMCLPEN
                FMCLPEN: u1,
                reserved14: u1,
                ///  QSPILPEN
                QSPILPEN: u1,
                reserved16: u1,
                ///  SDMMC1LPEN
                SDMMC1LPEN: u1,
                ///  SDMMC2LPEN
                SDMMC2LPEN: u1,
                reserved20: u2,
                ///  CRC1LPEN
                CRC1LPEN: u1,
                reserved24: u3,
                ///  USBHLPEN
                USBHLPEN: u1,
                padding: u7,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bits If TZEN = , this register can only be modified in secure mode.
            RCC_MP_TZAHB6LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  MDMALPEN
                MDMALPEN: u1,
                padding: u31,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bits If TZEN = , this register can only be modified in secure mode.
            RCC_MP_TZAHB6LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  MDMALPEN
                MDMALPEN: u1,
                padding: u31,
            }),
            reserved896: [88]u8,
            ///  This register is used by the MCU in order to set the PERxLPEN bit.
            RCC_MC_APB4LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  LTDCLPEN
                LTDCLPEN: u1,
                reserved4: u3,
                ///  DSILPEN
                DSILPEN: u1,
                reserved8: u3,
                ///  DDRPERFMLPEN
                DDRPERFMLPEN: u1,
                reserved16: u7,
                ///  USBPHYLPEN
                USBPHYLPEN: u1,
                reserved20: u3,
                ///  STGENROLPEN
                STGENROLPEN: u1,
                ///  STGENROSTPEN
                STGENROSTPEN: u1,
                padding: u10,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bit
            RCC_MC_APB4LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  LTDCLPEN
                LTDCLPEN: u1,
                reserved4: u3,
                ///  DSILPEN
                DSILPEN: u1,
                reserved8: u3,
                ///  DDRPERFMLPEN
                DDRPERFMLPEN: u1,
                reserved16: u7,
                ///  USBPHYLPEN
                USBPHYLPEN: u1,
                reserved20: u3,
                ///  STGENROLPEN
                STGENROLPEN: u1,
                ///  STGENROSTPEN
                STGENROSTPEN: u1,
                padding: u10,
            }),
            ///  This register is used by the MCU in order to set the PERxLPEN bit.
            RCC_MC_APB5LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  SPI6LPEN
                SPI6LPEN: u1,
                reserved2: u1,
                ///  I2C4LPEN
                I2C4LPEN: u1,
                ///  I2C6LPEN
                I2C6LPEN: u1,
                ///  USART1LPEN
                USART1LPEN: u1,
                reserved8: u3,
                ///  RTCAPBLPEN
                RTCAPBLPEN: u1,
                reserved11: u2,
                ///  TZC1LPEN
                TZC1LPEN: u1,
                ///  TZC2LPEN
                TZC2LPEN: u1,
                ///  TZPCLPEN
                TZPCLPEN: u1,
                reserved16: u2,
                ///  BSECLPEN
                BSECLPEN: u1,
                reserved20: u3,
                ///  STGENLPEN
                STGENLPEN: u1,
                ///  STGENSTPEN
                STGENSTPEN: u1,
                padding: u10,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bit
            RCC_MC_APB5LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  SPI6LPEN
                SPI6LPEN: u1,
                reserved2: u1,
                ///  I2C4LPEN
                I2C4LPEN: u1,
                ///  I2C6LPEN
                I2C6LPEN: u1,
                ///  USART1LPEN
                USART1LPEN: u1,
                reserved8: u3,
                ///  RTCAPBLPEN
                RTCAPBLPEN: u1,
                reserved11: u2,
                ///  TZC1LPEN
                TZC1LPEN: u1,
                ///  TZC2LPEN
                TZC2LPEN: u1,
                ///  TZPCLPEN
                TZPCLPEN: u1,
                reserved16: u2,
                ///  BSECLPEN
                BSECLPEN: u1,
                reserved20: u3,
                ///  STGENLPEN
                STGENLPEN: u1,
                ///  STGENSTPEN
                STGENSTPEN: u1,
                padding: u10,
            }),
            ///  This register is used by the MCU in order to set the PERxLPEN bit. If TZEN = , this register can only be modified in secure mode.
            RCC_MC_AHB5LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  GPIOZLPEN
                GPIOZLPEN: u1,
                reserved4: u3,
                ///  CRYP1LPEN
                CRYP1LPEN: u1,
                ///  HASH1LPEN
                HASH1LPEN: u1,
                ///  RNG1LPEN
                RNG1LPEN: u1,
                reserved8: u1,
                ///  BKPSRAMLPEN
                BKPSRAMLPEN: u1,
                padding: u23,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bit If TZEN = , this register can only be modified in secure mode.
            RCC_MC_AHB5LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  GPIOZLPEN
                GPIOZLPEN: u1,
                reserved4: u3,
                ///  CRYP1LPEN
                CRYP1LPEN: u1,
                ///  HASH1LPEN
                HASH1LPEN: u1,
                ///  RNG1LPEN
                RNG1LPEN: u1,
                reserved8: u1,
                ///  BKPSRAMLPEN
                BKPSRAMLPEN: u1,
                padding: u23,
            }),
            ///  This register is used by the MCU in order to set the PERxLPEN bit.
            RCC_MC_AHB6LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  MDMALPEN
                MDMALPEN: u1,
                reserved5: u4,
                ///  GPULPEN
                GPULPEN: u1,
                reserved7: u1,
                ///  ETHCKLPEN
                ETHCKLPEN: u1,
                ///  ETHTXLPEN
                ETHTXLPEN: u1,
                ///  ETHRXLPEN
                ETHRXLPEN: u1,
                ///  ETHMACLPEN
                ETHMACLPEN: u1,
                ///  ETHSTPEN
                ETHSTPEN: u1,
                ///  FMCLPEN
                FMCLPEN: u1,
                reserved14: u1,
                ///  QSPILPEN
                QSPILPEN: u1,
                reserved16: u1,
                ///  SDMMC1LPEN
                SDMMC1LPEN: u1,
                ///  SDMMC2LPEN
                SDMMC2LPEN: u1,
                reserved20: u2,
                ///  CRC1LPEN
                CRC1LPEN: u1,
                reserved24: u3,
                ///  USBHLPEN
                USBHLPEN: u1,
                padding: u7,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bit
            RCC_MC_AHB6LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  MDMALPEN
                MDMALPEN: u1,
                reserved5: u4,
                ///  GPULPEN
                GPULPEN: u1,
                reserved7: u1,
                ///  ETHCKLPEN
                ETHCKLPEN: u1,
                ///  ETHTXLPEN
                ETHTXLPEN: u1,
                ///  ETHRXLPEN
                ETHRXLPEN: u1,
                ///  ETHMACLPEN
                ETHMACLPEN: u1,
                ///  ETHSTPEN
                ETHSTPEN: u1,
                ///  FMCLPEN
                FMCLPEN: u1,
                reserved14: u1,
                ///  QSPILPEN
                QSPILPEN: u1,
                reserved16: u1,
                ///  SDMMC1LPEN
                SDMMC1LPEN: u1,
                ///  SDMMC2LPEN
                SDMMC2LPEN: u1,
                reserved20: u2,
                ///  CRC1LPEN
                CRC1LPEN: u1,
                reserved24: u3,
                ///  USBHLPEN
                USBHLPEN: u1,
                padding: u7,
            }),
            reserved1024: [96]u8,
            ///  This register is used by the BOOTROM to check the reset source. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a clears the corresponding bit to . In order to identify the reset source, the MPU application must use RCC MPU Reset Status Clear Register (RCC_MP_RSTSCLRR), and the MCU application must use the RCC MCU Reset Status Clear Register (RCC_MC_RSTSCLRR). Refer to Section10.3.13: Reset source identification for details.This register except MPUP[1:0]RSTF flags is located into VDD domain, and is reset by por_rst reset. The MPUP[1:0]RSTF flags are located into VDDCORE and are reset by nreset. If TZEN = , this register can only be modified in secure mode.
            RCC_BR_RSTSCLRR: mmio.Mmio(packed struct(u32) {
                ///  PORRSTF
                PORRSTF: u1,
                ///  BORRSTF
                BORRSTF: u1,
                ///  PADRSTF
                PADRSTF: u1,
                ///  HCSSRSTF
                HCSSRSTF: u1,
                ///  VCORERSTF
                VCORERSTF: u1,
                reserved6: u1,
                ///  MPSYSRSTF
                MPSYSRSTF: u1,
                ///  MCSYSRSTF
                MCSYSRSTF: u1,
                ///  IWDG1RSTF
                IWDG1RSTF: u1,
                ///  IWDG2RSTF
                IWDG2RSTF: u1,
                reserved13: u3,
                ///  MPUP0RSTF
                MPUP0RSTF: u1,
                ///  MPUP1RSTF
                MPUP1RSTF: u1,
                padding: u17,
            }),
            ///  This register is used by the MPU in order to generate either a MCU reset or a system reset or a reset of one of the two MPU processors. Writing has no effect, reading returns the effective values of the corresponding bits. Writing a activates the reset.
            RCC_MP_GRSTCSETR: mmio.Mmio(packed struct(u32) {
                ///  MPSYSRST
                MPSYSRST: u1,
                ///  MCURST
                MCURST: u1,
                reserved4: u2,
                ///  MPUP0RST
                MPUP0RST: u1,
                ///  MPUP1RST
                MPUP1RST: u1,
                padding: u26,
            }),
            ///  This register is used by the MPU to check the reset source. This register is updated by the BOOTROM code, after a power-on reset (por_rst), a system reset (nreset), or an exit from Standby or CStandby.Writing has no effect, reading will return the effective values of the corresponding bits. Writing a clears the corresponding bit to .Refer to Section10.3.13: Reset source identification for details.The register is located in VDDCORE.If TZEN = , this register can only be modified in secure mode.
            RCC_MP_RSTSCLRR: mmio.Mmio(packed struct(u32) {
                ///  PORRSTF
                PORRSTF: u1,
                ///  BORRSTF
                BORRSTF: u1,
                ///  PADRSTF
                PADRSTF: u1,
                ///  HCSSRSTF
                HCSSRSTF: u1,
                ///  VCORERSTF
                VCORERSTF: u1,
                reserved6: u1,
                ///  MPSYSRSTF
                MPSYSRSTF: u1,
                ///  MCSYSRSTF
                MCSYSRSTF: u1,
                ///  IWDG1RSTF
                IWDG1RSTF: u1,
                ///  IWDG2RSTF
                IWDG2RSTF: u1,
                reserved11: u1,
                ///  STDBYRSTF
                STDBYRSTF: u1,
                ///  CSTDBYRSTF
                CSTDBYRSTF: u1,
                ///  MPUP0RSTF
                MPUP0RSTF: u1,
                ///  MPUP1RSTF
                MPUP1RSTF: u1,
                ///  SPARE
                SPARE: u1,
                padding: u16,
            }),
            ///  This register is used by the BOOTROM in order to freeze the IWDGs clocks. After a system reset or Standby reset (nreset), or a CStandby reset (cstby_rst) the MPU is allowed to write it once.Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to . If TZEN = , this register can only be modified in secure mode.
            RCC_MP_IWDGFZSETR: mmio.Mmio(packed struct(u32) {
                ///  FZ_IWDG1
                FZ_IWDG1: u1,
                ///  FZ_IWDG2
                FZ_IWDG2: u1,
                padding: u30,
            }),
            ///  This register is used by the BOOTROM in order to unfreeze the IWDGs clocks. Writing has no effect, reading will return the effective values of the corresponding bits. Writing a clears the corresponding bit to . If TZEN = , this register can only be modified in secure mode.
            RCC_MP_IWDGFZCLRR: mmio.Mmio(packed struct(u32) {
                ///  FZ_IWDG1
                FZ_IWDG1: u1,
                ///  FZ_IWDG2
                FZ_IWDG2: u1,
                padding: u30,
            }),
            ///  This register shall be used by the MPU to control the interrupt source enable. Refer to Section10.5: RCC interrupts for more details. If TZEN = , this register can only be modified in secure mode.
            RCC_MP_CIER: mmio.Mmio(packed struct(u32) {
                ///  LSIRDYIE
                LSIRDYIE: u1,
                ///  LSERDYIE
                LSERDYIE: u1,
                ///  HSIRDYIE
                HSIRDYIE: u1,
                ///  HSERDYIE
                HSERDYIE: u1,
                ///  CSIRDYIE
                CSIRDYIE: u1,
                reserved8: u3,
                ///  PLL1DYIE
                PLL1DYIE: u1,
                ///  PLL2DYIE
                PLL2DYIE: u1,
                ///  PLL3DYIE
                PLL3DYIE: u1,
                ///  PLL4DYIE
                PLL4DYIE: u1,
                reserved16: u4,
                ///  LSECSSIE
                LSECSSIE: u1,
                reserved20: u3,
                ///  WKUPIE
                WKUPIE: u1,
                padding: u11,
            }),
            ///  This register shall be used by the MPU in order to read and clear the interrupt flags.Writing has no effect, writing will clear the corresponding flag.Refer to Section10.5: RCC interrupts for more details. If TZEN = , this register can only be modified in secure mode.
            RCC_MP_CIFR: mmio.Mmio(packed struct(u32) {
                ///  LSIRDYF
                LSIRDYF: u1,
                ///  LSERDYF
                LSERDYF: u1,
                ///  HSIRDYF
                HSIRDYF: u1,
                ///  HSERDYF
                HSERDYF: u1,
                ///  CSIRDYF
                CSIRDYF: u1,
                reserved8: u3,
                ///  PLL1DYF
                PLL1DYF: u1,
                ///  PLL2DYF
                PLL2DYF: u1,
                ///  PLL3DYF
                PLL3DYF: u1,
                ///  PLL4DYF
                PLL4DYF: u1,
                reserved16: u4,
                ///  LSECSSF
                LSECSSF: u1,
                reserved20: u3,
                ///  WKUPF
                WKUPF: u1,
                padding: u11,
            }),
            ///  This register is used to program the delay between the moment where the system exits from one of the Stop modes, and the moment where it is allowed to enable the PLLs and provide a clock to bridges and processors. If TZEN = , this register can only be modified in secure mode.
            RCC_PWRLPDLYCR: mmio.Mmio(packed struct(u32) {
                ///  PWRLP_DLY
                PWRLP_DLY: u22,
                reserved24: u2,
                ///  MCTMPSKP
                MCTMPSKP: u1,
                padding: u7,
            }),
            ///  This register is dedicated to the BOOTROM code in order to update the reset source. This register is updated by the BOOTROM code, after a power-on reset (por_rst), a system reset (nreset), or an exit from Standby or CStandby. The application software shall not use this register. In order to identify the reset source, the MPU application must use RCC MPU Reset Status Clear Register (RCC_MP_RSTSCLRR), and the MCU application must use the RCC MCU Reset Status Clear Register (RCC_MC_RSTSCLRR).Writing has no effect, reading will return the effective values of the corresponding bits. Writing a sets the corresponding bit to .Refer to Section10.3.13: Reset source identification for details.The register is located in VDDCORE.If TZEN = , this register can only be modified in secure mode.
            RCC_MP_RSTSSETR: mmio.Mmio(packed struct(u32) {
                ///  PORRSTF
                PORRSTF: u1,
                ///  BORRSTF
                BORRSTF: u1,
                ///  PADRSTF
                PADRSTF: u1,
                ///  HCSSRSTF
                HCSSRSTF: u1,
                ///  VCORERSTF
                VCORERSTF: u1,
                reserved6: u1,
                ///  MPSYSRSTF
                MPSYSRSTF: u1,
                ///  MCSYSRSTF
                MCSYSRSTF: u1,
                ///  IWDG1RSTF
                IWDG1RSTF: u1,
                ///  IWDG2RSTF
                IWDG2RSTF: u1,
                reserved11: u1,
                ///  STDBYRSTF
                STDBYRSTF: u1,
                ///  CSTDBYRSTF
                CSTDBYRSTF: u1,
                ///  MPUP0RSTF
                MPUP0RSTF: u1,
                ///  MPUP1RSTF
                MPUP1RSTF: u1,
                ///  SPARE
                SPARE: u1,
                padding: u16,
            }),
            reserved2048: [988]u8,
            ///  This register is used to select the clock generated on MCO1 output.
            RCC_MCO1CFGR: mmio.Mmio(packed struct(u32) {
                ///  MCO1SEL
                MCO1SEL: u3,
                reserved4: u1,
                ///  MCO1DIV
                MCO1DIV: u4,
                reserved12: u4,
                ///  MCO1ON
                MCO1ON: u1,
                padding: u19,
            }),
            ///  This register is used to select the clock generated on MCO2 output.
            RCC_MCO2CFGR: mmio.Mmio(packed struct(u32) {
                ///  MCO2SEL
                MCO2SEL: u3,
                reserved4: u1,
                ///  MCO2DIV
                MCO2DIV: u4,
                reserved12: u4,
                ///  MCO2ON
                MCO2ON: u1,
                padding: u19,
            }),
            ///  This is a read-only access register, It contains the status flags of oscillators. Writing has no effect.
            RCC_OCRDYR: mmio.Mmio(packed struct(u32) {
                ///  HSIRDY
                HSIRDY: u1,
                reserved2: u1,
                ///  HSIDIVRDY
                HSIDIVRDY: u1,
                reserved4: u1,
                ///  CSIRDY
                CSIRDY: u1,
                reserved8: u3,
                ///  HSERDY
                HSERDY: u1,
                reserved23: u14,
                ///  MPUCKRDY
                MPUCKRDY: u1,
                ///  AXICKRDY
                AXICKRDY: u1,
                ///  CKREST
                CKREST: u1,
                padding: u6,
            }),
            ///  This is register contains the enable control of the debug and trace function, and the clock divider for the trace function.
            RCC_DBGCFGR: mmio.Mmio(packed struct(u32) {
                ///  TRACEDIV
                TRACEDIV: u3,
                reserved8: u5,
                ///  DBGCKEN
                DBGCKEN: u1,
                ///  TRACECKEN
                TRACECKEN: u1,
                reserved12: u2,
                ///  DBGRST
                DBGRST: u1,
                padding: u19,
            }),
            reserved2080: [16]u8,
            ///  This register is used to select the reference clock for PLL3. If TZEN = MCKPROT = , this register can only be modified in secure mode.
            RCC_RCK3SELR: mmio.Mmio(packed struct(u32) {
                ///  PLL3SRC
                PLL3SRC: u2,
                reserved31: u29,
                ///  PLL3SRCRDY
                PLL3SRCRDY: u1,
            }),
            ///  This register is used to select the reference clock for PLL4.
            RCC_RCK4SELR: mmio.Mmio(packed struct(u32) {
                ///  PLL4SRC
                PLL4SRC: u2,
                reserved31: u29,
                ///  PLL4SRCRDY
                PLL4SRCRDY: u1,
            }),
            ///  This register is used to control the prescaler value of timers located into APB1 domain. It concerns TIM2, TIM3, TIM4, TIM5, TIM6, TIM7, TIM12, TIM13 and TIM14. Refer to Section: Sub-system clock generation for additional information.
            RCC_TIMG1PRER: mmio.Mmio(packed struct(u32) {
                ///  TIMG1PRE
                TIMG1PRE: u1,
                reserved31: u30,
                ///  TIMG1PRERDY
                TIMG1PRERDY: u1,
            }),
            ///  This register is used to control the prescaler value of timers located into APB2 domain. It concerns TIM1, TIM8, TIM15, TIM16, and TIM17. Refer to Section: Sub-system clock generation for additional information.
            RCC_TIMG2PRER: mmio.Mmio(packed struct(u32) {
                ///  TIMG2PRE
                TIMG2PRE: u1,
                reserved31: u30,
                ///  TIMG2PRERDY
                TIMG2PRERDY: u1,
            }),
            ///  This register is used to control the MCU sub-system clock prescaler. Refer to Section: Sub-system clock generation for additional information. If TZEN = , this register can only be modified in secure mode.
            RCC_MCUDIVR: mmio.Mmio(packed struct(u32) {
                ///  MCUDIV
                MCUDIV: u4,
                reserved31: u27,
                ///  MCUDIVRDY
                MCUDIVRDY: u1,
            }),
            ///  This register is used to control the APB1 clock prescaler. Refer to section Section1.4.6.3: Sub-System Clock Generation for additional information.
            RCC_APB1DIVR: mmio.Mmio(packed struct(u32) {
                ///  APB1DIV
                APB1DIV: u3,
                reserved31: u28,
                ///  APB1DIVRDY
                APB1DIVRDY: u1,
            }),
            ///  This register is used to control the APB2 clock prescaler. Refer to Section: Sub-system clock generation for additional information.
            RCC_APB2DIVR: mmio.Mmio(packed struct(u32) {
                ///  APB2DIV
                APB2DIV: u3,
                reserved31: u28,
                ///  APB2DIVRDY
                APB2DIVRDY: u1,
            }),
            ///  This register is used to control the APB3 clock prescaler. Refer to Section: Sub-system clock generation for additional information.
            RCC_APB3DIVR: mmio.Mmio(packed struct(u32) {
                ///  APB3DIV
                APB3DIV: u3,
                reserved31: u28,
                ///  APB3DIVRDY
                APB3DIVRDY: u1,
            }),
            reserved2176: [64]u8,
            ///  This register is used to control the PLL3. If TZEN = MCKPROT = , this register can only be modified in secure mode.
            RCC_PLL3CR: mmio.Mmio(packed struct(u32) {
                ///  PLLON
                PLLON: u1,
                ///  PLL3RDY
                PLL3RDY: u1,
                ///  SSCG_CTRL
                SSCG_CTRL: u1,
                reserved4: u1,
                ///  DIVPEN
                DIVPEN: u1,
                ///  DIVQEN
                DIVQEN: u1,
                ///  DIVREN
                DIVREN: u1,
                padding: u25,
            }),
            ///  This register is used to configure the PLL3. If TZEN = MCKPROT = , this register can only be modified in secure mode.
            RCC_PLL3CFGR1: mmio.Mmio(packed struct(u32) {
                ///  DIVN
                DIVN: u9,
                reserved16: u7,
                ///  DIVM3
                DIVM3: u6,
                reserved24: u2,
                ///  IFRGE
                IFRGE: u2,
                padding: u6,
            }),
            ///  This register is used to configure the PLL3. If TZEN = MCKPROT = , this register can only be modified in secure mode.
            RCC_PLL3CFGR2: mmio.Mmio(packed struct(u32) {
                ///  DIVP
                DIVP: u7,
                reserved8: u1,
                ///  DIVQ
                DIVQ: u7,
                reserved16: u1,
                ///  DIVR
                DIVR: u7,
                padding: u9,
            }),
            ///  This register is used to fine-tune the frequency of the PLL3 VCO. If TZEN = MCKPROT = , this register can only be modified in secure mode.
            RCC_PLL3FRACR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  FRACV
                FRACV: u13,
                ///  FRACLE
                FRACLE: u1,
                padding: u15,
            }),
            ///  This register is used to configure the PLL3.It is not recommended to change the content of this register when the PLL3 is enabled (PLLON = ). Refer to Section: Using the PLLs in spread spectrum mode for details. If TZEN = MCKPROT = , this register can only be modified in secure mode.
            RCC_PLL3CSGR: mmio.Mmio(packed struct(u32) {
                ///  MOD_PER
                MOD_PER: u13,
                ///  TPDFN_DIS
                TPDFN_DIS: u1,
                ///  RPDFN_DIS
                RPDFN_DIS: u1,
                ///  SSCG_MODE
                SSCG_MODE: u1,
                ///  INC_STEP
                INC_STEP: u15,
                padding: u1,
            }),
            ///  This register is used to control the PLL4.
            RCC_PLL4CR: mmio.Mmio(packed struct(u32) {
                ///  PLLON
                PLLON: u1,
                ///  PLL4RDY
                PLL4RDY: u1,
                ///  SSCG_CTRL
                SSCG_CTRL: u1,
                reserved4: u1,
                ///  DIVPEN
                DIVPEN: u1,
                ///  DIVQEN
                DIVQEN: u1,
                ///  DIVREN
                DIVREN: u1,
                padding: u25,
            }),
            ///  This register is used to configure the PLL4.
            RCC_PLL4CFGR1: mmio.Mmio(packed struct(u32) {
                ///  DIVN
                DIVN: u9,
                reserved16: u7,
                ///  DIVM4
                DIVM4: u6,
                reserved24: u2,
                ///  IFRGE
                IFRGE: u2,
                padding: u6,
            }),
            ///  This register is used to configure the PLL4.
            RCC_PLL4CFGR2: mmio.Mmio(packed struct(u32) {
                ///  DIVP
                DIVP: u7,
                reserved8: u1,
                ///  DIVQ
                DIVQ: u7,
                reserved16: u1,
                ///  DIVR
                DIVR: u7,
                padding: u9,
            }),
            ///  This register is used to fine-tune the frequency of the PLL4 VCO.
            RCC_PLL4FRACR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  FRACV
                FRACV: u13,
                ///  FRACLE
                FRACLE: u1,
                padding: u15,
            }),
            ///  This register is used to configure the PLL4.It is not recommended to change the content of this register when the PLL4 is enabled (PLLON = ). Refer to Section: Using the PLLs in spread spectrum mode for details. If TZEN = MCKPROT = , this register can only be modified in secure mode.
            RCC_PLL4CSGR: mmio.Mmio(packed struct(u32) {
                ///  MOD_PER
                MOD_PER: u13,
                ///  TPDFN_DIS
                TPDFN_DIS: u1,
                ///  RPDFN_DIS
                RPDFN_DIS: u1,
                ///  SSCG_MODE
                SSCG_MODE: u1,
                ///  INC_STEP
                INC_STEP: u15,
                padding: u1,
            }),
            reserved2240: [24]u8,
            ///  This register is used to control the selection of the kernel clock for the I2C1 and I2C2. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_I2C12CKSELR: mmio.Mmio(packed struct(u32) {
                ///  I2C12SRC
                I2C12SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the I2C3 and I2C5. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_I2C35CKSELR: mmio.Mmio(packed struct(u32) {
                ///  I2C35SRC
                I2C35SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the SAI1 and DFSDM audio clock. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_SAI1CKSELR: mmio.Mmio(packed struct(u32) {
                ///  SAI1SRC
                SAI1SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the SAI2. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_SAI2CKSELR: mmio.Mmio(packed struct(u32) {
                ///  SAI2SRC
                SAI2SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the SAI3. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_SAI3CKSELR: mmio.Mmio(packed struct(u32) {
                ///  SAI3SRC
                SAI3SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the SAI4. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_SAI4CKSELR: mmio.Mmio(packed struct(u32) {
                ///  SAI4SRC
                SAI4SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the SPI/I2S1. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_SPI2S1CKSELR: mmio.Mmio(packed struct(u32) {
                ///  SPI1SRC
                SPI1SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the SPI/I2S2,3. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_SPI2S23CKSELR: mmio.Mmio(packed struct(u32) {
                ///  SPI23SRC
                SPI23SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the SPI4,5. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_SPI45CKSELR: mmio.Mmio(packed struct(u32) {
                ///  SPI45SRC
                SPI45SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the USART6. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_UART6CKSELR: mmio.Mmio(packed struct(u32) {
                ///  UART6SRC
                UART6SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the USART2 and UART4. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_UART24CKSELR: mmio.Mmio(packed struct(u32) {
                ///  UART24SRC
                UART24SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the USART3 and UART5. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_UART35CKSELR: mmio.Mmio(packed struct(u32) {
                ///  UART35SRC
                UART35SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the UART7 and UART8. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_UART78CKSELR: mmio.Mmio(packed struct(u32) {
                ///  UART78SRC
                UART78SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the SDMMC1 and SDMMC2. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_SDMMC12CKSELR: mmio.Mmio(packed struct(u32) {
                ///  SDMMC12SRC
                SDMMC12SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the SDMMC3. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_SDMMC3CKSELR: mmio.Mmio(packed struct(u32) {
                ///  SDMMC3SRC
                SDMMC3SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the ETH block. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_ETHCKSELR: mmio.Mmio(packed struct(u32) {
                ///  ETHSRC
                ETHSRC: u2,
                reserved4: u2,
                ///  ETHPTPDIV
                ETHPTPDIV: u4,
                padding: u24,
            }),
            ///  This register is used to control the selection of the kernel clock for the QUADSPI. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_QSPICKSELR: mmio.Mmio(packed struct(u32) {
                ///  QSPISRC
                QSPISRC: u2,
                padding: u30,
            }),
            ///  This register is used to control the selection of the kernel clock for the FMC block. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_FMCCKSELR: mmio.Mmio(packed struct(u32) {
                ///  FMCSRC
                FMCSRC: u2,
                padding: u30,
            }),
            reserved2316: [4]u8,
            ///  This register is used to control the selection of the kernel clock for the FDCAN block. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_FDCANCKSELR: mmio.Mmio(packed struct(u32) {
                ///  FDCANSRC
                FDCANSRC: u2,
                padding: u30,
            }),
            reserved2324: [4]u8,
            ///  This register is used to control the selection of the kernel clock for the SPDIFRX. Note that changing the clock source on-the-fly is allowed, and will not generate any timing violation, however the user has to ensure that both the previous and the new clock sources are present during the switching, and for the whole transition time. Refer to Section: Clock enabling delays.
            RCC_SPDIFCKSELR: mmio.Mmio(packed struct(u32) {
                ///  SPDIFSRC
                SPDIFSRC: u2,
                padding: u30,
            }),
            ///  This register is used to control the selection of the kernel clock for the CEC-HDMI.
            RCC_CECCKSELR: mmio.Mmio(packed struct(u32) {
                ///  CECSRC
                CECSRC: u2,
                padding: u30,
            }),
            ///  This register is used to control the selection of the kernel clock for the USBPHY PLL of the USB HOST and USB OTG
            RCC_USBCKSELR: mmio.Mmio(packed struct(u32) {
                ///  USBPHYSRC
                USBPHYSRC: u2,
                reserved4: u2,
                ///  USBOSRC
                USBOSRC: u1,
                padding: u27,
            }),
            ///  This register is used to control the selection of the kernel clock for the RNG2.
            RCC_RNG2CKSELR: mmio.Mmio(packed struct(u32) {
                ///  RNG2SRC
                RNG2SRC: u2,
                padding: u30,
            }),
            ///  This register is used to control the selection of the kernel clock for the DSI block.
            RCC_DSICKSELR: mmio.Mmio(packed struct(u32) {
                ///  DSISRC
                DSISRC: u1,
                padding: u31,
            }),
            ///  This register is used to control the selection of the kernel clock for the ADC block.
            RCC_ADCCKSELR: mmio.Mmio(packed struct(u32) {
                ///  ADCSRC
                ADCSRC: u2,
                padding: u30,
            }),
            ///  This register is used to control the selection of the kernel clock for the LPTIM4 and LPTIM5 blocks.
            RCC_LPTIM45CKSELR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM45SRC
                LPTIM45SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the LPTIM2 and LPTIM3 blocks.
            RCC_LPTIM23CKSELR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM23SRC
                LPTIM23SRC: u3,
                padding: u29,
            }),
            ///  This register is used to control the selection of the kernel clock for the LPTIM1 block.
            RCC_LPTIM1CKSELR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM1SRC
                LPTIM1SRC: u3,
                padding: u29,
            }),
            reserved2432: [72]u8,
            ///  This register is used to activate the reset of the corresponding peripheral.
            RCC_APB1RSTSETR: mmio.Mmio(packed struct(u32) {
                ///  TIM2RST
                TIM2RST: u1,
                ///  TIM3RST
                TIM3RST: u1,
                ///  TIM4RST
                TIM4RST: u1,
                ///  TIM5RST
                TIM5RST: u1,
                ///  TIM6RST
                TIM6RST: u1,
                ///  TIM7RST
                TIM7RST: u1,
                ///  TIM12RST
                TIM12RST: u1,
                ///  TIM13RST
                TIM13RST: u1,
                ///  TIM14RST
                TIM14RST: u1,
                ///  LPTIM1RST
                LPTIM1RST: u1,
                reserved11: u1,
                ///  SPI2RST
                SPI2RST: u1,
                ///  SPI3RST
                SPI3RST: u1,
                reserved14: u1,
                ///  USART2RST
                USART2RST: u1,
                ///  USART3RST
                USART3RST: u1,
                ///  UART4RST
                UART4RST: u1,
                ///  UART5RST
                UART5RST: u1,
                ///  UART7RST
                UART7RST: u1,
                ///  UART8RST
                UART8RST: u1,
                reserved21: u1,
                ///  I2C1RST
                I2C1RST: u1,
                ///  I2C2RST
                I2C2RST: u1,
                ///  I2C3RST
                I2C3RST: u1,
                ///  I2C5RST
                I2C5RST: u1,
                reserved26: u1,
                ///  SPDIFRST
                SPDIFRST: u1,
                ///  CECRST
                CECRST: u1,
                reserved29: u1,
                ///  DAC12RST
                DAC12RST: u1,
                reserved31: u1,
                ///  MDIOSRST
                MDIOSRST: u1,
            }),
            ///  This register is used to release the reset of the corresponding peripheral.
            RCC_APB1RSTCLRR: mmio.Mmio(packed struct(u32) {
                ///  TIM2RST
                TIM2RST: u1,
                ///  TIM3RST
                TIM3RST: u1,
                ///  TIM4RST
                TIM4RST: u1,
                ///  TIM5RST
                TIM5RST: u1,
                ///  TIM6RST
                TIM6RST: u1,
                ///  TIM7RST
                TIM7RST: u1,
                ///  TIM12RST
                TIM12RST: u1,
                ///  TIM13RST
                TIM13RST: u1,
                ///  TIM14RST
                TIM14RST: u1,
                ///  LPTIM1RST
                LPTIM1RST: u1,
                reserved11: u1,
                ///  SPI2RST
                SPI2RST: u1,
                ///  SPI3RST
                SPI3RST: u1,
                reserved14: u1,
                ///  USART2RST
                USART2RST: u1,
                ///  USART3RST
                USART3RST: u1,
                ///  UART4RST
                UART4RST: u1,
                ///  UART5RST
                UART5RST: u1,
                ///  UART7RST
                UART7RST: u1,
                ///  UART8RST
                UART8RST: u1,
                reserved21: u1,
                ///  I2C1RST
                I2C1RST: u1,
                ///  I2C2RST
                I2C2RST: u1,
                ///  I2C3RST
                I2C3RST: u1,
                ///  I2C5RST
                I2C5RST: u1,
                reserved26: u1,
                ///  SPDIFRST
                SPDIFRST: u1,
                ///  CECRST
                CECRST: u1,
                reserved29: u1,
                ///  DAC12RST
                DAC12RST: u1,
                reserved31: u1,
                ///  MDIOSRST
                MDIOSRST: u1,
            }),
            ///  This register is used to activate the reset of the corresponding peripheral.
            RCC_APB2RSTSETR: mmio.Mmio(packed struct(u32) {
                ///  TIM1RST
                TIM1RST: u1,
                ///  TIM8RST
                TIM8RST: u1,
                ///  TIM15RST
                TIM15RST: u1,
                ///  TIM16RST
                TIM16RST: u1,
                ///  TIM17RST
                TIM17RST: u1,
                reserved8: u3,
                ///  SPI1RST
                SPI1RST: u1,
                ///  SPI4RST
                SPI4RST: u1,
                ///  SPI5RST
                SPI5RST: u1,
                reserved13: u2,
                ///  USART6RST
                USART6RST: u1,
                reserved16: u2,
                ///  SAI1RST
                SAI1RST: u1,
                ///  SAI2RST
                SAI2RST: u1,
                ///  SAI3RST
                SAI3RST: u1,
                reserved20: u1,
                ///  DFSDMRST
                DFSDMRST: u1,
                reserved24: u3,
                ///  FDCANRST
                FDCANRST: u1,
                padding: u7,
            }),
            ///  This register is used to release the reset of the corresponding peripheral.
            RCC_APB2RSTCLRR: mmio.Mmio(packed struct(u32) {
                ///  TIM1RST
                TIM1RST: u1,
                ///  TIM8RST
                TIM8RST: u1,
                ///  TIM15RST
                TIM15RST: u1,
                ///  TIM16RST
                TIM16RST: u1,
                ///  TIM17RST
                TIM17RST: u1,
                reserved8: u3,
                ///  SPI1RST
                SPI1RST: u1,
                ///  SPI4RST
                SPI4RST: u1,
                ///  SPI5RST
                SPI5RST: u1,
                reserved13: u2,
                ///  USART6RST
                USART6RST: u1,
                reserved16: u2,
                ///  SAI1RST
                SAI1RST: u1,
                ///  SAI2RST
                SAI2RST: u1,
                ///  SAI3RST
                SAI3RST: u1,
                reserved20: u1,
                ///  DFSDMRST
                DFSDMRST: u1,
                reserved24: u3,
                ///  FDCANRST
                FDCANRST: u1,
                padding: u7,
            }),
            ///  This register is used to activate the reset of the corresponding peripheral.
            RCC_APB3RSTSETR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM2RST
                LPTIM2RST: u1,
                ///  LPTIM3RST
                LPTIM3RST: u1,
                ///  LPTIM4RST
                LPTIM4RST: u1,
                ///  LPTIM5RST
                LPTIM5RST: u1,
                reserved8: u4,
                ///  SAI4RST
                SAI4RST: u1,
                reserved11: u2,
                ///  SYSCFGRST
                SYSCFGRST: u1,
                reserved13: u1,
                ///  VREFRST
                VREFRST: u1,
                reserved16: u2,
                ///  DTSRST
                DTSRST: u1,
                padding: u15,
            }),
            ///  This register is used to release the reset of the corresponding peripheral.
            RCC_APB3RSTCLRR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM2RST
                LPTIM2RST: u1,
                ///  LPTIM3RST
                LPTIM3RST: u1,
                ///  LPTIM4RST
                LPTIM4RST: u1,
                ///  LPTIM5RST
                LPTIM5RST: u1,
                reserved8: u4,
                ///  SAI4RST
                SAI4RST: u1,
                reserved11: u2,
                ///  SYSCFGRST
                SYSCFGRST: u1,
                reserved13: u1,
                ///  VREFRST
                VREFRST: u1,
                reserved16: u2,
                ///  DTSRST
                DTSRST: u1,
                padding: u15,
            }),
            ///  This register is used to activate the reset of the corresponding peripheral.
            RCC_AHB2RSTSETR: mmio.Mmio(packed struct(u32) {
                ///  DMA1RST
                DMA1RST: u1,
                ///  DMA2RST
                DMA2RST: u1,
                ///  DMAMUXRST
                DMAMUXRST: u1,
                reserved5: u2,
                ///  ADC12RST
                ADC12RST: u1,
                reserved8: u2,
                ///  USBORST
                USBORST: u1,
                reserved16: u7,
                ///  SDMMC3RST
                SDMMC3RST: u1,
                padding: u15,
            }),
            ///  This register is used to release the reset of the corresponding peripheral.
            RCC_AHB2RSTCLRR: mmio.Mmio(packed struct(u32) {
                ///  DMA1RST
                DMA1RST: u1,
                ///  DMA2RST
                DMA2RST: u1,
                ///  DMAMUXRST
                DMAMUXRST: u1,
                reserved5: u2,
                ///  ADC12RST
                ADC12RST: u1,
                reserved8: u2,
                ///  USBORST
                USBORST: u1,
                reserved16: u7,
                ///  SDMMC3RST
                SDMMC3RST: u1,
                padding: u15,
            }),
            ///  This register is used to activate the reset of the corresponding peripheral.
            RCC_AHB3RSTSETR: mmio.Mmio(packed struct(u32) {
                ///  DCMIRST
                DCMIRST: u1,
                reserved4: u3,
                ///  CRYP2RST
                CRYP2RST: u1,
                ///  HASH2RST
                HASH2RST: u1,
                ///  RNG2RST
                RNG2RST: u1,
                ///  CRC2RST
                CRC2RST: u1,
                reserved11: u3,
                ///  HSEMRST
                HSEMRST: u1,
                ///  IPCCRST
                IPCCRST: u1,
                padding: u19,
            }),
            ///  This register is used to release the reset of the corresponding peripheral.
            RCC_AHB3RSTCLRR: mmio.Mmio(packed struct(u32) {
                ///  DCMIRST
                DCMIRST: u1,
                reserved4: u3,
                ///  CRYP2RST
                CRYP2RST: u1,
                ///  HASH2RST
                HASH2RST: u1,
                ///  RNG2RST
                RNG2RST: u1,
                ///  CRC2RST
                CRC2RST: u1,
                reserved11: u3,
                ///  HSEMRST
                HSEMRST: u1,
                ///  IPCCRST
                IPCCRST: u1,
                padding: u19,
            }),
            ///  This register is used to activate the reset of the corresponding peripheral
            RCC_AHB4RSTSETR: mmio.Mmio(packed struct(u32) {
                ///  GPIOARST
                GPIOARST: u1,
                ///  GPIOBRST
                GPIOBRST: u1,
                ///  GPIOCRST
                GPIOCRST: u1,
                ///  GPIODRST
                GPIODRST: u1,
                ///  GPIOERST
                GPIOERST: u1,
                ///  GPIOFRST
                GPIOFRST: u1,
                ///  GPIOGRST
                GPIOGRST: u1,
                ///  GPIOHRST
                GPIOHRST: u1,
                ///  GPIOIRST
                GPIOIRST: u1,
                ///  GPIOJRST
                GPIOJRST: u1,
                ///  GPIOKRST
                GPIOKRST: u1,
                padding: u21,
            }),
            ///  This register is used to release the reset of the corresponding peripheral.
            RCC_AHB4RSTCLRR: mmio.Mmio(packed struct(u32) {
                ///  GPIOARST
                GPIOARST: u1,
                ///  GPIOBRST
                GPIOBRST: u1,
                ///  GPIOCRST
                GPIOCRST: u1,
                ///  GPIODRST
                GPIODRST: u1,
                ///  GPIOERST
                GPIOERST: u1,
                ///  GPIOFRST
                GPIOFRST: u1,
                ///  GPIOGRST
                GPIOGRST: u1,
                ///  GPIOHRST
                GPIOHRST: u1,
                ///  GPIOIRST
                GPIOIRST: u1,
                ///  GPIOJRST
                GPIOJRST: u1,
                ///  GPIOKRST
                GPIOKRST: u1,
                padding: u21,
            }),
            reserved2560: [80]u8,
            ///  This register is used to set the peripheral clock enable bit
            RCC_MP_APB1ENSETR: mmio.Mmio(packed struct(u32) {
                ///  TIM2EN
                TIM2EN: u1,
                ///  TIM3EN
                TIM3EN: u1,
                ///  TIM4EN
                TIM4EN: u1,
                ///  TIM5EN
                TIM5EN: u1,
                ///  TIM6EN
                TIM6EN: u1,
                ///  TIM7EN
                TIM7EN: u1,
                ///  TIM12EN
                TIM12EN: u1,
                ///  TIM13EN
                TIM13EN: u1,
                ///  TIM14EN
                TIM14EN: u1,
                ///  LPTIM1EN
                LPTIM1EN: u1,
                reserved11: u1,
                ///  SPI2EN
                SPI2EN: u1,
                ///  SPI3EN
                SPI3EN: u1,
                reserved14: u1,
                ///  USART2EN
                USART2EN: u1,
                ///  USART3EN
                USART3EN: u1,
                ///  UART4EN
                UART4EN: u1,
                ///  UART5EN
                UART5EN: u1,
                ///  UART7EN
                UART7EN: u1,
                ///  UART8EN
                UART8EN: u1,
                reserved21: u1,
                ///  I2C1EN
                I2C1EN: u1,
                ///  I2C2EN
                I2C2EN: u1,
                ///  I2C3EN
                I2C3EN: u1,
                ///  I2C5EN
                I2C5EN: u1,
                reserved26: u1,
                ///  SPDIFEN
                SPDIFEN: u1,
                ///  CECEN
                CECEN: u1,
                reserved29: u1,
                ///  DAC12EN
                DAC12EN: u1,
                reserved31: u1,
                ///  MDIOSEN
                MDIOSEN: u1,
            }),
            ///  This register is used to clear the peripheral clock enable bit
            RCC_MP_APB1ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  TIM2EN
                TIM2EN: u1,
                ///  TIM3EN
                TIM3EN: u1,
                ///  TIM4EN
                TIM4EN: u1,
                ///  TIM5EN
                TIM5EN: u1,
                ///  TIM6EN
                TIM6EN: u1,
                ///  TIM7EN
                TIM7EN: u1,
                ///  TIM12EN
                TIM12EN: u1,
                ///  TIM13EN
                TIM13EN: u1,
                ///  TIM14EN
                TIM14EN: u1,
                ///  LPTIM1EN
                LPTIM1EN: u1,
                reserved11: u1,
                ///  SPI2EN
                SPI2EN: u1,
                ///  SPI3EN
                SPI3EN: u1,
                reserved14: u1,
                ///  USART2EN
                USART2EN: u1,
                ///  USART3EN
                USART3EN: u1,
                ///  UART4EN
                UART4EN: u1,
                ///  UART5EN
                UART5EN: u1,
                ///  UART7EN
                UART7EN: u1,
                ///  UART8EN
                UART8EN: u1,
                reserved21: u1,
                ///  I2C1EN
                I2C1EN: u1,
                ///  I2C2EN
                I2C2EN: u1,
                ///  I2C3EN
                I2C3EN: u1,
                ///  I2C5EN
                I2C5EN: u1,
                reserved26: u1,
                ///  SPDIFEN
                SPDIFEN: u1,
                ///  CECEN
                CECEN: u1,
                reserved29: u1,
                ///  DAC12EN
                DAC12EN: u1,
                reserved31: u1,
                ///  MDIOSEN
                MDIOSEN: u1,
            }),
            ///  This register is used to set the peripheral clock enable bit
            RCC_MP_APB2ENSETR: mmio.Mmio(packed struct(u32) {
                ///  TIM1EN
                TIM1EN: u1,
                ///  TIM8EN
                TIM8EN: u1,
                ///  TIM15EN
                TIM15EN: u1,
                ///  TIM16EN
                TIM16EN: u1,
                ///  TIM17EN
                TIM17EN: u1,
                reserved8: u3,
                ///  SPI1EN
                SPI1EN: u1,
                ///  SPI4EN
                SPI4EN: u1,
                ///  SPI5EN
                SPI5EN: u1,
                reserved13: u2,
                ///  USART6EN
                USART6EN: u1,
                reserved16: u2,
                ///  SAI1EN
                SAI1EN: u1,
                ///  SAI2EN
                SAI2EN: u1,
                ///  SAI3EN
                SAI3EN: u1,
                reserved20: u1,
                ///  DFSDMEN
                DFSDMEN: u1,
                ///  ADFSDMEN
                ADFSDMEN: u1,
                reserved24: u2,
                ///  FDCANEN
                FDCANEN: u1,
                padding: u7,
            }),
            ///  This register is used to clear the peripheral clock enable bit of the corresponding peripheral.
            RCC_MP_APB2ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  TIM1EN
                TIM1EN: u1,
                ///  TIM8EN
                TIM8EN: u1,
                ///  TIM15EN
                TIM15EN: u1,
                ///  TIM16EN
                TIM16EN: u1,
                ///  TIM17EN
                TIM17EN: u1,
                reserved8: u3,
                ///  SPI1EN
                SPI1EN: u1,
                ///  SPI4EN
                SPI4EN: u1,
                ///  SPI5EN
                SPI5EN: u1,
                reserved13: u2,
                ///  USART6EN
                USART6EN: u1,
                reserved16: u2,
                ///  SAI1EN
                SAI1EN: u1,
                ///  SAI2EN
                SAI2EN: u1,
                ///  SAI3EN
                SAI3EN: u1,
                reserved20: u1,
                ///  DFSDMEN
                DFSDMEN: u1,
                ///  ADFSDMEN
                ADFSDMEN: u1,
                reserved24: u2,
                ///  FDCANEN
                FDCANEN: u1,
                padding: u7,
            }),
            ///  This register is used to set the peripheral clock enable bit
            RCC_MP_APB3ENSETR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM2EN
                LPTIM2EN: u1,
                ///  LPTIM3EN
                LPTIM3EN: u1,
                ///  LPTIM4EN
                LPTIM4EN: u1,
                ///  LPTIM5EN
                LPTIM5EN: u1,
                reserved8: u4,
                ///  SAI4EN
                SAI4EN: u1,
                reserved11: u2,
                ///  SYSCFGEN
                SYSCFGEN: u1,
                reserved13: u1,
                ///  VREFEN
                VREFEN: u1,
                reserved16: u2,
                ///  DTSEN
                DTSEN: u1,
                reserved20: u3,
                ///  HDPEN
                HDPEN: u1,
                padding: u11,
            }),
            ///  This register is used to clear the peripheral clock enable bit of the corresponding peripheral.
            RCC_MP_APB3ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM2EN
                LPTIM2EN: u1,
                ///  LPTIM3EN
                LPTIM3EN: u1,
                ///  LPTIM4EN
                LPTIM4EN: u1,
                ///  LPTIM5EN
                LPTIM5EN: u1,
                reserved8: u4,
                ///  SAI4EN
                SAI4EN: u1,
                reserved11: u2,
                ///  SYSCFGEN
                SYSCFGEN: u1,
                reserved13: u1,
                ///  VREFEN
                VREFEN: u1,
                reserved16: u2,
                ///  DTSEN
                DTSEN: u1,
                reserved20: u3,
                ///  HDPEN
                HDPEN: u1,
                padding: u11,
            }),
            ///  This register is used to set the peripheral clock enable bit of the corresponding peripheral
            RCC_MP_AHB2ENSETR: mmio.Mmio(packed struct(u32) {
                ///  DMA1EN
                DMA1EN: u1,
                ///  DMA2EN
                DMA2EN: u1,
                ///  DMAMUXEN
                DMAMUXEN: u1,
                reserved5: u2,
                ///  ADC12EN
                ADC12EN: u1,
                reserved8: u2,
                ///  USBOEN
                USBOEN: u1,
                reserved16: u7,
                ///  SDMMC3EN
                SDMMC3EN: u1,
                padding: u15,
            }),
            ///  This register is used to clear the peripheral clock enable bit of the corresponding peripheral.
            RCC_MP_AHB2ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  DMA1EN
                DMA1EN: u1,
                ///  DMA2EN
                DMA2EN: u1,
                ///  DMAMUXEN
                DMAMUXEN: u1,
                reserved5: u2,
                ///  ADC12EN
                ADC12EN: u1,
                reserved8: u2,
                ///  USBOEN
                USBOEN: u1,
                reserved16: u7,
                ///  SDMMC3EN
                SDMMC3EN: u1,
                padding: u15,
            }),
            ///  This register is used to set the peripheral clock enable bit of the corresponding peripheral
            RCC_MP_AHB3ENSETR: mmio.Mmio(packed struct(u32) {
                ///  DCMIEN
                DCMIEN: u1,
                reserved4: u3,
                ///  CRYP2EN
                CRYP2EN: u1,
                ///  HASH2EN
                HASH2EN: u1,
                ///  RNG2EN
                RNG2EN: u1,
                ///  CRC2EN
                CRC2EN: u1,
                reserved11: u3,
                ///  HSEMEN
                HSEMEN: u1,
                ///  IPCCEN
                IPCCEN: u1,
                padding: u19,
            }),
            ///  This register is used to clear the peripheral clock enable bit of the corresponding peripheral.
            RCC_MP_AHB3ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  DCMIEN
                DCMIEN: u1,
                reserved4: u3,
                ///  CRYP2EN
                CRYP2EN: u1,
                ///  HASH2EN
                HASH2EN: u1,
                ///  RNG2EN
                RNG2EN: u1,
                ///  CRC2EN
                CRC2EN: u1,
                reserved11: u3,
                ///  HSEMEN
                HSEMEN: u1,
                ///  IPCCEN
                IPCCEN: u1,
                padding: u19,
            }),
            ///  This register is used to set the peripheral clock enable bit of the corresponding peripheral to . It shall be used to allocate a peripheral to the MPU.
            RCC_MP_AHB4ENSETR: mmio.Mmio(packed struct(u32) {
                ///  GPIOAEN
                GPIOAEN: u1,
                ///  GPIOBEN
                GPIOBEN: u1,
                ///  GPIOCEN
                GPIOCEN: u1,
                ///  GPIODEN
                GPIODEN: u1,
                ///  GPIOEEN
                GPIOEEN: u1,
                ///  GPIOFEN
                GPIOFEN: u1,
                ///  GPIOGEN
                GPIOGEN: u1,
                ///  GPIOHEN
                GPIOHEN: u1,
                ///  GPIOIEN
                GPIOIEN: u1,
                ///  GPIOJEN
                GPIOJEN: u1,
                ///  GPIOKEN
                GPIOKEN: u1,
                padding: u21,
            }),
            ///  This register is used to clear the peripheral clock enable bit
            RCC_MP_AHB4ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  GPIOAEN
                GPIOAEN: u1,
                ///  GPIOBEN
                GPIOBEN: u1,
                ///  GPIOCEN
                GPIOCEN: u1,
                ///  GPIODEN
                GPIODEN: u1,
                ///  GPIOEEN
                GPIOEEN: u1,
                ///  GPIOFEN
                GPIOFEN: u1,
                ///  GPIOGEN
                GPIOGEN: u1,
                ///  GPIOHEN
                GPIOHEN: u1,
                ///  GPIOIEN
                GPIOIEN: u1,
                ///  GPIOJEN
                GPIOJEN: u1,
                ///  GPIOKEN
                GPIOKEN: u1,
                padding: u21,
            }),
            reserved2616: [8]u8,
            ///  This register is used to set the peripheral clock enable bit
            RCC_MP_MLAHBENSETR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  RETRAMEN
                RETRAMEN: u1,
                padding: u27,
            }),
            ///  This register is used to clear the peripheral clock enable bit.
            RCC_MP_MLAHBENCLRR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  RETRAMEN
                RETRAMEN: u1,
                padding: u27,
            }),
            reserved2688: [64]u8,
            ///  This register is used to set the peripheral clock enable bit of the corresponding peripheral to . It shall be used to allocate a peripheral to the MCU. Writing has no effect, reading will return . Writing a sets the corresponding bit to .
            RCC_MC_APB1ENSETR: mmio.Mmio(packed struct(u32) {
                ///  TIM2EN
                TIM2EN: u1,
                ///  TIM3EN
                TIM3EN: u1,
                ///  TIM4EN
                TIM4EN: u1,
                ///  TIM5EN
                TIM5EN: u1,
                ///  TIM6EN
                TIM6EN: u1,
                ///  TIM7EN
                TIM7EN: u1,
                ///  TIM12EN
                TIM12EN: u1,
                ///  TIM13EN
                TIM13EN: u1,
                ///  TIM14EN
                TIM14EN: u1,
                ///  LPTIM1EN
                LPTIM1EN: u1,
                reserved11: u1,
                ///  SPI2EN
                SPI2EN: u1,
                ///  SPI3EN
                SPI3EN: u1,
                reserved14: u1,
                ///  USART2EN
                USART2EN: u1,
                ///  USART3EN
                USART3EN: u1,
                ///  UART4EN
                UART4EN: u1,
                ///  UART5EN
                UART5EN: u1,
                ///  UART7EN
                UART7EN: u1,
                ///  UART8EN
                UART8EN: u1,
                reserved21: u1,
                ///  I2C1EN
                I2C1EN: u1,
                ///  I2C2EN
                I2C2EN: u1,
                ///  I2C3EN
                I2C3EN: u1,
                ///  I2C5EN
                I2C5EN: u1,
                reserved26: u1,
                ///  SPDIFEN
                SPDIFEN: u1,
                ///  CECEN
                CECEN: u1,
                ///  WWDG1EN
                WWDG1EN: u1,
                ///  DAC12EN
                DAC12EN: u1,
                reserved31: u1,
                ///  MDIOSEN
                MDIOSEN: u1,
            }),
            ///  This register is used to clear the peripheral clock enable bit of the corresponding peripheral.
            RCC_MC_APB1ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  TIM2EN
                TIM2EN: u1,
                ///  TIM3EN
                TIM3EN: u1,
                ///  TIM4EN
                TIM4EN: u1,
                ///  TIM5EN
                TIM5EN: u1,
                ///  TIM6EN
                TIM6EN: u1,
                ///  TIM7EN
                TIM7EN: u1,
                ///  TIM12EN
                TIM12EN: u1,
                ///  TIM13EN
                TIM13EN: u1,
                ///  TIM14EN
                TIM14EN: u1,
                ///  LPTIM1EN
                LPTIM1EN: u1,
                reserved11: u1,
                ///  SPI2EN
                SPI2EN: u1,
                ///  SPI3EN
                SPI3EN: u1,
                reserved14: u1,
                ///  USART2EN
                USART2EN: u1,
                ///  USART3EN
                USART3EN: u1,
                ///  UART4EN
                UART4EN: u1,
                ///  UART5EN
                UART5EN: u1,
                ///  UART7EN
                UART7EN: u1,
                ///  UART8EN
                UART8EN: u1,
                reserved21: u1,
                ///  I2C1EN
                I2C1EN: u1,
                ///  I2C2EN
                I2C2EN: u1,
                ///  I2C3EN
                I2C3EN: u1,
                ///  I2C5EN
                I2C5EN: u1,
                reserved26: u1,
                ///  SPDIFEN
                SPDIFEN: u1,
                ///  CECEN
                CECEN: u1,
                reserved29: u1,
                ///  DAC12EN
                DAC12EN: u1,
                reserved31: u1,
                ///  MDIOSEN
                MDIOSEN: u1,
            }),
            ///  This register is used to set the peripheral clock enable bit
            RCC_MC_APB2ENSETR: mmio.Mmio(packed struct(u32) {
                ///  TIM1EN
                TIM1EN: u1,
                ///  TIM8EN
                TIM8EN: u1,
                ///  TIM15EN
                TIM15EN: u1,
                ///  TIM16EN
                TIM16EN: u1,
                ///  TIM17EN
                TIM17EN: u1,
                reserved8: u3,
                ///  SPI1EN
                SPI1EN: u1,
                ///  SPI4EN
                SPI4EN: u1,
                ///  SPI5EN
                SPI5EN: u1,
                reserved13: u2,
                ///  USART6EN
                USART6EN: u1,
                reserved16: u2,
                ///  SAI1EN
                SAI1EN: u1,
                ///  SAI2EN
                SAI2EN: u1,
                ///  SAI3EN
                SAI3EN: u1,
                reserved20: u1,
                ///  DFSDMEN
                DFSDMEN: u1,
                ///  ADFSDMEN
                ADFSDMEN: u1,
                reserved24: u2,
                ///  FDCANEN
                FDCANEN: u1,
                padding: u7,
            }),
            ///  This register is used to clear the peripheral clock enable bit
            RCC_MC_APB2ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  TIM1EN
                TIM1EN: u1,
                ///  TIM8EN
                TIM8EN: u1,
                ///  TIM15EN
                TIM15EN: u1,
                ///  TIM16EN
                TIM16EN: u1,
                ///  TIM17EN
                TIM17EN: u1,
                reserved8: u3,
                ///  SPI1EN
                SPI1EN: u1,
                ///  SPI4EN
                SPI4EN: u1,
                ///  SPI5EN
                SPI5EN: u1,
                reserved13: u2,
                ///  USART6EN
                USART6EN: u1,
                reserved16: u2,
                ///  SAI1EN
                SAI1EN: u1,
                ///  SAI2EN
                SAI2EN: u1,
                ///  SAI3EN
                SAI3EN: u1,
                reserved20: u1,
                ///  DFSDMEN
                DFSDMEN: u1,
                ///  ADFSDMEN
                ADFSDMEN: u1,
                reserved24: u2,
                ///  FDCANEN
                FDCANEN: u1,
                padding: u7,
            }),
            ///  This register is used to set the peripheral clock enable bit
            RCC_MC_APB3ENSETR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM2EN
                LPTIM2EN: u1,
                ///  LPTIM3EN
                LPTIM3EN: u1,
                ///  LPTIM4EN
                LPTIM4EN: u1,
                ///  LPTIM5EN
                LPTIM5EN: u1,
                reserved8: u4,
                ///  SAI4EN
                SAI4EN: u1,
                reserved11: u2,
                ///  SYSCFGEN
                SYSCFGEN: u1,
                reserved13: u1,
                ///  VREFEN
                VREFEN: u1,
                reserved16: u2,
                ///  DTSEN
                DTSEN: u1,
                reserved20: u3,
                ///  HDPEN
                HDPEN: u1,
                padding: u11,
            }),
            ///  This register is used to clear the peripheral clock enable bit
            RCC_MC_APB3ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM2EN
                LPTIM2EN: u1,
                ///  LPTIM3EN
                LPTIM3EN: u1,
                ///  LPTIM4EN
                LPTIM4EN: u1,
                ///  LPTIM5EN
                LPTIM5EN: u1,
                reserved8: u4,
                ///  SAI4EN
                SAI4EN: u1,
                reserved11: u2,
                ///  SYSCFGEN
                SYSCFGEN: u1,
                reserved13: u1,
                ///  VREFEN
                VREFEN: u1,
                reserved16: u2,
                ///  DTSEN
                DTSEN: u1,
                reserved20: u3,
                ///  HDPEN
                HDPEN: u1,
                padding: u11,
            }),
            ///  This register is used to set the peripheral clock enable bit
            RCC_MC_AHB2ENSETR: mmio.Mmio(packed struct(u32) {
                ///  DMA1EN
                DMA1EN: u1,
                ///  DMA2EN
                DMA2EN: u1,
                ///  DMAMUXEN
                DMAMUXEN: u1,
                reserved5: u2,
                ///  ADC12EN
                ADC12EN: u1,
                reserved8: u2,
                ///  USBOEN
                USBOEN: u1,
                reserved16: u7,
                ///  SDMMC3EN
                SDMMC3EN: u1,
                padding: u15,
            }),
            ///  This register is used to clear the peripheral clock enable bit
            RCC_MC_AHB2ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  DMA1EN
                DMA1EN: u1,
                ///  DMA2EN
                DMA2EN: u1,
                ///  DMAMUXEN
                DMAMUXEN: u1,
                reserved5: u2,
                ///  ADC12EN
                ADC12EN: u1,
                reserved8: u2,
                ///  USBOEN
                USBOEN: u1,
                reserved16: u7,
                ///  SDMMC3EN
                SDMMC3EN: u1,
                padding: u15,
            }),
            ///  This register is used to set the peripheral clock enable bit
            RCC_MC_AHB3ENSETR: mmio.Mmio(packed struct(u32) {
                ///  DCMIEN
                DCMIEN: u1,
                reserved4: u3,
                ///  CRYP2EN
                CRYP2EN: u1,
                ///  HASH2EN
                HASH2EN: u1,
                ///  RNG2EN
                RNG2EN: u1,
                ///  CRC2EN
                CRC2EN: u1,
                reserved11: u3,
                ///  HSEMEN
                HSEMEN: u1,
                ///  IPCCEN
                IPCCEN: u1,
                padding: u19,
            }),
            ///  This register is used to clear the peripheral clock enable bit
            RCC_MC_AHB3ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  DCMIEN
                DCMIEN: u1,
                reserved4: u3,
                ///  CRYP2EN
                CRYP2EN: u1,
                ///  HASH2EN
                HASH2EN: u1,
                ///  RNG2EN
                RNG2EN: u1,
                ///  CRC2EN
                CRC2EN: u1,
                reserved11: u3,
                ///  HSEMEN
                HSEMEN: u1,
                ///  IPCCEN
                IPCCEN: u1,
                padding: u19,
            }),
            ///  This register is used to set the peripheral clock enable bit
            RCC_MC_AHB4ENSETR: mmio.Mmio(packed struct(u32) {
                ///  GPIOAEN
                GPIOAEN: u1,
                ///  GPIOBEN
                GPIOBEN: u1,
                ///  GPIOCEN
                GPIOCEN: u1,
                ///  GPIODEN
                GPIODEN: u1,
                ///  GPIOEEN
                GPIOEEN: u1,
                ///  GPIOFEN
                GPIOFEN: u1,
                ///  GPIOGEN
                GPIOGEN: u1,
                ///  GPIOHEN
                GPIOHEN: u1,
                ///  GPIOIEN
                GPIOIEN: u1,
                ///  GPIOJEN
                GPIOJEN: u1,
                ///  GPIOKEN
                GPIOKEN: u1,
                padding: u21,
            }),
            ///  This register is used to clear the peripheral clock enable bit
            RCC_MC_AHB4ENCLRR: mmio.Mmio(packed struct(u32) {
                ///  GPIOAEN
                GPIOAEN: u1,
                ///  GPIOBEN
                GPIOBEN: u1,
                ///  GPIOCEN
                GPIOCEN: u1,
                ///  GPIODEN
                GPIODEN: u1,
                ///  GPIOEEN
                GPIOEEN: u1,
                ///  GPIOFEN
                GPIOFEN: u1,
                ///  GPIOGEN
                GPIOGEN: u1,
                ///  GPIOHEN
                GPIOHEN: u1,
                ///  GPIOIEN
                GPIOIEN: u1,
                ///  GPIOJEN
                GPIOJEN: u1,
                ///  GPIOKEN
                GPIOKEN: u1,
                padding: u21,
            }),
            ///  This register is used to set the peripheral clock enable bit
            RCC_MC_AXIMENSETR: mmio.Mmio(packed struct(u32) {
                ///  SYSRAMEN
                SYSRAMEN: u1,
                padding: u31,
            }),
            ///  This register is used to clear the peripheral clock enable bit
            RCC_MC_AXIMENCLRR: mmio.Mmio(packed struct(u32) {
                ///  SYSRAMEN
                SYSRAMEN: u1,
                padding: u31,
            }),
            ///  This register is used to set the peripheral clock enable bit
            RCC_MC_MLAHBENSETR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  RETRAMEN
                RETRAMEN: u1,
                padding: u27,
            }),
            ///  This register is used to clear the peripheral clock enable bit
            RCC_MC_MLAHBENCLRR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  RETRAMEN
                RETRAMEN: u1,
                padding: u27,
            }),
            reserved2816: [64]u8,
            ///  This register is used by the MCU in order to clear the PERxLPEN bits
            RCC_MP_APB1LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  TIM2LPEN
                TIM2LPEN: u1,
                ///  TIM3LPEN
                TIM3LPEN: u1,
                ///  TIM4LPEN
                TIM4LPEN: u1,
                ///  TIM5LPEN
                TIM5LPEN: u1,
                ///  TIM6LPEN
                TIM6LPEN: u1,
                ///  TIM7LPEN
                TIM7LPEN: u1,
                ///  TIM12LPEN
                TIM12LPEN: u1,
                ///  TIM13LPEN
                TIM13LPEN: u1,
                ///  TIM14LPEN
                TIM14LPEN: u1,
                ///  LPTIM1LPEN
                LPTIM1LPEN: u1,
                reserved11: u1,
                ///  SPI2LPEN
                SPI2LPEN: u1,
                ///  SPI3LPEN
                SPI3LPEN: u1,
                reserved14: u1,
                ///  USART2LPEN
                USART2LPEN: u1,
                ///  USART3LPEN
                USART3LPEN: u1,
                ///  UART4LPEN
                UART4LPEN: u1,
                ///  UART5LPEN
                UART5LPEN: u1,
                ///  UART7LPEN
                UART7LPEN: u1,
                ///  UART8LPEN
                UART8LPEN: u1,
                reserved21: u1,
                ///  I2C1LPEN
                I2C1LPEN: u1,
                ///  I2C2LPEN
                I2C2LPEN: u1,
                ///  I2C3LPEN
                I2C3LPEN: u1,
                ///  I2C5LPEN
                I2C5LPEN: u1,
                reserved26: u1,
                ///  SPDIFLPEN
                SPDIFLPEN: u1,
                ///  CECLPEN
                CECLPEN: u1,
                reserved29: u1,
                ///  DAC12LPEN
                DAC12LPEN: u1,
                reserved31: u1,
                ///  MDIOSLPEN
                MDIOSLPEN: u1,
            }),
            ///  This register is used by the MPU in order to clear the PERxLPEN bits .
            RCC_MP_APB1LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  TIM2LPEN
                TIM2LPEN: u1,
                ///  TIM3LPEN
                TIM3LPEN: u1,
                ///  TIM4LPEN
                TIM4LPEN: u1,
                ///  TIM5LPEN
                TIM5LPEN: u1,
                ///  TIM6LPEN
                TIM6LPEN: u1,
                ///  TIM7LPEN
                TIM7LPEN: u1,
                ///  TIM12LPEN
                TIM12LPEN: u1,
                ///  TIM13LPEN
                TIM13LPEN: u1,
                ///  TIM14LPEN
                TIM14LPEN: u1,
                ///  LPTIM1LPEN
                LPTIM1LPEN: u1,
                reserved11: u1,
                ///  SPI2LPEN
                SPI2LPEN: u1,
                ///  SPI3LPEN
                SPI3LPEN: u1,
                reserved14: u1,
                ///  USART2LPEN
                USART2LPEN: u1,
                ///  USART3LPEN
                USART3LPEN: u1,
                ///  UART4LPEN
                UART4LPEN: u1,
                ///  UART5LPEN
                UART5LPEN: u1,
                ///  UART7LPEN
                UART7LPEN: u1,
                ///  UART8LPEN
                UART8LPEN: u1,
                reserved21: u1,
                ///  I2C1LPEN
                I2C1LPEN: u1,
                ///  I2C2LPEN
                I2C2LPEN: u1,
                ///  I2C3LPEN
                I2C3LPEN: u1,
                ///  I2C5LPEN
                I2C5LPEN: u1,
                reserved26: u1,
                ///  SPDIFLPEN
                SPDIFLPEN: u1,
                ///  CECLPEN
                CECLPEN: u1,
                reserved29: u1,
                ///  DAC12LPEN
                DAC12LPEN: u1,
                reserved31: u1,
                ///  MDIOSLPEN
                MDIOSLPEN: u1,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bits
            RCC_MP_APB2LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  TIM1LPEN
                TIM1LPEN: u1,
                ///  TIM8LPEN
                TIM8LPEN: u1,
                ///  TIM15LPEN
                TIM15LPEN: u1,
                ///  TIM16LPEN
                TIM16LPEN: u1,
                ///  TIM17LPEN
                TIM17LPEN: u1,
                reserved8: u3,
                ///  SPI1LPEN
                SPI1LPEN: u1,
                ///  SPI4LPEN
                SPI4LPEN: u1,
                ///  SPI5LPEN
                SPI5LPEN: u1,
                reserved13: u2,
                ///  USART6LPEN
                USART6LPEN: u1,
                reserved16: u2,
                ///  SAI1LPEN
                SAI1LPEN: u1,
                ///  SAI2LPEN
                SAI2LPEN: u1,
                ///  SAI3LPEN
                SAI3LPEN: u1,
                reserved20: u1,
                ///  DFSDMLPEN
                DFSDMLPEN: u1,
                ///  ADFSDMLPEN
                ADFSDMLPEN: u1,
                reserved24: u2,
                ///  FDCANLPEN
                FDCANLPEN: u1,
                padding: u7,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bits
            RCC_MP_APB2LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  TIM1LPEN
                TIM1LPEN: u1,
                ///  TIM8LPEN
                TIM8LPEN: u1,
                ///  TIM15LPEN
                TIM15LPEN: u1,
                ///  TIM16LPEN
                TIM16LPEN: u1,
                ///  TIM17LPEN
                TIM17LPEN: u1,
                reserved8: u3,
                ///  SPI1LPEN
                SPI1LPEN: u1,
                ///  SPI4LPEN
                SPI4LPEN: u1,
                ///  SPI5LPEN
                SPI5LPEN: u1,
                reserved13: u2,
                ///  USART6LPEN
                USART6LPEN: u1,
                reserved16: u2,
                ///  SAI1LPEN
                SAI1LPEN: u1,
                ///  SAI2LPEN
                SAI2LPEN: u1,
                ///  SAI3LPEN
                SAI3LPEN: u1,
                reserved20: u1,
                ///  DFSDMLPEN
                DFSDMLPEN: u1,
                ///  ADFSDMLPEN
                ADFSDMLPEN: u1,
                reserved24: u2,
                ///  FDCANLPEN
                FDCANLPEN: u1,
                padding: u7,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bits
            RCC_MP_APB3LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM2LPEN
                LPTIM2LPEN: u1,
                ///  LPTIM3LPEN
                LPTIM3LPEN: u1,
                ///  LPTIM4LPEN
                LPTIM4LPEN: u1,
                ///  LPTIM5LPEN
                LPTIM5LPEN: u1,
                reserved8: u4,
                ///  SAI4LPEN
                SAI4LPEN: u1,
                reserved11: u2,
                ///  SYSCFGLPEN
                SYSCFGLPEN: u1,
                reserved13: u1,
                ///  VREFLPEN
                VREFLPEN: u1,
                reserved16: u2,
                ///  DTSLPEN
                DTSLPEN: u1,
                padding: u15,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bits
            RCC_MP_APB3LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM2LPEN
                LPTIM2LPEN: u1,
                ///  LPTIM3LPEN
                LPTIM3LPEN: u1,
                ///  LPTIM4LPEN
                LPTIM4LPEN: u1,
                ///  LPTIM5LPEN
                LPTIM5LPEN: u1,
                reserved8: u4,
                ///  SAI4LPEN
                SAI4LPEN: u1,
                reserved11: u2,
                ///  SYSCFGLPEN
                SYSCFGLPEN: u1,
                reserved13: u1,
                ///  VREFLPEN
                VREFLPEN: u1,
                reserved16: u2,
                ///  DTSLPEN
                DTSLPEN: u1,
                padding: u15,
            }),
            ///  This register is used by the MPU in order to set the PERxLPEN bit.
            RCC_MP_AHB2LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  DMA1LPEN
                DMA1LPEN: u1,
                ///  DMA2LPEN
                DMA2LPEN: u1,
                ///  DMAMUXLPEN
                DMAMUXLPEN: u1,
                reserved5: u2,
                ///  ADC12LPEN
                ADC12LPEN: u1,
                reserved8: u2,
                ///  USBOLPEN
                USBOLPEN: u1,
                reserved16: u7,
                ///  SDMMC3LPEN
                SDMMC3LPEN: u1,
                padding: u15,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bits
            RCC_MP_AHB2LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  DMA1LPEN
                DMA1LPEN: u1,
                ///  DMA2LPEN
                DMA2LPEN: u1,
                ///  DMAMUXLPEN
                DMAMUXLPEN: u1,
                reserved5: u2,
                ///  ADC12LPEN
                ADC12LPEN: u1,
                reserved8: u2,
                ///  USBOLPEN
                USBOLPEN: u1,
                reserved16: u7,
                ///  SDMMC3LPEN
                SDMMC3LPEN: u1,
                padding: u15,
            }),
            ///  This register is used by the MPU
            RCC_MP_AHB3LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  DCMILPEN
                DCMILPEN: u1,
                reserved4: u3,
                ///  CRYP2LPEN
                CRYP2LPEN: u1,
                ///  HASH2LPEN
                HASH2LPEN: u1,
                ///  RNG2LPEN
                RNG2LPEN: u1,
                ///  CRC2LPEN
                CRC2LPEN: u1,
                reserved11: u3,
                ///  HSEMLPEN
                HSEMLPEN: u1,
                ///  IPCCLPEN
                IPCCLPEN: u1,
                padding: u19,
            }),
            ///  This register is used by the MPU in order to clear the PERxLPEN bit
            RCC_MP_AHB3LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  DCMILPEN
                DCMILPEN: u1,
                reserved4: u3,
                ///  CRYP2LPEN
                CRYP2LPEN: u1,
                ///  HASH2LPEN
                HASH2LPEN: u1,
                ///  RNG2LPEN
                RNG2LPEN: u1,
                ///  CRC2LPEN
                CRC2LPEN: u1,
                reserved11: u3,
                ///  HSEMLPEN
                HSEMLPEN: u1,
                ///  IPCCLPEN
                IPCCLPEN: u1,
                padding: u19,
            }),
            ///  This register is used by the MPU
            RCC_MP_AHB4LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  GPIOALPEN
                GPIOALPEN: u1,
                ///  GPIOBLPEN
                GPIOBLPEN: u1,
                ///  GPIOCLPEN
                GPIOCLPEN: u1,
                ///  GPIODLPEN
                GPIODLPEN: u1,
                ///  GPIOELPEN
                GPIOELPEN: u1,
                ///  GPIOFLPEN
                GPIOFLPEN: u1,
                ///  GPIOGLPEN
                GPIOGLPEN: u1,
                ///  GPIOHLPEN
                GPIOHLPEN: u1,
                ///  GPIOILPEN
                GPIOILPEN: u1,
                ///  GPIOJLPEN
                GPIOJLPEN: u1,
                ///  GPIOKLPEN
                GPIOKLPEN: u1,
                padding: u21,
            }),
            ///  This register is used by the MPU
            RCC_MP_AHB4LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  GPIOALPEN
                GPIOALPEN: u1,
                ///  GPIOBLPEN
                GPIOBLPEN: u1,
                ///  GPIOCLPEN
                GPIOCLPEN: u1,
                ///  GPIODLPEN
                GPIODLPEN: u1,
                ///  GPIOELPEN
                GPIOELPEN: u1,
                ///  GPIOFLPEN
                GPIOFLPEN: u1,
                ///  GPIOGLPEN
                GPIOGLPEN: u1,
                ///  GPIOHLPEN
                GPIOHLPEN: u1,
                ///  GPIOILPEN
                GPIOILPEN: u1,
                ///  GPIOJLPEN
                GPIOJLPEN: u1,
                ///  GPIOKLPEN
                GPIOKLPEN: u1,
                padding: u21,
            }),
            ///  This register is used by the MPU
            RCC_MP_AXIMLPENSETR: mmio.Mmio(packed struct(u32) {
                ///  SYSRAMLPEN
                SYSRAMLPEN: u1,
                padding: u31,
            }),
            ///  This register is used by the MPU
            RCC_MP_AXIMLPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  SYSRAMLPEN
                SYSRAMLPEN: u1,
                padding: u31,
            }),
            ///  This register is used by the MPU in order to set the PERxLPEN bit
            RCC_MP_MLAHBLPENSETR: mmio.Mmio(packed struct(u32) {
                ///  SRAM1LPEN
                SRAM1LPEN: u1,
                ///  SRAM2LPEN
                SRAM2LPEN: u1,
                ///  SRAM34LPEN
                SRAM34LPEN: u1,
                reserved4: u1,
                ///  RETRAMLPEN
                RETRAMLPEN: u1,
                padding: u27,
            }),
            ///  This register is used by the MPU in order to clear the PERxLPEN bit
            RCC_MP_MLAHBLPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  SRAM1LPEN
                SRAM1LPEN: u1,
                ///  SRAM2LPEN
                SRAM2LPEN: u1,
                ///  SRAM34LPEN
                SRAM34LPEN: u1,
                reserved4: u1,
                ///  RETRAMLPEN
                RETRAMLPEN: u1,
                padding: u27,
            }),
            reserved2944: [64]u8,
            ///  This register is used by the MCU in order to set the PERxLPEN bit.
            RCC_MC_APB1LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  TIM2LPEN
                TIM2LPEN: u1,
                ///  TIM3LPEN
                TIM3LPEN: u1,
                ///  TIM4LPEN
                TIM4LPEN: u1,
                ///  TIM5LPEN
                TIM5LPEN: u1,
                ///  TIM6LPEN
                TIM6LPEN: u1,
                ///  TIM7LPEN
                TIM7LPEN: u1,
                ///  TIM12LPEN
                TIM12LPEN: u1,
                ///  TIM13LPEN
                TIM13LPEN: u1,
                ///  TIM14LPEN
                TIM14LPEN: u1,
                ///  LPTIM1LPEN
                LPTIM1LPEN: u1,
                reserved11: u1,
                ///  SPI2LPEN
                SPI2LPEN: u1,
                ///  SPI3LPEN
                SPI3LPEN: u1,
                reserved14: u1,
                ///  USART2LPEN
                USART2LPEN: u1,
                ///  USART3LPEN
                USART3LPEN: u1,
                ///  UART4LPEN
                UART4LPEN: u1,
                ///  UART5LPEN
                UART5LPEN: u1,
                ///  UART7LPEN
                UART7LPEN: u1,
                ///  UART8LPEN
                UART8LPEN: u1,
                reserved21: u1,
                ///  I2C1LPEN
                I2C1LPEN: u1,
                ///  I2C2LPEN
                I2C2LPEN: u1,
                ///  I2C3LPEN
                I2C3LPEN: u1,
                ///  I2C5LPEN
                I2C5LPEN: u1,
                reserved26: u1,
                ///  SPDIFLPEN
                SPDIFLPEN: u1,
                ///  CECLPEN
                CECLPEN: u1,
                ///  WWDG1LPEN
                WWDG1LPEN: u1,
                ///  DAC12LPEN
                DAC12LPEN: u1,
                reserved31: u1,
                ///  MDIOSLPEN
                MDIOSLPEN: u1,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bits
            RCC_MC_APB1LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  TIM2LPEN
                TIM2LPEN: u1,
                ///  TIM3LPEN
                TIM3LPEN: u1,
                ///  TIM4LPEN
                TIM4LPEN: u1,
                ///  TIM5LPEN
                TIM5LPEN: u1,
                ///  TIM6LPEN
                TIM6LPEN: u1,
                ///  TIM7LPEN
                TIM7LPEN: u1,
                ///  TIM12LPEN
                TIM12LPEN: u1,
                ///  TIM13LPEN
                TIM13LPEN: u1,
                ///  TIM14LPEN
                TIM14LPEN: u1,
                ///  LPTIM1LPEN
                LPTIM1LPEN: u1,
                reserved11: u1,
                ///  SPI2LPEN
                SPI2LPEN: u1,
                ///  SPI3LPEN
                SPI3LPEN: u1,
                reserved14: u1,
                ///  USART2LPEN
                USART2LPEN: u1,
                ///  USART3LPEN
                USART3LPEN: u1,
                ///  UART4LPEN
                UART4LPEN: u1,
                ///  UART5LPEN
                UART5LPEN: u1,
                ///  UART7LPEN
                UART7LPEN: u1,
                ///  UART8LPEN
                UART8LPEN: u1,
                reserved21: u1,
                ///  I2C1LPEN
                I2C1LPEN: u1,
                ///  I2C2LPEN
                I2C2LPEN: u1,
                ///  I2C3LPEN
                I2C3LPEN: u1,
                ///  I2C5LPEN
                I2C5LPEN: u1,
                reserved26: u1,
                ///  SPDIFLPEN
                SPDIFLPEN: u1,
                ///  CECLPEN
                CECLPEN: u1,
                ///  WWDG1LPEN
                WWDG1LPEN: u1,
                ///  DAC12LPEN
                DAC12LPEN: u1,
                reserved31: u1,
                ///  MDIOSLPEN
                MDIOSLPEN: u1,
            }),
            ///  This register is used by the MCU in order to set the PERxLPEN bit.
            RCC_MC_APB2LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  TIM1LPEN
                TIM1LPEN: u1,
                ///  TIM8LPEN
                TIM8LPEN: u1,
                ///  TIM15LPEN
                TIM15LPEN: u1,
                ///  TIM16LPEN
                TIM16LPEN: u1,
                ///  TIM17LPEN
                TIM17LPEN: u1,
                reserved8: u3,
                ///  SPI1LPEN
                SPI1LPEN: u1,
                ///  SPI4LPEN
                SPI4LPEN: u1,
                ///  SPI5LPEN
                SPI5LPEN: u1,
                reserved13: u2,
                ///  USART6LPEN
                USART6LPEN: u1,
                reserved16: u2,
                ///  SAI1LPEN
                SAI1LPEN: u1,
                ///  SAI2LPEN
                SAI2LPEN: u1,
                ///  SAI3LPEN
                SAI3LPEN: u1,
                reserved20: u1,
                ///  DFSDMLPEN
                DFSDMLPEN: u1,
                ///  ADFSDMLPEN
                ADFSDMLPEN: u1,
                reserved24: u2,
                ///  FDCANLPEN
                FDCANLPEN: u1,
                padding: u7,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bit
            RCC_MC_APB2LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  TIM1LPEN
                TIM1LPEN: u1,
                ///  TIM8LPEN
                TIM8LPEN: u1,
                ///  TIM15LPEN
                TIM15LPEN: u1,
                ///  TIM16LPEN
                TIM16LPEN: u1,
                ///  TIM17LPEN
                TIM17LPEN: u1,
                reserved8: u3,
                ///  SPI1LPEN
                SPI1LPEN: u1,
                ///  SPI4LPEN
                SPI4LPEN: u1,
                ///  SPI5LPEN
                SPI5LPEN: u1,
                reserved13: u2,
                ///  USART6LPEN
                USART6LPEN: u1,
                reserved16: u2,
                ///  SAI1LPEN
                SAI1LPEN: u1,
                ///  SAI2LPEN
                SAI2LPEN: u1,
                ///  SAI3LPEN
                SAI3LPEN: u1,
                reserved20: u1,
                ///  DFSDMLPEN
                DFSDMLPEN: u1,
                ///  ADFSDMLPEN
                ADFSDMLPEN: u1,
                reserved24: u2,
                ///  FDCANLPEN
                FDCANLPEN: u1,
                padding: u7,
            }),
            ///  This register is used by the MCU in order to set the PERxLPEN bit.
            RCC_MC_APB3LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM2LPEN
                LPTIM2LPEN: u1,
                ///  LPTIM3LPEN
                LPTIM3LPEN: u1,
                ///  LPTIM4LPEN
                LPTIM4LPEN: u1,
                ///  LPTIM5LPEN
                LPTIM5LPEN: u1,
                reserved8: u4,
                ///  SAI4LPEN
                SAI4LPEN: u1,
                reserved11: u2,
                ///  SYSCFGLPEN
                SYSCFGLPEN: u1,
                reserved13: u1,
                ///  VREFLPEN
                VREFLPEN: u1,
                reserved16: u2,
                ///  DTSLPEN
                DTSLPEN: u1,
                padding: u15,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bit
            RCC_MC_APB3LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  LPTIM2LPEN
                LPTIM2LPEN: u1,
                ///  LPTIM3LPEN
                LPTIM3LPEN: u1,
                ///  LPTIM4LPEN
                LPTIM4LPEN: u1,
                ///  LPTIM5LPEN
                LPTIM5LPEN: u1,
                reserved8: u4,
                ///  SAI4LPEN
                SAI4LPEN: u1,
                reserved11: u2,
                ///  SYSCFGLPEN
                SYSCFGLPEN: u1,
                reserved13: u1,
                ///  VREFLPEN
                VREFLPEN: u1,
                reserved16: u2,
                ///  DTSLPEN
                DTSLPEN: u1,
                padding: u15,
            }),
            ///  This register is used by the MCU in order to set the PERxLPEN bit.
            RCC_MC_AHB2LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  DMA1LPEN
                DMA1LPEN: u1,
                ///  DMA2LPEN
                DMA2LPEN: u1,
                ///  DMAMUXLPEN
                DMAMUXLPEN: u1,
                reserved5: u2,
                ///  ADC12LPEN
                ADC12LPEN: u1,
                reserved8: u2,
                ///  USBOLPEN
                USBOLPEN: u1,
                reserved16: u7,
                ///  SDMMC3LPEN
                SDMMC3LPEN: u1,
                padding: u15,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bit
            RCC_MC_AHB2LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  DMA1LPEN
                DMA1LPEN: u1,
                ///  DMA2LPEN
                DMA2LPEN: u1,
                ///  DMAMUXLPEN
                DMAMUXLPEN: u1,
                reserved5: u2,
                ///  ADC12LPEN
                ADC12LPEN: u1,
                reserved8: u2,
                ///  USBOLPEN
                USBOLPEN: u1,
                reserved16: u7,
                ///  SDMMC3LPEN
                SDMMC3LPEN: u1,
                padding: u15,
            }),
            ///  This register is used by the MCU in order to set the PERxLPEN bit.
            RCC_MC_AHB3LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  DCMILPEN
                DCMILPEN: u1,
                reserved4: u3,
                ///  CRYP2LPEN
                CRYP2LPEN: u1,
                ///  HASH2LPEN
                HASH2LPEN: u1,
                ///  RNG2LPEN
                RNG2LPEN: u1,
                ///  CRC2LPEN
                CRC2LPEN: u1,
                reserved11: u3,
                ///  HSEMLPEN
                HSEMLPEN: u1,
                ///  IPCCLPEN
                IPCCLPEN: u1,
                padding: u19,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bit
            RCC_MC_AHB3LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  DCMILPEN
                DCMILPEN: u1,
                reserved4: u3,
                ///  CRYP2LPEN
                CRYP2LPEN: u1,
                ///  HASH2LPEN
                HASH2LPEN: u1,
                ///  RNG2LPEN
                RNG2LPEN: u1,
                ///  CRC2LPEN
                CRC2LPEN: u1,
                reserved11: u3,
                ///  HSEMLPEN
                HSEMLPEN: u1,
                ///  IPCCLPEN
                IPCCLPEN: u1,
                padding: u19,
            }),
            ///  This register is used by the MCU in order to set the PERxLPEN bit.
            RCC_MC_AHB4LPENSETR: mmio.Mmio(packed struct(u32) {
                ///  GPIOALPEN
                GPIOALPEN: u1,
                ///  GPIOBLPEN
                GPIOBLPEN: u1,
                ///  GPIOCLPEN
                GPIOCLPEN: u1,
                ///  GPIODLPEN
                GPIODLPEN: u1,
                ///  GPIOELPEN
                GPIOELPEN: u1,
                ///  GPIOFLPEN
                GPIOFLPEN: u1,
                ///  GPIOGLPEN
                GPIOGLPEN: u1,
                ///  GPIOHLPEN
                GPIOHLPEN: u1,
                ///  GPIOILPEN
                GPIOILPEN: u1,
                ///  GPIOJLPEN
                GPIOJLPEN: u1,
                ///  GPIOKLPEN
                GPIOKLPEN: u1,
                padding: u21,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bit of the corresponding peripheral.
            RCC_MC_AHB4LPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  GPIOALPEN
                GPIOALPEN: u1,
                ///  GPIOBLPEN
                GPIOBLPEN: u1,
                ///  GPIOCLPEN
                GPIOCLPEN: u1,
                ///  GPIODLPEN
                GPIODLPEN: u1,
                ///  GPIOELPEN
                GPIOELPEN: u1,
                ///  GPIOFLPEN
                GPIOFLPEN: u1,
                ///  GPIOGLPEN
                GPIOGLPEN: u1,
                ///  GPIOHLPEN
                GPIOHLPEN: u1,
                ///  GPIOILPEN
                GPIOILPEN: u1,
                ///  GPIOJLPEN
                GPIOJLPEN: u1,
                ///  GPIOKLPEN
                GPIOKLPEN: u1,
                padding: u21,
            }),
            ///  This register is used by the MCU in order to set the PERxLPEN bit of the corresponding peripheral.
            RCC_MC_AXIMLPENSETR: mmio.Mmio(packed struct(u32) {
                ///  SYSRAMLPEN
                SYSRAMLPEN: u1,
                padding: u31,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bit of the corresponding peripheral.
            RCC_MC_AXIMLPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  SYSRAMLPEN
                SYSRAMLPEN: u1,
                padding: u31,
            }),
            ///  This register is used by the MCU in order to set the PERxLPEN bit of the corresponding peripheral.
            RCC_MC_MLAHBLPENSETR: mmio.Mmio(packed struct(u32) {
                ///  SRAM1LPEN
                SRAM1LPEN: u1,
                ///  SRAM2LPEN
                SRAM2LPEN: u1,
                ///  SRAM34LPEN
                SRAM34LPEN: u1,
                reserved4: u1,
                ///  RETRAMLPEN
                RETRAMLPEN: u1,
                padding: u27,
            }),
            ///  This register is used by the MCU in order to clear the PERxLPEN bit of the corresponding peripheral.
            RCC_MC_MLAHBLPENCLRR: mmio.Mmio(packed struct(u32) {
                ///  SRAM1LPEN
                SRAM1LPEN: u1,
                ///  SRAM2LPEN
                SRAM2LPEN: u1,
                ///  SRAM34LPEN
                SRAM34LPEN: u1,
                reserved4: u1,
                ///  RETRAMLPEN
                RETRAMLPEN: u1,
                padding: u27,
            }),
            reserved3072: [64]u8,
            ///  This register is used by the MCU to check the reset source.
            RCC_MC_RSTSCLRR: mmio.Mmio(packed struct(u32) {
                ///  PORRSTF
                PORRSTF: u1,
                ///  BORRSTF
                BORRSTF: u1,
                ///  PADRSTF
                PADRSTF: u1,
                ///  HCSSRSTF
                HCSSRSTF: u1,
                ///  VCORERSTF
                VCORERSTF: u1,
                ///  MCURSTF
                MCURSTF: u1,
                ///  MPSYSRSTF
                MPSYSRSTF: u1,
                ///  MCSYSRSTF
                MCSYSRSTF: u1,
                ///  IWDG1RSTF
                IWDG1RSTF: u1,
                ///  IWDG2RSTF
                IWDG2RSTF: u1,
                ///  WWDG1RSTF
                WWDG1RSTF: u1,
                padding: u21,
            }),
            reserved3092: [16]u8,
            ///  This register shall be used by the MCU to control the interrupt source enable. Refer to Section10.5: RCC interrupts for more details.
            RCC_MC_CIER: mmio.Mmio(packed struct(u32) {
                ///  LSIRDYIE
                LSIRDYIE: u1,
                ///  LSERDYIE
                LSERDYIE: u1,
                ///  HSIRDYIE
                HSIRDYIE: u1,
                ///  HSERDYIE
                HSERDYIE: u1,
                ///  CSIRDYIE
                CSIRDYIE: u1,
                reserved8: u3,
                ///  PLL1DYIE
                PLL1DYIE: u1,
                ///  PLL2DYIE
                PLL2DYIE: u1,
                ///  PLL3DYIE
                PLL3DYIE: u1,
                ///  PLL4DYIE
                PLL4DYIE: u1,
                reserved16: u4,
                ///  LSECSSIE
                LSECSSIE: u1,
                reserved20: u3,
                ///  WKUPIE
                WKUPIE: u1,
                padding: u11,
            }),
            ///  This register shall be used by the MCU in order to read and clear the interrupt flags.
            RCC_MC_CIFR: mmio.Mmio(packed struct(u32) {
                ///  LSIRDYF
                LSIRDYF: u1,
                ///  LSERDYF
                LSERDYF: u1,
                ///  HSIRDYF
                HSIRDYF: u1,
                ///  HSERDYF
                HSERDYF: u1,
                ///  CSIRDYF
                CSIRDYF: u1,
                reserved8: u3,
                ///  PLL1DYF
                PLL1DYF: u1,
                ///  PLL2DYF
                PLL2DYF: u1,
                ///  PLL3DYF
                PLL3DYF: u1,
                ///  PLL4DYF
                PLL4DYF: u1,
                reserved16: u4,
                ///  LSECSSF
                LSECSSF: u1,
                reserved20: u3,
                ///  WKUPF
                WKUPF: u1,
                padding: u11,
            }),
            reserved4084: [984]u8,
            ///  This register gives the IP version
            RCC_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  This register gives the unique identifier of the RCC
            RCC_IDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  This register gives the decoding space, which is for the RCC of 4 kB.
            RCC_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  RNG1
        pub const RNG1 = extern struct {
            ///  RNG control register
            RNG_CR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  RNGEN
                RNGEN: u1,
                ///  IE
                IE: u1,
                reserved5: u1,
                ///  CED
                CED: u1,
                padding: u26,
            }),
            ///  RNG status register
            RNG_SR: mmio.Mmio(packed struct(u32) {
                ///  DRDY
                DRDY: u1,
                ///  CECS
                CECS: u1,
                ///  SECS
                SECS: u1,
                reserved5: u2,
                ///  CEIS
                CEIS: u1,
                ///  SEIS
                SEIS: u1,
                padding: u25,
            }),
            ///  The RNG_DR register is a read-only register.
            RNG_DR: mmio.Mmio(packed struct(u32) {
                ///  RNDATA
                RNDATA: u32,
            }),
            reserved1008: [996]u8,
            ///  RNG hardware configuration register
            RNG_HWCFGR: u32,
            ///  RNG version register
            RNG_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  RNG identification register
            RNG_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  RNG size ID register
            RNG_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  TIM13
        pub const TIM13 = extern struct {
            ///  TIM13 control register 1
            TIM13_CR1: mmio.Mmio(packed struct(u16) {
                ///  CEN
                CEN: u1,
                ///  UDIS
                UDIS: u1,
                ///  URS
                URS: u1,
                ///  OPM
                OPM: u1,
                reserved7: u3,
                ///  ARPE
                ARPE: u1,
                ///  CKD
                CKD: u2,
                reserved11: u1,
                ///  UIFREMAP
                UIFREMAP: u1,
                padding: u4,
            }),
            reserved12: [10]u8,
            ///  TIM13 Interrupt enable register
            TIM13_DIER: mmio.Mmio(packed struct(u16) {
                ///  UIE
                UIE: u1,
                ///  CC1IE
                CC1IE: u1,
                padding: u14,
            }),
            reserved16: [2]u8,
            ///  TIM13 status register
            TIM13_SR: mmio.Mmio(packed struct(u16) {
                ///  UIF
                UIF: u1,
                ///  CC1IF
                CC1IF: u1,
                reserved9: u7,
                ///  CC1OF
                CC1OF: u1,
                padding: u6,
            }),
            reserved20: [2]u8,
            ///  TIM13 event generation register
            TIM13_EGR: mmio.Mmio(packed struct(u16) {
                ///  UG
                UG: u1,
                ///  CC1G
                CC1G: u1,
                padding: u14,
            }),
            reserved24: [2]u8,
            ///  The channels can be used in input (capture mode) or in output (compare mode). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function in input and in output mode. For a given bit, OCxx describes its function when the channel is configured in output, ICxx describes its function when the channel is configured in input. So one must take care that the same bit can have a different meaning for the input stage and for the output stage. Output compare mode
            TIM13_CCMR1: mmio.Mmio(packed struct(u32) {
                ///  CC1S
                CC1S: u2,
                ///  OC1FE
                OC1FE: u1,
                ///  OC1PE
                OC1PE: u1,
                ///  OC1M
                OC1M: u3,
                reserved16: u9,
                ///  OC1M3
                OC1M3: u1,
                padding: u15,
            }),
            reserved32: [4]u8,
            ///  TIM13 capture/compare enable register
            TIM13_CCER: mmio.Mmio(packed struct(u16) {
                ///  CC1E
                CC1E: u1,
                ///  CC1P
                CC1P: u1,
                reserved3: u1,
                ///  CC1NP
                CC1NP: u1,
                padding: u12,
            }),
            reserved36: [2]u8,
            ///  TIM13 counter
            TIM13_CNT: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u16,
                reserved31: u15,
                ///  UIFCPY
                UIFCPY: u1,
            }),
            ///  TIM13 prescaler
            TIM13_PSC: mmio.Mmio(packed struct(u16) {
                ///  PSC
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM13 auto-reload register
            TIM13_ARR: mmio.Mmio(packed struct(u16) {
                ///  ARR
                ARR: u16,
            }),
            reserved52: [6]u8,
            ///  TIM13 capture/compare register 1
            TIM13_CCR1: mmio.Mmio(packed struct(u16) {
                ///  CCR1
                CCR1: u16,
            }),
            reserved104: [50]u8,
            ///  TIM13 timer input selection register
            TIM13_TISEL: mmio.Mmio(packed struct(u16) {
                ///  TI1SEL
                TI1SEL: u4,
                padding: u12,
            }),
        };

        ///  RTC
        pub const RTC = extern struct {
            ///  The RTC_TR is the calendar time shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page1830 and Reading the calendar on page1831. This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be write-protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_TR: mmio.Mmio(packed struct(u32) {
                ///  SU
                SU: u4,
                ///  ST
                ST: u3,
                reserved8: u1,
                ///  MNU
                MNU: u4,
                ///  MNT
                MNT: u3,
                reserved16: u1,
                ///  HU
                HU: u4,
                ///  HT
                HT: u2,
                ///  PM
                PM: u1,
                padding: u9,
            }),
            ///  The RTC_DR is the calendar date shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page1830 and Reading the calendar on page1831. This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be write-protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_DR: mmio.Mmio(packed struct(u32) {
                ///  DU
                DU: u4,
                ///  DT
                DT: u2,
                reserved8: u2,
                ///  MU
                MU: u4,
                ///  MT
                MT: u1,
                ///  WDU
                WDU: u3,
                ///  YU
                YU: u4,
                ///  YT
                YT: u4,
                padding: u8,
            }),
            ///  RTC sub second register
            RTC_SSR: mmio.Mmio(packed struct(u32) {
                ///  SS
                SS: u16,
                padding: u16,
            }),
            ///  This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be globally protected, or each bit of this register can be individually protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_ICSR: mmio.Mmio(packed struct(u32) {
                ///  ALRAWF
                ALRAWF: u1,
                ///  ALRBWF
                ALRBWF: u1,
                ///  WUTWF
                WUTWF: u1,
                ///  SHPF
                SHPF: u1,
                ///  INITS
                INITS: u1,
                ///  RSF
                RSF: u1,
                ///  INITF
                INITF: u1,
                ///  INIT
                INIT: u1,
                reserved16: u8,
                ///  RECALPF
                RECALPF: u1,
                padding: u15,
            }),
            ///  This register must be written in initialization mode only. The initialization must be performed in two separate write accesses. Refer to Calendar initialization and configuration on page1830. This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be write-protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_PRER: mmio.Mmio(packed struct(u32) {
                ///  PREDIV_S
                PREDIV_S: u15,
                reserved16: u1,
                ///  PREDIV_A
                PREDIV_A: u7,
                padding: u9,
            }),
            ///  This register can be written only when WUTWF is set to 1 in RTC_ICSR. This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_WUTR: mmio.Mmio(packed struct(u32) {
                ///  WUT
                WUT: u16,
                padding: u16,
            }),
            ///  This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be globally protected, or each bit of this register can be individually protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_CR: mmio.Mmio(packed struct(u32) {
                ///  WUCKSEL
                WUCKSEL: u3,
                ///  TSEDGE
                TSEDGE: u1,
                ///  REFCKON
                REFCKON: u1,
                ///  BYPSHAD
                BYPSHAD: u1,
                ///  FMT
                FMT: u1,
                reserved8: u1,
                ///  ALRAE
                ALRAE: u1,
                ///  ALRBE
                ALRBE: u1,
                ///  WUTE
                WUTE: u1,
                ///  TSE
                TSE: u1,
                ///  ALRAIE
                ALRAIE: u1,
                ///  ALRBIE
                ALRBIE: u1,
                ///  WUTIE
                WUTIE: u1,
                ///  TSIE
                TSIE: u1,
                ///  ADD1H
                ADD1H: u1,
                ///  SUB1H
                SUB1H: u1,
                ///  BKP
                BKP: u1,
                ///  COSEL
                COSEL: u1,
                ///  POL
                POL: u1,
                ///  OSEL
                OSEL: u2,
                ///  COE
                COE: u1,
                ///  ITSE
                ITSE: u1,
                ///  TAMPTS
                TAMPTS: u1,
                ///  TAMPOE
                TAMPOE: u1,
                reserved29: u2,
                ///  TAMPALRM_PU
                TAMPALRM_PU: u1,
                ///  TAMPALRM_TYPE
                TAMPALRM_TYPE: u1,
                ///  OUT2EN
                OUT2EN: u1,
            }),
            reserved32: [4]u8,
            ///  This register can be written only when the APB access is secure.
            RTC_SMCR: mmio.Mmio(packed struct(u32) {
                ///  ALRADPROT
                ALRADPROT: u1,
                ///  ALRBDPROT
                ALRBDPROT: u1,
                ///  WUTDPROT
                WUTDPROT: u1,
                ///  TSDPROT
                TSDPROT: u1,
                reserved13: u9,
                ///  CALDPROT
                CALDPROT: u1,
                ///  INITDPROT
                INITDPROT: u1,
                ///  DECPROT
                DECPROT: u1,
                padding: u16,
            }),
            ///  RTC write protection register
            RTC_WPR: mmio.Mmio(packed struct(u32) {
                ///  KEY
                KEY: u8,
                padding: u24,
            }),
            ///  This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be write-protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_CALR: mmio.Mmio(packed struct(u32) {
                ///  CALM
                CALM: u9,
                reserved13: u4,
                ///  CALW16
                CALW16: u1,
                ///  CALW8
                CALW8: u1,
                ///  CALP
                CALP: u1,
                padding: u16,
            }),
            ///  This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_SHIFTR: mmio.Mmio(packed struct(u32) {
                ///  SUBFS
                SUBFS: u15,
                reserved31: u16,
                ///  ADD1S
                ADD1S: u1,
            }),
            ///  The content of this register is valid only when TSF is set to 1 in RTC_SR. It is cleared when TSF bit is reset. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_TSTR: mmio.Mmio(packed struct(u32) {
                ///  SU
                SU: u4,
                ///  ST
                ST: u3,
                reserved8: u1,
                ///  MNU
                MNU: u4,
                ///  MNT
                MNT: u3,
                reserved16: u1,
                ///  HU
                HU: u4,
                ///  HT
                HT: u2,
                ///  PM
                PM: u1,
                padding: u9,
            }),
            ///  The content of this register is valid only when TSF is set to 1 in RTC_SR. It is cleared when TSF bit is reset. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_TSDR: mmio.Mmio(packed struct(u32) {
                ///  DU
                DU: u4,
                ///  DT
                DT: u2,
                reserved8: u2,
                ///  MU
                MU: u4,
                ///  MT
                MT: u1,
                ///  WDU
                WDU: u3,
                padding: u16,
            }),
            ///  The content of this register is valid only when TSF is set to 1 in RTC_SR. It is cleared when the TSF bit is reset. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_TSSSR: mmio.Mmio(packed struct(u32) {
                ///  SS
                SS: u16,
                padding: u16,
            }),
            reserved64: [4]u8,
            ///  This register can be written only when ALRAWF is set to 1 in RTC_ICSR, or in initialization mode. This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_ALRMAR: mmio.Mmio(packed struct(u32) {
                ///  SU
                SU: u4,
                ///  ST
                ST: u3,
                ///  MSK1
                MSK1: u1,
                ///  MNU
                MNU: u4,
                ///  MNT
                MNT: u3,
                ///  MSK2
                MSK2: u1,
                ///  HU
                HU: u4,
                ///  HT
                HT: u2,
                ///  PM
                PM: u1,
                ///  MSK3
                MSK3: u1,
                ///  DU
                DU: u4,
                ///  DT
                DT: u2,
                ///  WDSEL
                WDSEL: u1,
                ///  MSK4
                MSK4: u1,
            }),
            ///  This register can be written only when ALRAWF is set to 1 in RTC_ICSR, or in initialization mode. This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_ALRMASSR: mmio.Mmio(packed struct(u32) {
                ///  SS
                SS: u15,
                reserved24: u9,
                ///  MASKSS
                MASKSS: u4,
                padding: u4,
            }),
            ///  This register can be written only when ALRBWF is set to 1 in RTC_ICSR, or in initialization mode. This register is write protected. The write access procedure is described in RTC register write protection on page1830. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_ALRMBR: mmio.Mmio(packed struct(u32) {
                ///  SU
                SU: u4,
                ///  ST
                ST: u3,
                ///  MSK1
                MSK1: u1,
                ///  MNU
                MNU: u4,
                ///  MNT
                MNT: u3,
                ///  MSK2
                MSK2: u1,
                ///  HU
                HU: u4,
                ///  HT
                HT: u2,
                ///  PM
                PM: u1,
                ///  MSK3
                MSK3: u1,
                ///  DU
                DU: u4,
                ///  DT
                DT: u2,
                ///  WDSEL
                WDSEL: u1,
                ///  MSK4
                MSK4: u1,
            }),
            ///  This register can be written only when ALRBE is reset in RTC_CR register, or in initialization mode. This register is write protected.The write access procedure is described in Section: RTC register write protection. This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_ALRMBSSR: mmio.Mmio(packed struct(u32) {
                ///  SS
                SS: u15,
                reserved24: u9,
                ///  MASKSS
                MASKSS: u4,
                padding: u4,
            }),
            ///  This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_SR: mmio.Mmio(packed struct(u32) {
                ///  ALRAF
                ALRAF: u1,
                ///  ALRBF
                ALRBF: u1,
                ///  WUTF
                WUTF: u1,
                ///  TSF
                TSF: u1,
                ///  TSOVF
                TSOVF: u1,
                ///  ITSF
                ITSF: u1,
                padding: u26,
            }),
            ///  RTC non-secure masked interrupt status register
            RTC_MISR: mmio.Mmio(packed struct(u32) {
                ///  ALRAMF
                ALRAMF: u1,
                ///  ALRBMF
                ALRBMF: u1,
                ///  WUTMF
                WUTMF: u1,
                ///  TSMF
                TSMF: u1,
                ///  TSOVMF
                TSOVMF: u1,
                ///  ITSMF
                ITSMF: u1,
                padding: u26,
            }),
            ///  This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_SMISR: mmio.Mmio(packed struct(u32) {
                ///  ALRAMF
                ALRAMF: u1,
                ///  ALRBMF
                ALRBMF: u1,
                ///  WUTMF
                WUTMF: u1,
                ///  TSMF
                TSMF: u1,
                ///  TSOVMF
                TSOVMF: u1,
                ///  ITSMF
                ITSMF: u1,
                padding: u26,
            }),
            ///  This register can be protected against non-secure access. Refer to Section50.3.4: RTC secure protection modes.
            RTC_SCR: mmio.Mmio(packed struct(u32) {
                ///  CALRAF
                CALRAF: u1,
                ///  CALRBF
                CALRBF: u1,
                ///  CWUTF
                CWUTF: u1,
                ///  CTSF
                CTSF: u1,
                ///  CTSOVF
                CTSOVF: u1,
                ///  CITSF
                CITSF: u1,
                padding: u26,
            }),
            ///  RTC configuration register
            RTC_CFGR: mmio.Mmio(packed struct(u32) {
                ///  OUT2_RMP
                OUT2_RMP: u1,
                ///  LSCOEN
                LSCOEN: u2,
                padding: u29,
            }),
            reserved1008: [908]u8,
            ///  RTC hardware configuration register
            RTC_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  ALARMB
                ALARMB: u4,
                ///  WAKEUP
                WAKEUP: u4,
                ///  SMOOTH_CALIB
                SMOOTH_CALIB: u4,
                ///  TIMESTAMP
                TIMESTAMP: u4,
                ///  OPTIONREG_OUT
                OPTIONREG_OUT: u8,
                ///  TRUST_ZONE
                TRUST_ZONE: u4,
                padding: u4,
            }),
            ///  RTC version register
            RTC_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  RTC identification register
            RTC_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  RTC size identification register
            RTC_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  SAI1 register block
        pub const SAI1 = extern struct {
            ///  Global configuration register
            SAI_GCR: mmio.Mmio(packed struct(u32) {
                ///  SYNCIN
                SYNCIN: u2,
                reserved4: u2,
                ///  SYNCOUT
                SYNCOUT: u2,
                padding: u26,
            }),
            ///  Configuration register 1
            SAI_ACR1: mmio.Mmio(packed struct(u32) {
                ///  MODE
                MODE: u2,
                ///  PRTCFG
                PRTCFG: u2,
                reserved5: u1,
                ///  DS
                DS: u3,
                ///  LSBFIRST
                LSBFIRST: u1,
                ///  CKSTR
                CKSTR: u1,
                ///  SYNCEN
                SYNCEN: u2,
                ///  MONO
                MONO: u1,
                ///  OUTDRIV
                OUTDRIV: u1,
                reserved16: u2,
                ///  SAIEN
                SAIEN: u1,
                ///  DMAEN
                DMAEN: u1,
                reserved19: u1,
                ///  NODIV
                NODIV: u1,
                ///  MCKDIV
                MCKDIV: u6,
                ///  OSR
                OSR: u1,
                ///  MCKEN
                MCKEN: u1,
                padding: u4,
            }),
            ///  Configuration register 2
            SAI_ACR2: mmio.Mmio(packed struct(u32) {
                ///  FTH
                FTH: u3,
                ///  FFLUSH
                FFLUSH: u1,
                ///  TRIS
                TRIS: u1,
                ///  MUTE
                MUTE: u1,
                ///  MUTEVAL
                MUTEVAL: u1,
                ///  MUTECNT
                MUTECNT: u6,
                ///  CPL
                CPL: u1,
                ///  COMP
                COMP: u2,
                padding: u16,
            }),
            ///  This register has no meaning in and SPDIF audio protocol
            SAI_AFRCR: mmio.Mmio(packed struct(u32) {
                ///  FRL
                FRL: u8,
                ///  FSALL
                FSALL: u7,
                reserved16: u1,
                ///  FSDEF
                FSDEF: u1,
                ///  FSPOL
                FSPOL: u1,
                ///  FSOFF
                FSOFF: u1,
                padding: u13,
            }),
            ///  This register has no meaning in and SPDIF audio protocol
            SAI_ASLOTR: mmio.Mmio(packed struct(u32) {
                ///  FBOFF
                FBOFF: u5,
                reserved6: u1,
                ///  SLOTSZ
                SLOTSZ: u2,
                ///  NBSLOT
                NBSLOT: u4,
                reserved16: u4,
                ///  SLOTEN
                SLOTEN: u16,
            }),
            ///  Interrupt mask register
            SAI_AIM: mmio.Mmio(packed struct(u32) {
                ///  OVRUDRIE
                OVRUDRIE: u1,
                ///  MUTEDETIE
                MUTEDETIE: u1,
                ///  WCKCFGIE
                WCKCFGIE: u1,
                ///  FREQIE
                FREQIE: u1,
                ///  CNRDYIE
                CNRDYIE: u1,
                ///  AFSDETIE
                AFSDETIE: u1,
                ///  LFSDETIE
                LFSDETIE: u1,
                padding: u25,
            }),
            ///  Status register
            SAI_ASR: mmio.Mmio(packed struct(u32) {
                ///  OVRUDR
                OVRUDR: u1,
                ///  MUTEDET
                MUTEDET: u1,
                ///  WCKCFG
                WCKCFG: u1,
                ///  FREQ
                FREQ: u1,
                ///  CNRDY
                CNRDY: u1,
                ///  AFSDET
                AFSDET: u1,
                ///  LFSDET
                LFSDET: u1,
                reserved16: u9,
                ///  FLVL
                FLVL: u3,
                padding: u13,
            }),
            ///  Clear flag register
            SAI_ACLRFR: mmio.Mmio(packed struct(u32) {
                ///  COVRUDR
                COVRUDR: u1,
                ///  CMUTEDET
                CMUTEDET: u1,
                ///  CWCKCFG
                CWCKCFG: u1,
                reserved4: u1,
                ///  CCNRDY
                CCNRDY: u1,
                ///  CAFSDET
                CAFSDET: u1,
                ///  CLFSDET
                CLFSDET: u1,
                padding: u25,
            }),
            ///  Data register
            SAI_ADR: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  Configuration register 1
            SAI_BCR1: mmio.Mmio(packed struct(u32) {
                ///  MODE
                MODE: u2,
                ///  PRTCFG
                PRTCFG: u2,
                reserved5: u1,
                ///  DS
                DS: u3,
                ///  LSBFIRST
                LSBFIRST: u1,
                ///  CKSTR
                CKSTR: u1,
                ///  SYNCEN
                SYNCEN: u2,
                ///  MONO
                MONO: u1,
                ///  OUTDRIV
                OUTDRIV: u1,
                reserved16: u2,
                ///  SAIEN
                SAIEN: u1,
                ///  DMAEN
                DMAEN: u1,
                reserved19: u1,
                ///  NODIV
                NODIV: u1,
                ///  MCKDIV
                MCKDIV: u6,
                ///  OSR
                OSR: u1,
                ///  MCKEN
                MCKEN: u1,
                padding: u4,
            }),
            ///  Configuration register 2
            SAI_BCR2: mmio.Mmio(packed struct(u32) {
                ///  FTH
                FTH: u3,
                ///  FFLUSH
                FFLUSH: u1,
                ///  TRIS
                TRIS: u1,
                ///  MUTE
                MUTE: u1,
                ///  MUTEVAL
                MUTEVAL: u1,
                ///  MUTECNT
                MUTECNT: u6,
                ///  CPL
                CPL: u1,
                ///  COMP
                COMP: u2,
                padding: u16,
            }),
            ///  This register has no meaning in and SPDIF audio protocol
            SAI_BFRCR: mmio.Mmio(packed struct(u32) {
                ///  FRL
                FRL: u8,
                ///  FSALL
                FSALL: u7,
                reserved16: u1,
                ///  FSDEF
                FSDEF: u1,
                ///  FSPOL
                FSPOL: u1,
                ///  FSOFF
                FSOFF: u1,
                padding: u13,
            }),
            ///  This register has no meaning in and SPDIF audio protocol
            SAI_BSLOTR: mmio.Mmio(packed struct(u32) {
                ///  FBOFF
                FBOFF: u5,
                reserved6: u1,
                ///  SLOTSZ
                SLOTSZ: u2,
                ///  NBSLOT
                NBSLOT: u4,
                reserved16: u4,
                ///  SLOTEN
                SLOTEN: u16,
            }),
            ///  Interrupt mask register
            SAI_BIM: mmio.Mmio(packed struct(u32) {
                ///  OVRUDRIE
                OVRUDRIE: u1,
                ///  MUTEDETIE
                MUTEDETIE: u1,
                ///  WCKCFGIE
                WCKCFGIE: u1,
                ///  FREQIE
                FREQIE: u1,
                ///  CNRDYIE
                CNRDYIE: u1,
                ///  AFSDETIE
                AFSDETIE: u1,
                ///  LFSDETIE
                LFSDETIE: u1,
                padding: u25,
            }),
            ///  Status register
            SAI_BSR: mmio.Mmio(packed struct(u32) {
                ///  OVRUDR
                OVRUDR: u1,
                ///  MUTEDET
                MUTEDET: u1,
                ///  WCKCFG
                WCKCFG: u1,
                ///  FREQ
                FREQ: u1,
                ///  CNRDY
                CNRDY: u1,
                ///  AFSDET
                AFSDET: u1,
                ///  LFSDET
                LFSDET: u1,
                reserved16: u9,
                ///  FLVL
                FLVL: u3,
                padding: u13,
            }),
            ///  Clear flag register
            SAI_BCLRFR: mmio.Mmio(packed struct(u32) {
                ///  COVRUDR
                COVRUDR: u1,
                ///  CMUTEDET
                CMUTEDET: u1,
                ///  CWCKCFG
                CWCKCFG: u1,
                reserved4: u1,
                ///  CCNRDY
                CCNRDY: u1,
                ///  CAFSDET
                CAFSDET: u1,
                ///  CLFSDET
                CLFSDET: u1,
                padding: u25,
            }),
            ///  Data register
            SAI_BDR: mmio.Mmio(packed struct(u32) {
                ///  DATA
                DATA: u32,
            }),
            ///  PDM control register
            SAI_PDMCR: mmio.Mmio(packed struct(u32) {
                ///  PDMEN
                PDMEN: u1,
                reserved4: u3,
                ///  MICNBR
                MICNBR: u2,
                reserved8: u2,
                ///  CKEN1
                CKEN1: u1,
                ///  CKEN2
                CKEN2: u1,
                ///  CKEN3
                CKEN3: u1,
                ///  CKEN4
                CKEN4: u1,
                padding: u20,
            }),
            ///  PDM delay register
            SAI_PDMDLY: mmio.Mmio(packed struct(u32) {
                ///  DLYM1L
                DLYM1L: u3,
                reserved4: u1,
                ///  DLYM1R
                DLYM1R: u3,
                reserved8: u1,
                ///  DLYM2L
                DLYM2L: u3,
                reserved12: u1,
                ///  DLYM2R
                DLYM2R: u3,
                reserved16: u1,
                ///  DLYM3L
                DLYM3L: u3,
                reserved20: u1,
                ///  DLYM3R
                DLYM3R: u3,
                reserved24: u1,
                ///  DLYM4L
                DLYM4L: u3,
                reserved28: u1,
                ///  DLYM4R
                DLYM4R: u3,
                padding: u1,
            }),
            reserved1008: [932]u8,
            ///  SAI hardware configuration register
            SAI_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  FIFO_SIZE
                FIFO_SIZE: u8,
                ///  SPDIF_PDM
                SPDIF_PDM: u4,
                ///  OPTION_REGOUT
                OPTION_REGOUT: u8,
                padding: u12,
            }),
            ///  SAI version register
            SAI_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  SAI identification register
            SAI_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  SAI size identification register
            SAI_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  TIM12
        pub const TIM12 = extern struct {
            ///  TIM12 control register 1
            TIM12_CR1: mmio.Mmio(packed struct(u16) {
                ///  CEN
                CEN: u1,
                ///  UDIS
                UDIS: u1,
                ///  URS
                URS: u1,
                ///  OPM
                OPM: u1,
                reserved7: u3,
                ///  ARPE
                ARPE: u1,
                ///  CKD
                CKD: u2,
                reserved11: u1,
                ///  UIFREMAP
                UIFREMAP: u1,
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM12 control register 2
            TIM12_CR2: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                ///  MMS
                MMS: u3,
                ///  TI1S
                TI1S: u1,
                padding: u24,
            }),
            ///  TIM12 slave mode control register
            TIM12_SMCR: mmio.Mmio(packed struct(u32) {
                ///  SMS
                SMS: u3,
                reserved4: u1,
                ///  TS
                TS: u3,
                ///  MSM
                MSM: u1,
                reserved16: u8,
                ///  SMS_3
                SMS_3: u1,
                reserved20: u3,
                ///  TS_3
                TS_3: u1,
                ///  TS_4
                TS_4: u1,
                padding: u10,
            }),
            ///  TIM12 interrupt enable register
            TIM12_DIER: mmio.Mmio(packed struct(u16) {
                ///  UIE
                UIE: u1,
                ///  CC1IE
                CC1IE: u1,
                ///  CC2IE
                CC2IE: u1,
                reserved6: u3,
                ///  TIE
                TIE: u1,
                padding: u9,
            }),
            reserved16: [2]u8,
            ///  TIM12 status register
            TIM12_SR: mmio.Mmio(packed struct(u32) {
                ///  UIF
                UIF: u1,
                ///  CC1IF
                CC1IF: u1,
                ///  CC2IF
                CC2IF: u1,
                reserved6: u3,
                ///  TIF
                TIF: u1,
                reserved9: u2,
                ///  CC1OF
                CC1OF: u1,
                ///  CC2OF
                CC2OF: u1,
                padding: u21,
            }),
            ///  TIM12 event generation register
            TIM12_EGR: mmio.Mmio(packed struct(u16) {
                ///  UG
                UG: u1,
                ///  CC1G
                CC1G: u1,
                ///  CC2G
                CC2G: u1,
                reserved6: u3,
                ///  TG
                TG: u1,
                padding: u9,
            }),
            reserved24: [2]u8,
            ///  TIM12 capture/compare mode register 1
            TIM12_CCMR1_input: mmio.Mmio(packed struct(u32) {
                ///  CC1S
                CC1S: u2,
                ///  IC1PSC
                IC1PSC: u2,
                ///  IC1F
                IC1F: u4,
                ///  CC2S
                CC2S: u2,
                ///  IC2PSC
                IC2PSC: u2,
                ///  IC2F
                IC2F: u4,
                padding: u16,
            }),
            reserved32: [4]u8,
            ///  TIM12 capture/compare enable register
            TIM12_CCER: mmio.Mmio(packed struct(u32) {
                ///  CC1E
                CC1E: u1,
                ///  CC1P
                CC1P: u1,
                reserved3: u1,
                ///  CC1NP
                CC1NP: u1,
                ///  CC2E
                CC2E: u1,
                ///  CC2P
                CC2P: u1,
                reserved7: u1,
                ///  CC2NP
                CC2NP: u1,
                padding: u24,
            }),
            ///  TIM12 counter
            TIM12_CNT: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u16,
                reserved31: u15,
                ///  UIFCPY
                UIFCPY: u1,
            }),
            ///  TIM12 prescaler
            TIM12_PSC: mmio.Mmio(packed struct(u16) {
                ///  PSC
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM12 auto-reload register
            TIM12_ARR: mmio.Mmio(packed struct(u16) {
                ///  ARR
                ARR: u16,
            }),
            reserved52: [6]u8,
            ///  TIM12 capture/compare register 1
            TIM12_CCR1: mmio.Mmio(packed struct(u16) {
                ///  CCR1
                CCR1: u16,
            }),
            reserved56: [2]u8,
            ///  TIM12 capture/compare register 2
            TIM12_CCR2: mmio.Mmio(packed struct(u16) {
                ///  CCR2
                CCR2: u16,
            }),
            reserved104: [46]u8,
            ///  TIM12 timer input selection register
            TIM12_TISEL: mmio.Mmio(packed struct(u32) {
                ///  TI1SEL
                TI1SEL: u4,
                reserved8: u4,
                ///  TI2SEL
                TI2SEL: u4,
                padding: u20,
            }),
        };

        ///  TIM8
        pub const TIM8 = extern struct {
            ///  TIM8 control register 1
            TIM8_CR1: mmio.Mmio(packed struct(u16) {
                ///  CEN
                CEN: u1,
                ///  UDIS
                UDIS: u1,
                ///  URS
                URS: u1,
                ///  OPM
                OPM: u1,
                ///  DIR
                DIR: u1,
                ///  CMS
                CMS: u2,
                ///  ARPE
                ARPE: u1,
                ///  CKD
                CKD: u2,
                reserved11: u1,
                ///  UIFREMAP
                UIFREMAP: u1,
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM8 control register 2
            TIM8_CR2: mmio.Mmio(packed struct(u32) {
                ///  CCPC
                CCPC: u1,
                reserved2: u1,
                ///  CCUS
                CCUS: u1,
                ///  CCDS
                CCDS: u1,
                ///  MMS
                MMS: u3,
                ///  TI1S
                TI1S: u1,
                ///  OIS1
                OIS1: u1,
                ///  OIS1N
                OIS1N: u1,
                ///  OIS2
                OIS2: u1,
                ///  OIS2N
                OIS2N: u1,
                ///  OIS3
                OIS3: u1,
                ///  OIS3N
                OIS3N: u1,
                ///  OIS4
                OIS4: u1,
                reserved16: u1,
                ///  OIS5
                OIS5: u1,
                reserved18: u1,
                ///  OIS6
                OIS6: u1,
                reserved20: u1,
                ///  MMS2
                MMS2: u4,
                padding: u8,
            }),
            ///  TIM8 slave mode control register
            TIM8_SMCR: mmio.Mmio(packed struct(u32) {
                ///  SMS
                SMS: u3,
                reserved4: u1,
                ///  TS
                TS: u3,
                ///  MSM
                MSM: u1,
                ///  ETF
                ETF: u4,
                ///  ETPS
                ETPS: u2,
                ///  ECE
                ECE: u1,
                ///  ETP
                ETP: u1,
                ///  SMS3
                SMS3: u1,
                reserved20: u3,
                ///  TS3
                TS3: u1,
                ///  TS4
                TS4: u1,
                padding: u10,
            }),
            ///  TIM8 DMA/interrupt enable register
            TIM8_DIER: mmio.Mmio(packed struct(u16) {
                ///  UIE
                UIE: u1,
                ///  CC1IE
                CC1IE: u1,
                ///  CC2IE
                CC2IE: u1,
                ///  CC3IE
                CC3IE: u1,
                ///  CC4IE
                CC4IE: u1,
                ///  COMIE
                COMIE: u1,
                ///  TIE
                TIE: u1,
                ///  BIE
                BIE: u1,
                ///  UDE
                UDE: u1,
                ///  CC1DE
                CC1DE: u1,
                ///  CC2DE
                CC2DE: u1,
                ///  CC3DE
                CC3DE: u1,
                ///  CC4DE
                CC4DE: u1,
                ///  COMDE
                COMDE: u1,
                ///  TDE
                TDE: u1,
                padding: u1,
            }),
            reserved16: [2]u8,
            ///  TIM8 status register
            TIM8_SR: mmio.Mmio(packed struct(u32) {
                ///  UIF
                UIF: u1,
                ///  CC1IF
                CC1IF: u1,
                ///  CC2IF
                CC2IF: u1,
                ///  CC3IF
                CC3IF: u1,
                ///  CC4IF
                CC4IF: u1,
                ///  COMIF
                COMIF: u1,
                ///  TIF
                TIF: u1,
                ///  BIF
                BIF: u1,
                ///  B2IF
                B2IF: u1,
                ///  CC1OF
                CC1OF: u1,
                ///  CC2OF
                CC2OF: u1,
                ///  CC3OF
                CC3OF: u1,
                ///  CC4OF
                CC4OF: u1,
                ///  SBIF
                SBIF: u1,
                reserved16: u2,
                ///  CC5IF
                CC5IF: u1,
                ///  CC6IF
                CC6IF: u1,
                padding: u14,
            }),
            ///  TIM8 event generation register
            TIM8_EGR: mmio.Mmio(packed struct(u16) {
                ///  UG
                UG: u1,
                ///  CC1G
                CC1G: u1,
                ///  CC2G
                CC2G: u1,
                ///  CC3G
                CC3G: u1,
                ///  CC4G
                CC4G: u1,
                ///  COMG
                COMG: u1,
                ///  TG
                TG: u1,
                ///  BG
                BG: u1,
                ///  B2G
                B2G: u1,
                padding: u7,
            }),
            reserved24: [2]u8,
            ///  The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
            TIM8_CCMR1ALTERNATE8: mmio.Mmio(packed struct(u32) {
                ///  CC1S
                CC1S: u2,
                ///  IC1PSC
                IC1PSC: u2,
                ///  IC1F
                IC1F: u4,
                ///  CC2S
                CC2S: u2,
                ///  IC2PSC
                IC2PSC: u2,
                ///  IC2F
                IC2F: u4,
                padding: u16,
            }),
            ///  The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
            TIM8_CCMR2ALTERNATE24: mmio.Mmio(packed struct(u32) {
                ///  CC3S
                CC3S: u2,
                ///  IC3PSC
                IC3PSC: u2,
                ///  IC3F
                IC3F: u4,
                ///  CC4S
                CC4S: u2,
                ///  IC4PSC
                IC4PSC: u2,
                ///  IC4F
                IC4F: u4,
                padding: u16,
            }),
            ///  TIM8 capture/compare enable register
            TIM8_CCER: mmio.Mmio(packed struct(u32) {
                ///  CC1E
                CC1E: u1,
                ///  CC1P
                CC1P: u1,
                ///  CC1NE
                CC1NE: u1,
                ///  CC1NP
                CC1NP: u1,
                ///  CC2E
                CC2E: u1,
                ///  CC2P
                CC2P: u1,
                ///  CC2NE
                CC2NE: u1,
                ///  CC2NP
                CC2NP: u1,
                ///  CC3E
                CC3E: u1,
                ///  CC3P
                CC3P: u1,
                ///  CC3NE
                CC3NE: u1,
                ///  CC3NP
                CC3NP: u1,
                ///  CC4E
                CC4E: u1,
                ///  CC4P
                CC4P: u1,
                reserved15: u1,
                ///  CC4NP
                CC4NP: u1,
                ///  CC5E
                CC5E: u1,
                ///  CC5P
                CC5P: u1,
                reserved20: u2,
                ///  CC6E
                CC6E: u1,
                ///  CC6P
                CC6P: u1,
                padding: u10,
            }),
            ///  TIM8 counter
            TIM8_CNT: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u16,
                reserved31: u15,
                ///  UIFCPY
                UIFCPY: u1,
            }),
            ///  TIM8 prescaler
            TIM8_PSC: mmio.Mmio(packed struct(u16) {
                ///  PSC
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM8 auto-reload register
            TIM8_ARR: mmio.Mmio(packed struct(u16) {
                ///  ARR
                ARR: u16,
            }),
            reserved48: [2]u8,
            ///  TIM8 repetition counter register
            TIM8_RCR: mmio.Mmio(packed struct(u16) {
                ///  REP
                REP: u16,
            }),
            reserved52: [2]u8,
            ///  TIM8 capture/compare register 1
            TIM8_CCR1: mmio.Mmio(packed struct(u16) {
                ///  CCR1
                CCR1: u16,
            }),
            reserved56: [2]u8,
            ///  TIM8 capture/compare register 2
            TIM8_CCR2: mmio.Mmio(packed struct(u16) {
                ///  CCR2
                CCR2: u16,
            }),
            reserved60: [2]u8,
            ///  TIM8 capture/compare register 3
            TIM8_CCR3: mmio.Mmio(packed struct(u16) {
                ///  CCR3
                CCR3: u16,
            }),
            reserved64: [2]u8,
            ///  TIM8 capture/compare register 4
            TIM8_CCR4: mmio.Mmio(packed struct(u16) {
                ///  CCR4
                CCR4: u16,
            }),
            reserved68: [2]u8,
            ///  As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
            TIM8_BDTR: mmio.Mmio(packed struct(u32) {
                ///  DTG
                DTG: u8,
                ///  LOCK
                LOCK: u2,
                ///  OSSI
                OSSI: u1,
                ///  OSSR
                OSSR: u1,
                ///  BKE
                BKE: u1,
                ///  BKP
                BKP: u1,
                ///  AOE
                AOE: u1,
                ///  MOE
                MOE: u1,
                ///  BKF
                BKF: u4,
                ///  BK2F
                BK2F: u4,
                ///  BK2E
                BK2E: u1,
                ///  BK2P
                BK2P: u1,
                ///  BKDSRM
                BKDSRM: u1,
                ///  BK2DSRM
                BK2DSRM: u1,
                ///  BKBID
                BKBID: u1,
                ///  BK2BID
                BK2BID: u1,
                padding: u2,
            }),
            ///  TIM8 DMA control register
            TIM8_DCR: mmio.Mmio(packed struct(u16) {
                ///  DBA
                DBA: u5,
                reserved8: u3,
                ///  DBL
                DBL: u5,
                padding: u3,
            }),
            reserved76: [2]u8,
            ///  TIM8 DMA address for full transfer
            TIM8_DMAR: mmio.Mmio(packed struct(u32) {
                ///  DMAB
                DMAB: u32,
            }),
            reserved84: [4]u8,
            ///  The channels 5 and 6 can only be configured in output. Output compare mode:
            TIM8_CCMR3: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  OC5FE
                OC5FE: u1,
                ///  OC5PE
                OC5PE: u1,
                ///  OC5M
                OC5M: u3,
                ///  OC5CE
                OC5CE: u1,
                reserved10: u2,
                ///  OC6FE
                OC6FE: u1,
                ///  OC6PE
                OC6PE: u1,
                ///  OC6M
                OC6M: u3,
                ///  OC6CE
                OC6CE: u1,
                ///  OC5M3
                OC5M3: u1,
                reserved24: u7,
                ///  OC6M3
                OC6M3: u1,
                padding: u7,
            }),
            ///  TIM8 capture/compare register 5
            TIM8_CCR5: mmio.Mmio(packed struct(u32) {
                ///  CCR5
                CCR5: u16,
                reserved29: u13,
                ///  GC5C1
                GC5C1: u1,
                ///  GC5C2
                GC5C2: u1,
                ///  GC5C3
                GC5C3: u1,
            }),
            ///  TIM8 capture/compare register 6
            TIM8_CCR6: mmio.Mmio(packed struct(u16) {
                ///  CCR6
                CCR6: u16,
            }),
            reserved96: [2]u8,
            ///  TIM8 Alternate function option register 1
            TIM8_AF1: mmio.Mmio(packed struct(u32) {
                ///  BKINE
                BKINE: u1,
                reserved8: u7,
                ///  BKDF1BK2E
                BKDF1BK2E: u1,
                ///  BKINP
                BKINP: u1,
                reserved14: u4,
                ///  ETRSEL
                ETRSEL: u4,
                padding: u14,
            }),
            ///  TIM8 Alternate function option register 2
            TIM8_AF2: mmio.Mmio(packed struct(u32) {
                ///  BK2INE
                BK2INE: u1,
                reserved8: u7,
                ///  BK2DF1BK3E
                BK2DF1BK3E: u1,
                ///  BK2INP
                BK2INP: u1,
                padding: u22,
            }),
            ///  TIM8 timer input selection register
            TIM8_TISEL: mmio.Mmio(packed struct(u32) {
                ///  TI1SEL
                TI1SEL: u4,
                reserved8: u4,
                ///  TI2SEL
                TI2SEL: u4,
                reserved16: u4,
                ///  TI3SEL
                TI3SEL: u4,
                reserved24: u4,
                ///  TI4SEL
                TI4SEL: u4,
                padding: u4,
            }),
        };

        ///  TIM7
        pub const TIM7 = extern struct {
            ///  TIM7 control register 1
            TIM7_CR1: mmio.Mmio(packed struct(u16) {
                ///  CEN
                CEN: u1,
                ///  UDIS
                UDIS: u1,
                ///  URS
                URS: u1,
                ///  OPM
                OPM: u1,
                ///  DIR
                DIR: u1,
                ///  CMS
                CMS: u2,
                ///  ARPE
                ARPE: u1,
                ///  CKD
                CKD: u2,
                reserved11: u1,
                ///  UIFREMAP
                UIFREMAP: u1,
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM7 control register 2
            TIM7_CR2: mmio.Mmio(packed struct(u32) {
                ///  CCPC
                CCPC: u1,
                reserved2: u1,
                ///  CCUS
                CCUS: u1,
                ///  CCDS
                CCDS: u1,
                ///  MMS
                MMS: u3,
                ///  TI1S
                TI1S: u1,
                ///  OIS1
                OIS1: u1,
                ///  OIS1N
                OIS1N: u1,
                ///  OIS2
                OIS2: u1,
                ///  OIS2N
                OIS2N: u1,
                ///  OIS3
                OIS3: u1,
                ///  OIS3N
                OIS3N: u1,
                ///  OIS4
                OIS4: u1,
                reserved16: u1,
                ///  OIS5
                OIS5: u1,
                reserved18: u1,
                ///  OIS6
                OIS6: u1,
                reserved20: u1,
                ///  MMS2
                MMS2: u4,
                padding: u8,
            }),
            ///  TIM7 slave mode control register
            TIM7_SMCR: mmio.Mmio(packed struct(u32) {
                ///  SMS
                SMS: u3,
                reserved4: u1,
                ///  TS
                TS: u3,
                ///  MSM
                MSM: u1,
                ///  ETF
                ETF: u4,
                ///  ETPS
                ETPS: u2,
                ///  ECE
                ECE: u1,
                ///  ETP
                ETP: u1,
                ///  SMS3
                SMS3: u1,
                reserved20: u3,
                ///  TS3
                TS3: u1,
                ///  TS4
                TS4: u1,
                padding: u10,
            }),
            ///  TIM7 DMA/interrupt enable register
            TIM7_DIER: mmio.Mmio(packed struct(u16) {
                ///  UIE
                UIE: u1,
                ///  CC1IE
                CC1IE: u1,
                ///  CC2IE
                CC2IE: u1,
                ///  CC3IE
                CC3IE: u1,
                ///  CC4IE
                CC4IE: u1,
                ///  COMIE
                COMIE: u1,
                ///  TIE
                TIE: u1,
                ///  BIE
                BIE: u1,
                ///  UDE
                UDE: u1,
                ///  CC1DE
                CC1DE: u1,
                ///  CC2DE
                CC2DE: u1,
                ///  CC3DE
                CC3DE: u1,
                ///  CC4DE
                CC4DE: u1,
                ///  COMDE
                COMDE: u1,
                ///  TDE
                TDE: u1,
                padding: u1,
            }),
            reserved16: [2]u8,
            ///  TIM7 status register
            TIM7_SR: mmio.Mmio(packed struct(u32) {
                ///  UIF
                UIF: u1,
                ///  CC1IF
                CC1IF: u1,
                ///  CC2IF
                CC2IF: u1,
                ///  CC3IF
                CC3IF: u1,
                ///  CC4IF
                CC4IF: u1,
                ///  COMIF
                COMIF: u1,
                ///  TIF
                TIF: u1,
                ///  BIF
                BIF: u1,
                ///  B2IF
                B2IF: u1,
                ///  CC1OF
                CC1OF: u1,
                ///  CC2OF
                CC2OF: u1,
                ///  CC3OF
                CC3OF: u1,
                ///  CC4OF
                CC4OF: u1,
                ///  SBIF
                SBIF: u1,
                reserved16: u2,
                ///  CC5IF
                CC5IF: u1,
                ///  CC6IF
                CC6IF: u1,
                padding: u14,
            }),
            ///  TIM7 event generation register
            TIM7_EGR: mmio.Mmio(packed struct(u16) {
                ///  UG
                UG: u1,
                ///  CC1G
                CC1G: u1,
                ///  CC2G
                CC2G: u1,
                ///  CC3G
                CC3G: u1,
                ///  CC4G
                CC4G: u1,
                ///  COMG
                COMG: u1,
                ///  TG
                TG: u1,
                ///  BG
                BG: u1,
                ///  B2G
                B2G: u1,
                padding: u7,
            }),
            reserved24: [2]u8,
            ///  The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
            TIM7_CCMR1ALTERNATE7: mmio.Mmio(packed struct(u32) {
                ///  CC1S
                CC1S: u2,
                ///  IC1PSC
                IC1PSC: u2,
                ///  IC1F
                IC1F: u4,
                ///  CC2S
                CC2S: u2,
                ///  IC2PSC
                IC2PSC: u2,
                ///  IC2F
                IC2F: u4,
                padding: u16,
            }),
            ///  The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
            TIM7_CCMR2ALTERNATE23: mmio.Mmio(packed struct(u32) {
                ///  CC3S
                CC3S: u2,
                ///  IC3PSC
                IC3PSC: u2,
                ///  IC3F
                IC3F: u4,
                ///  CC4S
                CC4S: u2,
                ///  IC4PSC
                IC4PSC: u2,
                ///  IC4F
                IC4F: u4,
                padding: u16,
            }),
            ///  TIM7 capture/compare enable register
            TIM7_CCER: mmio.Mmio(packed struct(u32) {
                ///  CC1E
                CC1E: u1,
                ///  CC1P
                CC1P: u1,
                ///  CC1NE
                CC1NE: u1,
                ///  CC1NP
                CC1NP: u1,
                ///  CC2E
                CC2E: u1,
                ///  CC2P
                CC2P: u1,
                ///  CC2NE
                CC2NE: u1,
                ///  CC2NP
                CC2NP: u1,
                ///  CC3E
                CC3E: u1,
                ///  CC3P
                CC3P: u1,
                ///  CC3NE
                CC3NE: u1,
                ///  CC3NP
                CC3NP: u1,
                ///  CC4E
                CC4E: u1,
                ///  CC4P
                CC4P: u1,
                reserved15: u1,
                ///  CC4NP
                CC4NP: u1,
                ///  CC5E
                CC5E: u1,
                ///  CC5P
                CC5P: u1,
                reserved20: u2,
                ///  CC6E
                CC6E: u1,
                ///  CC6P
                CC6P: u1,
                padding: u10,
            }),
            ///  TIM7 counter
            TIM7_CNT: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u16,
                reserved31: u15,
                ///  UIFCPY
                UIFCPY: u1,
            }),
            ///  TIM7 prescaler
            TIM7_PSC: mmio.Mmio(packed struct(u16) {
                ///  PSC
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM7 auto-reload register
            TIM7_ARR: mmio.Mmio(packed struct(u16) {
                ///  ARR
                ARR: u16,
            }),
            reserved48: [2]u8,
            ///  TIM7 repetition counter register
            TIM7_RCR: mmio.Mmio(packed struct(u16) {
                ///  REP
                REP: u16,
            }),
            reserved52: [2]u8,
            ///  TIM7 capture/compare register 1
            TIM7_CCR1: mmio.Mmio(packed struct(u16) {
                ///  CCR1
                CCR1: u16,
            }),
            reserved56: [2]u8,
            ///  TIM7 capture/compare register 2
            TIM7_CCR2: mmio.Mmio(packed struct(u16) {
                ///  CCR2
                CCR2: u16,
            }),
            reserved60: [2]u8,
            ///  TIM7 capture/compare register 3
            TIM7_CCR3: mmio.Mmio(packed struct(u16) {
                ///  CCR3
                CCR3: u16,
            }),
            reserved64: [2]u8,
            ///  TIM7 capture/compare register 4
            TIM7_CCR4: mmio.Mmio(packed struct(u16) {
                ///  CCR4
                CCR4: u16,
            }),
            reserved68: [2]u8,
            ///  As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
            TIM7_BDTR: mmio.Mmio(packed struct(u32) {
                ///  DTG
                DTG: u8,
                ///  LOCK
                LOCK: u2,
                ///  OSSI
                OSSI: u1,
                ///  OSSR
                OSSR: u1,
                ///  BKE
                BKE: u1,
                ///  BKP
                BKP: u1,
                ///  AOE
                AOE: u1,
                ///  MOE
                MOE: u1,
                ///  BKF
                BKF: u4,
                ///  BK2F
                BK2F: u4,
                ///  BK2E
                BK2E: u1,
                ///  BK2P
                BK2P: u1,
                ///  BKDSRM
                BKDSRM: u1,
                ///  BK2DSRM
                BK2DSRM: u1,
                ///  BKBID
                BKBID: u1,
                ///  BK2BID
                BK2BID: u1,
                padding: u2,
            }),
            ///  TIM7 DMA control register
            TIM7_DCR: mmio.Mmio(packed struct(u16) {
                ///  DBA
                DBA: u5,
                reserved8: u3,
                ///  DBL
                DBL: u5,
                padding: u3,
            }),
            reserved76: [2]u8,
            ///  TIM7 DMA address for full transfer
            TIM7_DMAR: mmio.Mmio(packed struct(u32) {
                ///  DMAB
                DMAB: u32,
            }),
            reserved84: [4]u8,
            ///  The channels 5 and 6 can only be configured in output. Output compare mode:
            TIM7_CCMR3: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  OC5FE
                OC5FE: u1,
                ///  OC5PE
                OC5PE: u1,
                ///  OC5M
                OC5M: u3,
                ///  OC5CE
                OC5CE: u1,
                reserved10: u2,
                ///  OC6FE
                OC6FE: u1,
                ///  OC6PE
                OC6PE: u1,
                ///  OC6M
                OC6M: u3,
                ///  OC6CE
                OC6CE: u1,
                ///  OC5M3
                OC5M3: u1,
                reserved24: u7,
                ///  OC6M3
                OC6M3: u1,
                padding: u7,
            }),
            ///  TIM7 capture/compare register 5
            TIM7_CCR5: mmio.Mmio(packed struct(u32) {
                ///  CCR5
                CCR5: u16,
                reserved29: u13,
                ///  GC5C1
                GC5C1: u1,
                ///  GC5C2
                GC5C2: u1,
                ///  GC5C3
                GC5C3: u1,
            }),
            ///  TIM7 capture/compare register 6
            TIM7_CCR6: mmio.Mmio(packed struct(u16) {
                ///  CCR6
                CCR6: u16,
            }),
        };

        ///  SDMMC1
        pub const SDMMC1 = extern struct {
            ///  SDMMC power control register
            SDMMC_POWER: mmio.Mmio(packed struct(u32) {
                ///  PWRCTRL
                PWRCTRL: u2,
                ///  VSWITCH
                VSWITCH: u1,
                ///  VSWITCHEN
                VSWITCHEN: u1,
                ///  DIRPOL
                DIRPOL: u1,
                padding: u27,
            }),
            ///  The SDMMC_CLKCR register controls the SDMMC_CK output clock, the sdmmc_rx_ck receive clock, and the bus width.
            SDMMC_CLKCR: mmio.Mmio(packed struct(u32) {
                ///  CLKDIV
                CLKDIV: u10,
                reserved12: u2,
                ///  PWRSAV
                PWRSAV: u1,
                reserved14: u1,
                ///  WIDBUS
                WIDBUS: u2,
                ///  NEGEDGE
                NEGEDGE: u1,
                ///  HWFC_EN
                HWFC_EN: u1,
                ///  DDR
                DDR: u1,
                ///  BUSSPEED
                BUSSPEED: u1,
                ///  SELCLKRX
                SELCLKRX: u2,
                padding: u10,
            }),
            ///  The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message.
            SDMMC_ARGR: mmio.Mmio(packed struct(u32) {
                ///  CMDARG
                CMDARG: u32,
            }),
            ///  The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM).
            SDMMC_CMDR: mmio.Mmio(packed struct(u32) {
                ///  CMDINDEX
                CMDINDEX: u6,
                ///  CMDTRANS
                CMDTRANS: u1,
                ///  CMDSTOP
                CMDSTOP: u1,
                ///  WAITRESP
                WAITRESP: u2,
                ///  WAITINT
                WAITINT: u1,
                ///  WAITPEND
                WAITPEND: u1,
                ///  CPSMEN
                CPSMEN: u1,
                ///  DTHOLD
                DTHOLD: u1,
                ///  BOOTMODE
                BOOTMODE: u1,
                ///  BOOTEN
                BOOTEN: u1,
                ///  CMDSUSPEND
                CMDSUSPEND: u1,
                padding: u15,
            }),
            ///  The SDMMC_RESPCMDR register contains the command index field of the last command response received. If the command response transmission does not contain the command index field (long or OCR response), the RESPCMD field is unknown, although it must contain 111111b (the value of the reserved field from the response).
            SDMMC_RESPCMDR: mmio.Mmio(packed struct(u32) {
                ///  RESPCMD
                RESPCMD: u6,
                padding: u26,
            }),
            ///  The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
            SDMMC_RESP1R: mmio.Mmio(packed struct(u32) {
                ///  CARDSTATUS1
                CARDSTATUS1: u32,
            }),
            ///  The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
            SDMMC_RESP2R: mmio.Mmio(packed struct(u32) {
                ///  CARDSTATUS2
                CARDSTATUS2: u32,
            }),
            ///  The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
            SDMMC_RESP3R: mmio.Mmio(packed struct(u32) {
                ///  CARDSTATUS3
                CARDSTATUS3: u32,
            }),
            ///  The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
            SDMMC_RESP4R: mmio.Mmio(packed struct(u32) {
                ///  CARDSTATUS4
                CARDSTATUS4: u32,
            }),
            ///  The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_R or Busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set.
            SDMMC_DTIMER: mmio.Mmio(packed struct(u32) {
                ///  DATATIME
                DATATIME: u32,
            }),
            ///  The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts.
            SDMMC_DLENR: mmio.Mmio(packed struct(u32) {
                ///  DATALENGTH
                DATALENGTH: u25,
                padding: u7,
            }),
            ///  The SDMMC_DCTRL register control the data path state machine (DPSM).
            SDMMC_DCTRL: mmio.Mmio(packed struct(u32) {
                ///  DTEN
                DTEN: u1,
                ///  DTDIR
                DTDIR: u1,
                ///  DTMODE
                DTMODE: u2,
                ///  DBLOCKSIZE
                DBLOCKSIZE: u4,
                ///  RWSTART
                RWSTART: u1,
                ///  RWSTOP
                RWSTOP: u1,
                ///  RWMOD
                RWMOD: u1,
                ///  SDIOEN
                SDIOEN: u1,
                ///  BOOTACKEN
                BOOTACKEN: u1,
                ///  FIFORST
                FIFORST: u1,
                padding: u18,
            }),
            ///  The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the Idle state and when there has been no error, the data status end flag (DATAEND) is set.
            SDMMC_DCNTR: mmio.Mmio(packed struct(u32) {
                ///  DATACOUNT
                DATACOUNT: u25,
                padding: u7,
            }),
            ///  The SDMMC_STAR register is a read-only register. It contains two types of flag: Static flags (bits [28, 21, 11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt Clear register (see SDMMC_ICR) Dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO)
            SDMMC_STAR: mmio.Mmio(packed struct(u32) {
                ///  CCRCFAIL
                CCRCFAIL: u1,
                ///  DCRCFAIL
                DCRCFAIL: u1,
                ///  CTIMEOUT
                CTIMEOUT: u1,
                ///  DTIMEOUT
                DTIMEOUT: u1,
                ///  TXUNDERR
                TXUNDERR: u1,
                ///  RXOVERR
                RXOVERR: u1,
                ///  CMDREND
                CMDREND: u1,
                ///  CMDSENT
                CMDSENT: u1,
                ///  DATAEND
                DATAEND: u1,
                ///  DHOLD
                DHOLD: u1,
                ///  DBCKEND
                DBCKEND: u1,
                ///  DABORT
                DABORT: u1,
                ///  DPSMACT
                DPSMACT: u1,
                ///  CPSMACT
                CPSMACT: u1,
                ///  TXFIFOHE
                TXFIFOHE: u1,
                ///  RXFIFOHF
                RXFIFOHF: u1,
                ///  TXFIFOF
                TXFIFOF: u1,
                ///  RXFIFOF
                RXFIFOF: u1,
                ///  TXFIFOE
                TXFIFOE: u1,
                ///  RXFIFOE
                RXFIFOE: u1,
                ///  BUSYD0
                BUSYD0: u1,
                ///  BUSYD0END
                BUSYD0END: u1,
                ///  SDIOIT
                SDIOIT: u1,
                ///  ACKFAIL
                ACKFAIL: u1,
                ///  ACKTIMEOUT
                ACKTIMEOUT: u1,
                ///  VSWEND
                VSWEND: u1,
                ///  CKSTOP
                CKSTOP: u1,
                ///  IDMATE
                IDMATE: u1,
                ///  IDMABTC
                IDMABTC: u1,
                padding: u3,
            }),
            ///  The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register.
            SDMMC_ICR: mmio.Mmio(packed struct(u32) {
                ///  CCRCFAILC
                CCRCFAILC: u1,
                ///  DCRCFAILC
                DCRCFAILC: u1,
                ///  CTIMEOUTC
                CTIMEOUTC: u1,
                ///  DTIMEOUTC
                DTIMEOUTC: u1,
                ///  TXUNDERRC
                TXUNDERRC: u1,
                ///  RXOVERRC
                RXOVERRC: u1,
                ///  CMDRENDC
                CMDRENDC: u1,
                ///  CMDSENTC
                CMDSENTC: u1,
                ///  DATAENDC
                DATAENDC: u1,
                ///  DHOLDC
                DHOLDC: u1,
                ///  DBCKENDC
                DBCKENDC: u1,
                ///  DABORTC
                DABORTC: u1,
                reserved21: u9,
                ///  BUSYD0ENDC
                BUSYD0ENDC: u1,
                ///  SDIOITC
                SDIOITC: u1,
                ///  ACKFAILC
                ACKFAILC: u1,
                ///  ACKTIMEOUTC
                ACKTIMEOUTC: u1,
                ///  VSWENDC
                VSWENDC: u1,
                ///  CKSTOPC
                CKSTOPC: u1,
                ///  IDMATEC
                IDMATEC: u1,
                ///  IDMABTCC
                IDMABTCC: u1,
                padding: u3,
            }),
            ///  The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
            SDMMC_MASKR: mmio.Mmio(packed struct(u32) {
                ///  CCRCFAILIE
                CCRCFAILIE: u1,
                ///  DCRCFAILIE
                DCRCFAILIE: u1,
                ///  CTIMEOUTIE
                CTIMEOUTIE: u1,
                ///  DTIMEOUTIE
                DTIMEOUTIE: u1,
                ///  TXUNDERRIE
                TXUNDERRIE: u1,
                ///  RXOVERRIE
                RXOVERRIE: u1,
                ///  CMDRENDIE
                CMDRENDIE: u1,
                ///  CMDSENTIE
                CMDSENTIE: u1,
                ///  DATAENDIE
                DATAENDIE: u1,
                ///  DHOLDIE
                DHOLDIE: u1,
                ///  DBCKENDIE
                DBCKENDIE: u1,
                ///  DABORTIE
                DABORTIE: u1,
                reserved14: u2,
                ///  TXFIFOHEIE
                TXFIFOHEIE: u1,
                ///  RXFIFOHFIE
                RXFIFOHFIE: u1,
                reserved17: u1,
                ///  RXFIFOFIE
                RXFIFOFIE: u1,
                ///  TXFIFOEIE
                TXFIFOEIE: u1,
                reserved21: u2,
                ///  BUSYD0ENDIE
                BUSYD0ENDIE: u1,
                ///  SDIOITIE
                SDIOITIE: u1,
                ///  ACKFAILIE
                ACKFAILIE: u1,
                ///  ACKTIMEOUTIE
                ACKTIMEOUTIE: u1,
                ///  VSWENDIE
                VSWENDIE: u1,
                ///  CKSTOPIE
                CKSTOPIE: u1,
                reserved28: u1,
                ///  IDMABTCIE
                IDMABTCIE: u1,
                padding: u3,
            }),
            ///  The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_Ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set.
            SDMMC_ACKTIMER: mmio.Mmio(packed struct(u32) {
                ///  ACKTIME
                ACKTIME: u25,
                padding: u7,
            }),
            reserved80: [12]u8,
            ///  The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.
            SDMMC_IDMACTRLR: mmio.Mmio(packed struct(u32) {
                ///  IDMAEN
                IDMAEN: u1,
                ///  IDMABMODE
                IDMABMODE: u1,
                padding: u30,
            }),
            ///  The SDMMC_IDMABSIZER register contains the buffer size when in linked list configuration.
            SDMMC_IDMABSIZER: mmio.Mmio(packed struct(u32) {
                reserved5: u5,
                ///  IDMABNDT
                IDMABNDT: u12,
                padding: u15,
            }),
            ///  The SDMMC_IDMABASER register contains the memory buffer base address in single buffer configuration and linked list configuration.
            SDMMC_IDMABASER: mmio.Mmio(packed struct(u32) {
                ///  IDMABASE
                IDMABASE: u32,
            }),
            reserved100: [8]u8,
            ///  SDMMC IDMA linked list address register
            SDMMC_IDMALAR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  IDMALA
                IDMALA: u14,
                reserved29: u13,
                ///  ABR
                ABR: u1,
                ///  ULS
                ULS: u1,
                ///  ULA
                ULA: u1,
            }),
            ///  SDMMC IDMA linked list memory base register
            SDMMC_IDMABAR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  IDMABA
                IDMABA: u30,
            }),
            reserved128: [20]u8,
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            SDMMC_FIFOR0: mmio.Mmio(packed struct(u32) {
                ///  FIFODATA
                FIFODATA: u32,
            }),
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            SDMMC_FIFOR1: mmio.Mmio(packed struct(u32) {
                ///  FIFODATA
                FIFODATA: u32,
            }),
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            SDMMC_FIFOR2: mmio.Mmio(packed struct(u32) {
                ///  FIFODATA
                FIFODATA: u32,
            }),
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            SDMMC_FIFOR3: mmio.Mmio(packed struct(u32) {
                ///  FIFODATA
                FIFODATA: u32,
            }),
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            SDMMC_FIFOR4: mmio.Mmio(packed struct(u32) {
                ///  FIFODATA
                FIFODATA: u32,
            }),
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            SDMMC_FIFOR5: mmio.Mmio(packed struct(u32) {
                ///  FIFODATA
                FIFODATA: u32,
            }),
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            SDMMC_FIFOR6: mmio.Mmio(packed struct(u32) {
                ///  FIFODATA
                FIFODATA: u32,
            }),
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            SDMMC_FIFOR7: mmio.Mmio(packed struct(u32) {
                ///  FIFODATA
                FIFODATA: u32,
            }),
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            SDMMC_FIFOR8: mmio.Mmio(packed struct(u32) {
                ///  FIFODATA
                FIFODATA: u32,
            }),
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            SDMMC_FIFOR9: mmio.Mmio(packed struct(u32) {
                ///  FIFODATA
                FIFODATA: u32,
            }),
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            SDMMC_FIFOR10: mmio.Mmio(packed struct(u32) {
                ///  FIFODATA
                FIFODATA: u32,
            }),
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            SDMMC_FIFOR11: mmio.Mmio(packed struct(u32) {
                ///  FIFODATA
                FIFODATA: u32,
            }),
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            SDMMC_FIFOR12: mmio.Mmio(packed struct(u32) {
                ///  FIFODATA
                FIFODATA: u32,
            }),
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            SDMMC_FIFOR13: mmio.Mmio(packed struct(u32) {
                ///  FIFODATA
                FIFODATA: u32,
            }),
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            SDMMC_FIFOR14: mmio.Mmio(packed struct(u32) {
                ///  FIFODATA
                FIFODATA: u32,
            }),
            ///  The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. The FIFO register interface takes care of correct data alignment inside the FIFO, the FIFO register address used by the CPU does matter. When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
            SDMMC_FIFOR15: mmio.Mmio(packed struct(u32) {
                ///  FIFODATA
                FIFODATA: u32,
            }),
            reserved1012: [820]u8,
            ///  SDMMC version register
            SDMMC_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  SDMMC identification register
            SDMMC_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  IP_ID
                IP_ID: u32,
            }),
            ///  SDMMC size ID register
            SDMMC_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  TIM6
        pub const TIM6 = extern struct {
            ///  TIM6 control register 1
            TIM6_CR1: mmio.Mmio(packed struct(u16) {
                ///  CEN
                CEN: u1,
                ///  UDIS
                UDIS: u1,
                ///  URS
                URS: u1,
                ///  OPM
                OPM: u1,
                ///  DIR
                DIR: u1,
                ///  CMS
                CMS: u2,
                ///  ARPE
                ARPE: u1,
                ///  CKD
                CKD: u2,
                reserved11: u1,
                ///  UIFREMAP
                UIFREMAP: u1,
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM6 control register 2
            TIM6_CR2: mmio.Mmio(packed struct(u32) {
                ///  CCPC
                CCPC: u1,
                reserved2: u1,
                ///  CCUS
                CCUS: u1,
                ///  CCDS
                CCDS: u1,
                ///  MMS
                MMS: u3,
                ///  TI1S
                TI1S: u1,
                ///  OIS1
                OIS1: u1,
                ///  OIS1N
                OIS1N: u1,
                ///  OIS2
                OIS2: u1,
                ///  OIS2N
                OIS2N: u1,
                ///  OIS3
                OIS3: u1,
                ///  OIS3N
                OIS3N: u1,
                ///  OIS4
                OIS4: u1,
                reserved16: u1,
                ///  OIS5
                OIS5: u1,
                reserved18: u1,
                ///  OIS6
                OIS6: u1,
                reserved20: u1,
                ///  MMS2
                MMS2: u4,
                padding: u8,
            }),
            ///  TIM6 slave mode control register
            TIM6_SMCR: mmio.Mmio(packed struct(u32) {
                ///  SMS
                SMS: u3,
                reserved4: u1,
                ///  TS
                TS: u3,
                ///  MSM
                MSM: u1,
                ///  ETF
                ETF: u4,
                ///  ETPS
                ETPS: u2,
                ///  ECE
                ECE: u1,
                ///  ETP
                ETP: u1,
                ///  SMS3
                SMS3: u1,
                reserved20: u3,
                ///  TS3
                TS3: u1,
                ///  TS4
                TS4: u1,
                padding: u10,
            }),
            ///  TIM6 DMA/interrupt enable register
            TIM6_DIER: mmio.Mmio(packed struct(u16) {
                ///  UIE
                UIE: u1,
                ///  CC1IE
                CC1IE: u1,
                ///  CC2IE
                CC2IE: u1,
                ///  CC3IE
                CC3IE: u1,
                ///  CC4IE
                CC4IE: u1,
                ///  COMIE
                COMIE: u1,
                ///  TIE
                TIE: u1,
                ///  BIE
                BIE: u1,
                ///  UDE
                UDE: u1,
                ///  CC1DE
                CC1DE: u1,
                ///  CC2DE
                CC2DE: u1,
                ///  CC3DE
                CC3DE: u1,
                ///  CC4DE
                CC4DE: u1,
                ///  COMDE
                COMDE: u1,
                ///  TDE
                TDE: u1,
                padding: u1,
            }),
            reserved16: [2]u8,
            ///  TIM6 status register
            TIM6_SR: mmio.Mmio(packed struct(u32) {
                ///  UIF
                UIF: u1,
                ///  CC1IF
                CC1IF: u1,
                ///  CC2IF
                CC2IF: u1,
                ///  CC3IF
                CC3IF: u1,
                ///  CC4IF
                CC4IF: u1,
                ///  COMIF
                COMIF: u1,
                ///  TIF
                TIF: u1,
                ///  BIF
                BIF: u1,
                ///  B2IF
                B2IF: u1,
                ///  CC1OF
                CC1OF: u1,
                ///  CC2OF
                CC2OF: u1,
                ///  CC3OF
                CC3OF: u1,
                ///  CC4OF
                CC4OF: u1,
                ///  SBIF
                SBIF: u1,
                reserved16: u2,
                ///  CC5IF
                CC5IF: u1,
                ///  CC6IF
                CC6IF: u1,
                padding: u14,
            }),
            ///  TIM6 event generation register
            TIM6_EGR: mmio.Mmio(packed struct(u16) {
                ///  UG
                UG: u1,
                ///  CC1G
                CC1G: u1,
                ///  CC2G
                CC2G: u1,
                ///  CC3G
                CC3G: u1,
                ///  CC4G
                CC4G: u1,
                ///  COMG
                COMG: u1,
                ///  TG
                TG: u1,
                ///  BG
                BG: u1,
                ///  B2G
                B2G: u1,
                padding: u7,
            }),
            reserved24: [2]u8,
            ///  The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
            TIM6_CCMR1ALTERNATE6: mmio.Mmio(packed struct(u32) {
                ///  CC1S
                CC1S: u2,
                ///  IC1PSC
                IC1PSC: u2,
                ///  IC1F
                IC1F: u4,
                ///  CC2S
                CC2S: u2,
                ///  IC2PSC
                IC2PSC: u2,
                ///  IC2F
                IC2F: u4,
                padding: u16,
            }),
            ///  The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
            TIM6_CCMR2ALTERNATE22: mmio.Mmio(packed struct(u32) {
                ///  CC3S
                CC3S: u2,
                ///  IC3PSC
                IC3PSC: u2,
                ///  IC3F
                IC3F: u4,
                ///  CC4S
                CC4S: u2,
                ///  IC4PSC
                IC4PSC: u2,
                ///  IC4F
                IC4F: u4,
                padding: u16,
            }),
            ///  TIM6 capture/compare enable register
            TIM6_CCER: mmio.Mmio(packed struct(u32) {
                ///  CC1E
                CC1E: u1,
                ///  CC1P
                CC1P: u1,
                ///  CC1NE
                CC1NE: u1,
                ///  CC1NP
                CC1NP: u1,
                ///  CC2E
                CC2E: u1,
                ///  CC2P
                CC2P: u1,
                ///  CC2NE
                CC2NE: u1,
                ///  CC2NP
                CC2NP: u1,
                ///  CC3E
                CC3E: u1,
                ///  CC3P
                CC3P: u1,
                ///  CC3NE
                CC3NE: u1,
                ///  CC3NP
                CC3NP: u1,
                ///  CC4E
                CC4E: u1,
                ///  CC4P
                CC4P: u1,
                reserved15: u1,
                ///  CC4NP
                CC4NP: u1,
                ///  CC5E
                CC5E: u1,
                ///  CC5P
                CC5P: u1,
                reserved20: u2,
                ///  CC6E
                CC6E: u1,
                ///  CC6P
                CC6P: u1,
                padding: u10,
            }),
            ///  TIM6 counter
            TIM6_CNT: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u16,
                reserved31: u15,
                ///  UIFCPY
                UIFCPY: u1,
            }),
            ///  TIM6 prescaler
            TIM6_PSC: mmio.Mmio(packed struct(u16) {
                ///  PSC
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM6 auto-reload register
            TIM6_ARR: mmio.Mmio(packed struct(u16) {
                ///  ARR
                ARR: u16,
            }),
            reserved48: [2]u8,
            ///  TIM6 repetition counter register
            TIM6_RCR: mmio.Mmio(packed struct(u16) {
                ///  REP
                REP: u16,
            }),
            reserved52: [2]u8,
            ///  TIM6 capture/compare register 1
            TIM6_CCR1: mmio.Mmio(packed struct(u16) {
                ///  CCR1
                CCR1: u16,
            }),
            reserved56: [2]u8,
            ///  TIM6 capture/compare register 2
            TIM6_CCR2: mmio.Mmio(packed struct(u16) {
                ///  CCR2
                CCR2: u16,
            }),
            reserved60: [2]u8,
            ///  TIM6 capture/compare register 3
            TIM6_CCR3: mmio.Mmio(packed struct(u16) {
                ///  CCR3
                CCR3: u16,
            }),
            reserved64: [2]u8,
            ///  TIM6 capture/compare register 4
            TIM6_CCR4: mmio.Mmio(packed struct(u16) {
                ///  CCR4
                CCR4: u16,
            }),
            reserved68: [2]u8,
            ///  As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
            TIM6_BDTR: mmio.Mmio(packed struct(u32) {
                ///  DTG
                DTG: u8,
                ///  LOCK
                LOCK: u2,
                ///  OSSI
                OSSI: u1,
                ///  OSSR
                OSSR: u1,
                ///  BKE
                BKE: u1,
                ///  BKP
                BKP: u1,
                ///  AOE
                AOE: u1,
                ///  MOE
                MOE: u1,
                ///  BKF
                BKF: u4,
                ///  BK2F
                BK2F: u4,
                ///  BK2E
                BK2E: u1,
                ///  BK2P
                BK2P: u1,
                ///  BKDSRM
                BKDSRM: u1,
                ///  BK2DSRM
                BK2DSRM: u1,
                ///  BKBID
                BKBID: u1,
                ///  BK2BID
                BK2BID: u1,
                padding: u2,
            }),
            ///  TIM6 DMA control register
            TIM6_DCR: mmio.Mmio(packed struct(u16) {
                ///  DBA
                DBA: u5,
                reserved8: u3,
                ///  DBL
                DBL: u5,
                padding: u3,
            }),
            reserved76: [2]u8,
            ///  TIM6 DMA address for full transfer
            TIM6_DMAR: mmio.Mmio(packed struct(u32) {
                ///  DMAB
                DMAB: u32,
            }),
            reserved84: [4]u8,
            ///  The channels 5 and 6 can only be configured in output. Output compare mode:
            TIM6_CCMR3: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  OC5FE
                OC5FE: u1,
                ///  OC5PE
                OC5PE: u1,
                ///  OC5M
                OC5M: u3,
                ///  OC5CE
                OC5CE: u1,
                reserved10: u2,
                ///  OC6FE
                OC6FE: u1,
                ///  OC6PE
                OC6PE: u1,
                ///  OC6M
                OC6M: u3,
                ///  OC6CE
                OC6CE: u1,
                ///  OC5M3
                OC5M3: u1,
                reserved24: u7,
                ///  OC6M3
                OC6M3: u1,
                padding: u7,
            }),
            ///  TIM6 capture/compare register 5
            TIM6_CCR5: mmio.Mmio(packed struct(u32) {
                ///  CCR5
                CCR5: u16,
                reserved29: u13,
                ///  GC5C1
                GC5C1: u1,
                ///  GC5C2
                GC5C2: u1,
                ///  GC5C3
                GC5C3: u1,
            }),
            ///  TIM6 capture/compare register 6
            TIM6_CCR6: mmio.Mmio(packed struct(u16) {
                ///  CCR6
                CCR6: u16,
            }),
        };

        ///  TIM5
        pub const TIM5 = extern struct {
            ///  TIM5 control register 1
            TIM5_CR1: mmio.Mmio(packed struct(u16) {
                ///  CEN
                CEN: u1,
                ///  UDIS
                UDIS: u1,
                ///  URS
                URS: u1,
                ///  OPM
                OPM: u1,
                ///  DIR
                DIR: u1,
                ///  CMS
                CMS: u2,
                ///  ARPE
                ARPE: u1,
                ///  CKD
                CKD: u2,
                reserved11: u1,
                ///  UIFREMAP
                UIFREMAP: u1,
                padding: u4,
            }),
            reserved4: [2]u8,
            ///  TIM5 control register 2
            TIM5_CR2: mmio.Mmio(packed struct(u32) {
                ///  CCPC
                CCPC: u1,
                reserved2: u1,
                ///  CCUS
                CCUS: u1,
                ///  CCDS
                CCDS: u1,
                ///  MMS
                MMS: u3,
                ///  TI1S
                TI1S: u1,
                ///  OIS1
                OIS1: u1,
                ///  OIS1N
                OIS1N: u1,
                ///  OIS2
                OIS2: u1,
                ///  OIS2N
                OIS2N: u1,
                ///  OIS3
                OIS3: u1,
                ///  OIS3N
                OIS3N: u1,
                ///  OIS4
                OIS4: u1,
                reserved16: u1,
                ///  OIS5
                OIS5: u1,
                reserved18: u1,
                ///  OIS6
                OIS6: u1,
                reserved20: u1,
                ///  MMS2
                MMS2: u4,
                padding: u8,
            }),
            ///  TIM5 slave mode control register
            TIM5_SMCR: mmio.Mmio(packed struct(u32) {
                ///  SMS
                SMS: u3,
                reserved4: u1,
                ///  TS
                TS: u3,
                ///  MSM
                MSM: u1,
                ///  ETF
                ETF: u4,
                ///  ETPS
                ETPS: u2,
                ///  ECE
                ECE: u1,
                ///  ETP
                ETP: u1,
                ///  SMS3
                SMS3: u1,
                reserved20: u3,
                ///  TS3
                TS3: u1,
                ///  TS4
                TS4: u1,
                padding: u10,
            }),
            ///  TIM5 DMA/interrupt enable register
            TIM5_DIER: mmio.Mmio(packed struct(u16) {
                ///  UIE
                UIE: u1,
                ///  CC1IE
                CC1IE: u1,
                ///  CC2IE
                CC2IE: u1,
                ///  CC3IE
                CC3IE: u1,
                ///  CC4IE
                CC4IE: u1,
                ///  COMIE
                COMIE: u1,
                ///  TIE
                TIE: u1,
                ///  BIE
                BIE: u1,
                ///  UDE
                UDE: u1,
                ///  CC1DE
                CC1DE: u1,
                ///  CC2DE
                CC2DE: u1,
                ///  CC3DE
                CC3DE: u1,
                ///  CC4DE
                CC4DE: u1,
                ///  COMDE
                COMDE: u1,
                ///  TDE
                TDE: u1,
                padding: u1,
            }),
            reserved16: [2]u8,
            ///  TIM5 status register
            TIM5_SR: mmio.Mmio(packed struct(u32) {
                ///  UIF
                UIF: u1,
                ///  CC1IF
                CC1IF: u1,
                ///  CC2IF
                CC2IF: u1,
                ///  CC3IF
                CC3IF: u1,
                ///  CC4IF
                CC4IF: u1,
                ///  COMIF
                COMIF: u1,
                ///  TIF
                TIF: u1,
                ///  BIF
                BIF: u1,
                ///  B2IF
                B2IF: u1,
                ///  CC1OF
                CC1OF: u1,
                ///  CC2OF
                CC2OF: u1,
                ///  CC3OF
                CC3OF: u1,
                ///  CC4OF
                CC4OF: u1,
                ///  SBIF
                SBIF: u1,
                reserved16: u2,
                ///  CC5IF
                CC5IF: u1,
                ///  CC6IF
                CC6IF: u1,
                padding: u14,
            }),
            ///  TIM5 event generation register
            TIM5_EGR: mmio.Mmio(packed struct(u16) {
                ///  UG
                UG: u1,
                ///  CC1G
                CC1G: u1,
                ///  CC2G
                CC2G: u1,
                ///  CC3G
                CC3G: u1,
                ///  CC4G
                CC4G: u1,
                ///  COMG
                COMG: u1,
                ///  TG
                TG: u1,
                ///  BG
                BG: u1,
                ///  B2G
                B2G: u1,
                padding: u7,
            }),
            reserved24: [2]u8,
            ///  The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
            TIM5_CCMR1ALTERNATE5: mmio.Mmio(packed struct(u32) {
                ///  CC1S
                CC1S: u2,
                ///  IC1PSC
                IC1PSC: u2,
                ///  IC1F
                IC1F: u4,
                ///  CC2S
                CC2S: u2,
                ///  IC2PSC
                IC2PSC: u2,
                ///  IC2F
                IC2F: u4,
                padding: u16,
            }),
            ///  The same register can be used for input capture mode (this section) or for output compare mode (next section). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function for input capture and for output compare modes. It is possible to combine both modes independently (e.g. channel 1 in input capture mode and channel 2 in output compare mode). Input capture mode:
            TIM5_CCMR2ALTERNATE21: mmio.Mmio(packed struct(u32) {
                ///  CC3S
                CC3S: u2,
                ///  IC3PSC
                IC3PSC: u2,
                ///  IC3F
                IC3F: u4,
                ///  CC4S
                CC4S: u2,
                ///  IC4PSC
                IC4PSC: u2,
                ///  IC4F
                IC4F: u4,
                padding: u16,
            }),
            ///  TIM5 capture/compare enable register
            TIM5_CCER: mmio.Mmio(packed struct(u32) {
                ///  CC1E
                CC1E: u1,
                ///  CC1P
                CC1P: u1,
                ///  CC1NE
                CC1NE: u1,
                ///  CC1NP
                CC1NP: u1,
                ///  CC2E
                CC2E: u1,
                ///  CC2P
                CC2P: u1,
                ///  CC2NE
                CC2NE: u1,
                ///  CC2NP
                CC2NP: u1,
                ///  CC3E
                CC3E: u1,
                ///  CC3P
                CC3P: u1,
                ///  CC3NE
                CC3NE: u1,
                ///  CC3NP
                CC3NP: u1,
                ///  CC4E
                CC4E: u1,
                ///  CC4P
                CC4P: u1,
                reserved15: u1,
                ///  CC4NP
                CC4NP: u1,
                ///  CC5E
                CC5E: u1,
                ///  CC5P
                CC5P: u1,
                reserved20: u2,
                ///  CC6E
                CC6E: u1,
                ///  CC6P
                CC6P: u1,
                padding: u10,
            }),
            ///  TIM5 counter
            TIM5_CNT: mmio.Mmio(packed struct(u32) {
                ///  CNT
                CNT: u16,
                reserved31: u15,
                ///  UIFCPY
                UIFCPY: u1,
            }),
            ///  TIM5 prescaler
            TIM5_PSC: mmio.Mmio(packed struct(u16) {
                ///  PSC
                PSC: u16,
            }),
            reserved44: [2]u8,
            ///  TIM5 auto-reload register
            TIM5_ARR: mmio.Mmio(packed struct(u16) {
                ///  ARR
                ARR: u16,
            }),
            reserved48: [2]u8,
            ///  TIM5 repetition counter register
            TIM5_RCR: mmio.Mmio(packed struct(u16) {
                ///  REP
                REP: u16,
            }),
            reserved52: [2]u8,
            ///  TIM5 capture/compare register 1
            TIM5_CCR1: mmio.Mmio(packed struct(u16) {
                ///  CCR1
                CCR1: u16,
            }),
            reserved56: [2]u8,
            ///  TIM5 capture/compare register 2
            TIM5_CCR2: mmio.Mmio(packed struct(u16) {
                ///  CCR2
                CCR2: u16,
            }),
            reserved60: [2]u8,
            ///  TIM5 capture/compare register 3
            TIM5_CCR3: mmio.Mmio(packed struct(u16) {
                ///  CCR3
                CCR3: u16,
            }),
            reserved64: [2]u8,
            ///  TIM5 capture/compare register 4
            TIM5_CCR4: mmio.Mmio(packed struct(u16) {
                ///  CCR4
                CCR4: u16,
            }),
            reserved68: [2]u8,
            ///  As the bits BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.
            TIM5_BDTR: mmio.Mmio(packed struct(u32) {
                ///  DTG
                DTG: u8,
                ///  LOCK
                LOCK: u2,
                ///  OSSI
                OSSI: u1,
                ///  OSSR
                OSSR: u1,
                ///  BKE
                BKE: u1,
                ///  BKP
                BKP: u1,
                ///  AOE
                AOE: u1,
                ///  MOE
                MOE: u1,
                ///  BKF
                BKF: u4,
                ///  BK2F
                BK2F: u4,
                ///  BK2E
                BK2E: u1,
                ///  BK2P
                BK2P: u1,
                ///  BKDSRM
                BKDSRM: u1,
                ///  BK2DSRM
                BK2DSRM: u1,
                ///  BKBID
                BKBID: u1,
                ///  BK2BID
                BK2BID: u1,
                padding: u2,
            }),
            ///  TIM5 DMA control register
            TIM5_DCR: mmio.Mmio(packed struct(u16) {
                ///  DBA
                DBA: u5,
                reserved8: u3,
                ///  DBL
                DBL: u5,
                padding: u3,
            }),
            reserved76: [2]u8,
            ///  TIM5 DMA address for full transfer
            TIM5_DMAR: mmio.Mmio(packed struct(u32) {
                ///  DMAB
                DMAB: u32,
            }),
            reserved84: [4]u8,
            ///  The channels 5 and 6 can only be configured in output. Output compare mode:
            TIM5_CCMR3: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  OC5FE
                OC5FE: u1,
                ///  OC5PE
                OC5PE: u1,
                ///  OC5M
                OC5M: u3,
                ///  OC5CE
                OC5CE: u1,
                reserved10: u2,
                ///  OC6FE
                OC6FE: u1,
                ///  OC6PE
                OC6PE: u1,
                ///  OC6M
                OC6M: u3,
                ///  OC6CE
                OC6CE: u1,
                ///  OC5M3
                OC5M3: u1,
                reserved24: u7,
                ///  OC6M3
                OC6M3: u1,
                padding: u7,
            }),
            ///  TIM5 capture/compare register 5
            TIM5_CCR5: mmio.Mmio(packed struct(u32) {
                ///  CCR5
                CCR5: u16,
                reserved29: u13,
                ///  GC5C1
                GC5C1: u1,
                ///  GC5C2
                GC5C2: u1,
                ///  GC5C3
                GC5C3: u1,
            }),
            ///  TIM5 capture/compare register 6
            TIM5_CCR6: mmio.Mmio(packed struct(u16) {
                ///  CCR6
                CCR6: u16,
            }),
        };

        ///  SPDIFRX
        pub const SPDIFRX = extern struct {
            ///  Control register
            SPDIFRX_CR: mmio.Mmio(packed struct(u32) {
                ///  SPDIFRXEN
                SPDIFRXEN: u2,
                ///  RXDMAEN
                RXDMAEN: u1,
                ///  RXSTEO
                RXSTEO: u1,
                ///  DRFMT
                DRFMT: u2,
                ///  PMSK
                PMSK: u1,
                ///  VMSK
                VMSK: u1,
                ///  CUMSK
                CUMSK: u1,
                ///  PTMSK
                PTMSK: u1,
                ///  CBDMAEN
                CBDMAEN: u1,
                ///  CHSEL
                CHSEL: u1,
                ///  NBTR
                NBTR: u2,
                ///  WFA
                WFA: u1,
                reserved16: u1,
                ///  INSEL
                INSEL: u3,
                reserved20: u1,
                ///  CKSEN
                CKSEN: u1,
                ///  CKSBKPEN
                CKSBKPEN: u1,
                padding: u10,
            }),
            ///  Interrupt mask register
            SPDIFRX_IMR: mmio.Mmio(packed struct(u32) {
                ///  RXNEIE
                RXNEIE: u1,
                ///  CSRNEIE
                CSRNEIE: u1,
                ///  PERRIE
                PERRIE: u1,
                ///  OVRIE
                OVRIE: u1,
                ///  SBLKIE
                SBLKIE: u1,
                ///  SYNCDIE
                SYNCDIE: u1,
                ///  IFEIE
                IFEIE: u1,
                padding: u25,
            }),
            ///  Status register
            SPDIFRX_SR: mmio.Mmio(packed struct(u32) {
                ///  RXNE
                RXNE: u1,
                ///  CSRNE
                CSRNE: u1,
                ///  PERR
                PERR: u1,
                ///  OVR
                OVR: u1,
                ///  SBD
                SBD: u1,
                ///  SYNCD
                SYNCD: u1,
                ///  FERR
                FERR: u1,
                ///  SERR
                SERR: u1,
                ///  TERR
                TERR: u1,
                reserved16: u7,
                ///  WIDTH5
                WIDTH5: u15,
                padding: u1,
            }),
            ///  Interrupt flag clear register
            SPDIFRX_IFCR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  PERRCF
                PERRCF: u1,
                ///  OVRCF
                OVRCF: u1,
                ///  SBDCF
                SBDCF: u1,
                ///  SYNCDCF
                SYNCDCF: u1,
                padding: u26,
            }),
            ///  This register can take 3 different formats according to DRFMT. Here is the format when DRFMT = 00:
            SPDIFRX_FMT0_DR: mmio.Mmio(packed struct(u32) {
                ///  DR
                DR: u24,
                ///  PE
                PE: u1,
                ///  V
                V: u1,
                ///  U
                U: u1,
                ///  C
                C: u1,
                ///  PT
                PT: u2,
                padding: u2,
            }),
            ///  Channel status register
            SPDIFRX_CSR: mmio.Mmio(packed struct(u32) {
                ///  USR
                USR: u16,
                ///  CS
                CS: u8,
                ///  SOB
                SOB: u1,
                padding: u7,
            }),
            ///  Debug information register
            SPDIFRX_DIR: mmio.Mmio(packed struct(u32) {
                ///  THI
                THI: u13,
                reserved16: u3,
                ///  TLO
                TLO: u13,
                padding: u3,
            }),
            reserved1012: [984]u8,
            ///  SPDIFRX version register
            SPDIFRX_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  SPDIFRX identification register
            SPDIFRX_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  SPDIFRX size identification register
            SPDIFRX_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };

        ///  SPI1
        pub const SPI1 = extern struct {
            ///  SPI/I2S control register 1
            SPI2S_CR1: mmio.Mmio(packed struct(u32) {
                ///  SPE
                SPE: u1,
                reserved8: u7,
                ///  MASRX
                MASRX: u1,
                ///  CSTART
                CSTART: u1,
                ///  CSUSP
                CSUSP: u1,
                ///  HDDIR
                HDDIR: u1,
                ///  SSI
                SSI: u1,
                ///  CRC33_17
                CRC33_17: u1,
                ///  RCRCINI
                RCRCINI: u1,
                ///  TCRCINI
                TCRCINI: u1,
                ///  IOLOCK
                IOLOCK: u1,
                padding: u15,
            }),
            ///  SPI control register 2
            SPI_CR2: mmio.Mmio(packed struct(u32) {
                ///  TSIZE
                TSIZE: u16,
                ///  TSER
                TSER: u16,
            }),
            ///  Content of this register is write protected when SPI is enabled
            SPI_CFG1: mmio.Mmio(packed struct(u32) {
                ///  DSIZE
                DSIZE: u5,
                ///  FTHLV
                FTHLV: u4,
                ///  UDRCFG
                UDRCFG: u2,
                ///  UDRDET
                UDRDET: u2,
                reserved14: u1,
                ///  RXDMAEN
                RXDMAEN: u1,
                ///  TXDMAEN
                TXDMAEN: u1,
                ///  CRCSIZE
                CRCSIZE: u5,
                reserved22: u1,
                ///  CRCEN
                CRCEN: u1,
                reserved28: u5,
                ///  MBR
                MBR: u3,
                padding: u1,
            }),
            ///  The content of this register is write protected when SPI is enabled or IOLOCK bit is set at SPI2S_CR1 register.
            SPI_CFG2: mmio.Mmio(packed struct(u32) {
                ///  MSSI
                MSSI: u4,
                ///  MIDI
                MIDI: u4,
                reserved15: u7,
                ///  IOSWP
                IOSWP: u1,
                reserved17: u1,
                ///  COMM
                COMM: u2,
                ///  SP
                SP: u3,
                ///  MASTER
                MASTER: u1,
                ///  LSBFRST
                LSBFRST: u1,
                ///  CPHA
                CPHA: u1,
                ///  CPOL
                CPOL: u1,
                ///  SSM
                SSM: u1,
                reserved28: u1,
                ///  SSIOP
                SSIOP: u1,
                ///  SSOE
                SSOE: u1,
                ///  SSOM
                SSOM: u1,
                ///  AFCNTR
                AFCNTR: u1,
            }),
            ///  SPI/I2S interrupt enable register
            SPI2S_IER: mmio.Mmio(packed struct(u32) {
                ///  RXPIE
                RXPIE: u1,
                ///  TXPIE
                TXPIE: u1,
                ///  DXPIE
                DXPIE: u1,
                ///  EOTIE
                EOTIE: u1,
                ///  TXTFIE
                TXTFIE: u1,
                ///  UDRIE
                UDRIE: u1,
                ///  OVRIE
                OVRIE: u1,
                ///  CRCEIE
                CRCEIE: u1,
                ///  TIFREIE
                TIFREIE: u1,
                ///  MODFIE
                MODFIE: u1,
                ///  TSERFIE
                TSERFIE: u1,
                padding: u21,
            }),
            ///  SPI/I2S status register
            SPI2S_SR: mmio.Mmio(packed struct(u32) {
                ///  RXP
                RXP: u1,
                ///  TXP
                TXP: u1,
                ///  DXP
                DXP: u1,
                ///  EOT
                EOT: u1,
                ///  TXTF
                TXTF: u1,
                ///  UDR
                UDR: u1,
                ///  OVR
                OVR: u1,
                ///  CRCE
                CRCE: u1,
                ///  TIFRE
                TIFRE: u1,
                ///  MODF
                MODF: u1,
                ///  TSERF
                TSERF: u1,
                ///  SUSP
                SUSP: u1,
                ///  TXC
                TXC: u1,
                ///  RXPLVL
                RXPLVL: u2,
                ///  RXWNE
                RXWNE: u1,
                ///  CTSIZE
                CTSIZE: u16,
            }),
            ///  SPI/I2S interrupt/status flags clear register
            SPI2S_IFCR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  EOTC
                EOTC: u1,
                ///  TXTFC
                TXTFC: u1,
                ///  UDRC
                UDRC: u1,
                ///  OVRC
                OVRC: u1,
                ///  CRCEC
                CRCEC: u1,
                ///  TIFREC
                TIFREC: u1,
                ///  MODFC
                MODFC: u1,
                ///  TSERFC
                TSERFC: u1,
                ///  SUSPC
                SUSPC: u1,
                padding: u20,
            }),
            reserved32: [4]u8,
            ///  SPI/I2S transmit data register
            SPI2S_TXDR: mmio.Mmio(packed struct(u32) {
                ///  TXDR
                TXDR: u32,
            }),
            reserved48: [12]u8,
            ///  SPI/I2S receive data register
            SPI2S_RXDR: mmio.Mmio(packed struct(u32) {
                ///  RXDR
                RXDR: u32,
            }),
            reserved64: [12]u8,
            ///  SPI polynomial register
            SPI_CRCPOLY: mmio.Mmio(packed struct(u32) {
                ///  CRCPOLY
                CRCPOLY: u32,
            }),
            ///  SPI transmitter CRC register
            SPI_TXCRC: mmio.Mmio(packed struct(u32) {
                ///  TXCRC
                TXCRC: u32,
            }),
            ///  SPI receiver CRC register
            SPI_RXCRC: mmio.Mmio(packed struct(u32) {
                ///  RXCRC
                RXCRC: u32,
            }),
            ///  SPI underrun data register
            SPI_UDRDR: mmio.Mmio(packed struct(u32) {
                ///  UDRDR
                UDRDR: u32,
            }),
            ///  All documented bits in this register must be configured when the I2S is disabled (SPE = 0).These bits are not used in SPI mode except for I2SMOD which needs to be set to 0 in SPI mode.
            SPI_I2SCFGR: mmio.Mmio(packed struct(u32) {
                ///  I2SMOD
                I2SMOD: u1,
                ///  I2SCFG
                I2SCFG: u3,
                ///  I2SSTD
                I2SSTD: u2,
                reserved7: u1,
                ///  PCMSYNC
                PCMSYNC: u1,
                ///  DATLEN
                DATLEN: u2,
                ///  CHLEN
                CHLEN: u1,
                ///  CKPOL
                CKPOL: u1,
                ///  FIXCH
                FIXCH: u1,
                ///  WSINV
                WSINV: u1,
                ///  DATFMT
                DATFMT: u1,
                reserved16: u1,
                ///  I2SDIV
                I2SDIV: u8,
                ///  ODD
                ODD: u1,
                ///  MCKOE
                MCKOE: u1,
                padding: u6,
            }),
            reserved1008: [924]u8,
            ///  SPI/I2S hardware configuration register
            SPI_I2S_HWCFGR: mmio.Mmio(packed struct(u32) {
                ///  TXFCFG
                TXFCFG: u4,
                ///  RXFCFG
                RXFCFG: u4,
                ///  CRCCFG
                CRCCFG: u4,
                ///  I2SCFG
                I2SCFG: u4,
                ///  DSCFG
                DSCFG: u4,
                padding: u12,
            }),
            ///  SPI/I2S version register
            SPI_VERR: mmio.Mmio(packed struct(u32) {
                ///  MINREV
                MINREV: u4,
                ///  MAJREV
                MAJREV: u4,
                padding: u24,
            }),
            ///  SPI/I2S identification register
            SPI_IPIDR: mmio.Mmio(packed struct(u32) {
                ///  ID
                ID: u32,
            }),
            ///  SPI/I2S size identification register
            SPI_SIDR: mmio.Mmio(packed struct(u32) {
                ///  SID
                SID: u32,
            }),
        };
    };
};
